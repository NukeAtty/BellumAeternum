<!DOCTYPE html>
<html lang="zh-Hans">
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" type="text/css" href="../../style.css">
	<meta name="description" content="红色警戒2：尤里的复仇原版AI案例分析，提供最全面的原版AI参考。">
	<link rel="icon" type="image/svg" href="../../src/favicon.svg">
	<meta name="robots" content="noindex, nofollow">
	<title>Phobos中文教程 | 万世之战：为红警2带来前所未有的体验</title>
	<style>
		#version {
			vertical-align: middle;
			font-size: 12px;
			font-family: monospace;
			background-color: #f00;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: center;
			line-height: 16px;
		}

		.collapsible #version {
			vertical-align: middle;
			font-size: 12px;
			font-family: monospace;
			background-color: #f00;
			border-radius: 4px;
			padding: 1px 4px;
			margin: 0 0.5em;
			color: #ccc;
			text-align: left;
			line-height: 1em;
		}

		#versionx {
			vertical-align: middle;
			font-size: 12px;
			font-family: monospace;
			background-color: #900;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: center;
			line-height: 16px;	
		}

		.collapsible #versionx {
			vertical-align: top;
			font-size: 12px;
			font-family: monospace;
			background-color: #900;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: left;
			line-height: 20px;
		}

		code {
			font-family: monospace;
			font-size: 12px;
			font-weight: normal;
			border: 1px dotted #fff;
			border-radius: 4px;
			background-color: #000;
			padding: 0.2em 0.4em;
			margin: 0 0.2em 0 0;
			user-select: text;
			text-align: center;
		}

		#comment {
			border: 1px dashed #fff;
			font-size: 14px;
			font-weight: 100;
			padding: 0.2em;
			margin: 0.5em auto;
		}

		#alert {
			border: 1px dashed #fcc;
			font-size: 14px;
			font-weight: normal;
			padding: 0.2em;
			background-color: #933;
			margin: 0.5em auto;
		}

		#highlight {
			border: 1px solid #fff;
			font-size: 14px;
			font-weight: bold;
			padding: 0.2em;
			background-color: #c93;
			margin: 0.5em auto;
			border-radius: 2px;
			text-align:center;
			text-shadow: 0 1px 1px #000;
		}

		.blog-content h4{
			font-size: 18px;
			margin: 2px auto;
		}

		.blog-content h5{
			font-size: 20px;
			font-weight: bold;
			line-height: 1em;
			margin: 1em auto;
		}

		.blog-content h5:before {
			content:'\2605';
			color: #f00;
		}

		.index-navigator {
			width: 50%;
			margin: 1em 0;
			padding-right: 2vw;
			background-color: #999;
			border: 1px solid #fff;
		}

		.index-navigator a {
			font-size: 18px;
			font-weight: bold;
			color: #fff;
			text-decoration: none;
			text-shadow: 1px 1px 1px #333;
		}
	</style>
</head>
<body>
	<header>
		<div class="navigation-buttons">
			<div class="navigation-button">
				<a href="https://ra2be.com/zh">主页</a>
			</div>
			<div class="navigation-button">
				<a href="../archives.html">档案库</a>
			</div>
			<div class="navigation-button">
				<a href="../blog.html">博客</a>
			</div>
			<div class="navigation-button">
				<a href="../download.html">下载</a>
			</div>
		</div>
		<div class="responsive-navigation">
			<a href="https://ra2be.com/zh"><img src="../../src/favicon.svg" alt="logo" width="36px" height="36px"></a>
			<div class="responsive-navigation-buttons">
				<a href="../archives.html">档案库</a>
				<a href="../blog.html">博客</a>
				<a href="../download.html">下载</a>
			</div>
		</div>
	</header>
	<!--Main-->
	<main>
		<div class="blog">
			<h1></h1>
			<div class="blog-info">
				<div class="update-time">
					<p>最后更新时间：<time datetime="2024-11-19 18:00">2024/11/19</time></p>
				</div>
			</div>			
			<div class="blog-main">
				<div class="blog-left">
					<div class="blog-info"></div>
					<div class="chap-nav">
						<p>快速导航</p>
						<div class="chaps">
							<a id="h2" href="#new-enhanced-logic">全新或增强的逻辑</a>
							<a id="h2" href="#fixed-logic">修复或改善的逻辑</a>
							<a id="h2" href="#ai-script">AI编写和地图编辑</a>
							<a id="h2" href="#user-interface">用户图形界面</a>
							<a id="h2" href="#misc">杂项</a>
						</div>
					</div>
				</div>
				<div class="blog-content">
					<h1>Phobos中文教程</h1>
					<h2>前言</h2>
					<h3>关于教程</h3>
					<p>本教程基于Phobos的英文版教程和中文版教程编撰，转载请署名nuke，并给出本页面的超链接。</p>
					<p>因为Phobos版本比较多，前言中会做出相应的介绍，以免实操的时候出现“货不对板”的情况。</p>
					<h3>Phobos的版本和说明</h3>
					<p>Phobos总共有三个类型：</p>
					<ol>
						<li>稳定版：通过大量测试，Bug最少的版本。时至教程编撰日期，Phobos的稳定版本号为v0.3.0.1。</li>
						<li>开发版：通过测试，Bug比较少的版本。时至教程编撰日期，Phobos的开发版为b44。</li>
						<li>测试版：集合了最新功能，但可能存在Bug。</li>
					</ol>
					<p>如果是新入门的Modder，比较推荐使用稳定版。如果是比较有经验的Modder，推荐使用功能更多的开发版。如果是深度精通代码的Modder可以使用测试版，但这类Modder通常能看懂原文，所以不做讨论。</p>
					<p>本教程所有的内容都会以v0.3.0.1稳定版作为基础，开发版相关的内容会以<span id="version">DEV</span>的标签标记，意为开发版。如果是只有测试版才有的功能，在教程中会标注<span id="versionx">N/A</span>的标签标记，意为暂时无法直接下载使用。</p>
					<h3>代码术语目录表</h3>
					<ul>
						<li>布尔值（Boolean）：开关参数值，填入true或false，或者yes或no。</li>
						<li>列表（List）：多个值的集合，用英文的逗号<code>,</code>隔开。</li>
						<li>浮点值（Float）：指的是用小数表示任意实数的值，比如1为整数，其浮点值就要写为1.0或者1.00等待小数点的值。</li>
					</ul>
					<h3>红警相关术语目录表：</h3>
					<ul>
						<li>对象（ObjectType）：所有游戏内可视物的总称，包括单位、动画、粒子、地形、覆盖物、污染等。</li>
						<li>单位（TechnoType）：建筑、步兵、载具和飞行器的总称。</li>
						<li>建筑插件（PowersUp）：指的是类似泰伯利亚之日中GDI发电厂涡轮、必须以其他建筑为基础才能放置的建筑。</li>
					</ul>
					<!--New Logic-->
					<h2 id="new-enhanced-logic">全新或增强的逻辑</h2>
					<p>全新或增强的逻辑章节包含了Phobos新增的机制以及一些有显著增强或扩展的旧机制，一共有分为以下类型：</p>
					<div class="index-navigator">
						<ul>
							<li><a href="#new-logic-new-types">新的机制</a></li>
							<li><a href="#new-logic-animations">动画</a></li>
							<li><a href="#new-logic-buildings">建筑</a></li>
							<li><a href="#new-logic-infantries">步兵</a></li>
							<li><a href="#new-logic-projectiles">抛射体</a></li>
							<li><a href="#new-logic-superweapons">超级武器</a></li>
							<li><a href="#new-logic-technos">单位</a></li>
							<li><a href="#new-logic-terrains">地形</a></li>
							<li><a href="#new-logic-warheads">弹头</a></li>
							<li><a href="#new-logic-weapons">武器</a></li>
						</ul>
					</div>
					<h3 id="new-logic-new-types">新的机制</h3>
					<h4 type="button" class="collapsible">附加效果（AE）<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>和Ares的附加效果逻辑类似，但Phobos的附加效果逻辑可以明确地定义类型。</p>
						<p><code>Duration</code>定义该附加效果可以持续多长时间，可以被单位和弹头上的<span>DurationOverrides</span>覆盖。数据类型为整数，单位为帧，可以填入负数代表不定时长。</p>
						<p><code>Cumulative</code>定义该附加效果的时长是否可叠加，参数为布尔值。如果被设置为<code>True</code>，表示相同附加效果的存在时长可以叠加。</p>
						<p><code>Cumulative.MaxCount</code>定义该附加效果的最大叠加层数。为正整数来定义相同附加效果可以叠加的层数，如果设为负数，相同附加效果则可以无限叠加。如果某单位的附加效果已经达到了可携带的最高层数但继续附加，则最新的附加效果会替换掉持续时长最短的效果。</p>
						<p><code>Powered</code>定义拥有该附加效果的单位在<abbr title="遥控坦克断电或被电磁脉冲击中">瘫痪</abbr>中是否会改变附加效果的动画。</p>
						<p><code>DiscardOn</code>定义该附加效果会在什么条件下会消失，默认为<code>none</code>，可以填入多个参数，参数详解如下：</p>
						<ul>
							<li><code>entry</code>：单位离开地图时，如进入建筑或进入载具。</li>
							<li><code>move</code>：单位移动时，如果是建筑则无视这个效果。</li>
							<li><code>stationary</code>：单位静止时，如果是建筑则无视这个效果。</li>
							<li><code>drain</code>：单位被带有<code>DrainWeapon=true</code>的吸取武器攻击时。</li>
							<li><code>inrange</code>：单位在附加效果来源的攻击范围之内时，可通过<code>DiscardOn.RangeOverride</code>来覆盖距离。</li>
							<li><code>outofrange</code>：单位在附加效果来源的攻击范围之外时，可通过<code>DiscardOn.RangeOverride</code>来覆盖距离。</li>
							<li><code>firing</code>：单位开火时，子机武器或吸取武器等特殊武器同样受影响。</li>
						</ul>
						<p><code>PenetratesIronCurtain</code>定义该附加效果是否对带有铁幕的单位有效，参数为布尔值。</p>
						<p><code>PenetratesForceShield</code>定义该附加效果是否对带有力场护盾的单位有效，参数为布尔值，默认为<code>PenetratesIronCurtain</code>的值。</p>
						<br>
						<p><code>Animation</code>定义该附加效果的动画，该动画会自动循环播放，无视Art.ini中的LoopCount。</p>
					</div>
					<h4 type="button" class="collapsible">自定义辐射类型</h4>
					<div class="col-content">
						<p>现在任何武器都可以拥有自定义的辐射类型。使用自定义辐射需要创建一个新的注册表<code>[RadiationTypes]</code>，并注册新的辐射名称。</p>
						<p><b>全局定义：</b></p>
						<p>开启自定义辐射参数需要在全局代码<code>[Radiation]</code>中加入<code>UseGlobalRadApplicationDelay</code>，参数为布尔值。如果设定为True，那么新增加的辐射会使用全局的辐射参数，反之设定为False，那么则可以定义辐射的属性。</p>
						<p><b>辐射定义：</b></p>
						<p><code>RadApplicationDelay.Building</code>定义该辐射类型的对建筑的效果，参数为整数，填入大于0的值将伤害建筑。</p>
						<p><code>RadBuildingDamageMaxCount</code><span id="version">DEV</span>限制辐射对建筑的最多伤害的次数，参数为整数。和<code>CellSpread</code>的机制类似，因为建筑通常占有多个地格，因此辐射也会对建筑造成每个地格叠加的伤害，所以需要用这段代码来控制伤害。填入负值代表不做限制。</p>
						<p><code>RadSiteWarhead.Detonate</code>定义是否让辐射的弹头附带其他弹头效果而不是单纯的伤害比例控制，参数为布尔值。原版中辐射场的弹头只用于伤害控制，因此单位走到辐射场中不会有受击的动画。</p>
						<p id="comment">笔者注：若非特殊需求建议把这个功能关掉，非常消耗性能。</p>
						<p><code>RadSiteWarhead.Detonate.Full</code>定义是否只保留弹头的范围伤害和Phobos专属的弹头效果，参数为布尔值。</p>
						<p><code>RadHasOwner</code>定义该辐射类型是否附带所属信息，填入布尔值。填入true则被该辐射所击杀的敌军单位会记录在玩家游戏数据中，同时也可以自定义其他相关的弹头设置，比如利用<code>AffectsAllies</code>来控制辐射是否影响友军。</p>
						<p><code>RadHasInvoker</code>定义该辐射类型是否附带击杀者信息，填入布尔值。填入true则释放该辐射的单位可以通过辐射击杀的单位获得经验值。</p>
						<p><b>为武器添加自定义辐射：</b></p>
						<p><code>RadType</code>：定义武器附带的辐射类型。</p>
						<p><b>代码示例：</b></p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Radiation]	;全局控制</p>
							<p>UseGlobalRadApplicationDelay=no ;开启自定义辐射参数</p>
							<br>
							<p>[RadiationTypes] ;新的注册表</p>
							<p>0=NewRadiation ;注册新的辐射类型</p>
							<br>
							<p>[NewWeapon] ;带辐射的武器</p>
							<p>RadType=NewRadiation ;辐射类型</p>
							<p>RadLevel=200 ;辐射量，一定要高于RadLevelDelay的值。</p>
							<br>
							<p>[NewRadiation] ;定义新的辐射类型</p>
							<p>RadDurationMultiple=1 ;控制辐射的存续时间，公式为RadLevel * RadDurationMultiple<p>
							<p>RadApplicationDelay=16 ;控制辐射造成伤害的间隔</p>
							<p>RadApplicationDelay.Building=32 ;控制辐射对建筑造成伤害的间隔</p>
							<p>RadBuildingDamageMaxCount=-1 ;控制辐射对建筑造成伤害的最高次数</p>
							<p>RadLevelMax=500 ;控制辐射的在单元格内最高值</p>
							<p>RadLevelDelay=90 ;重新计算辐射量的间隔</p>
							<p>RadLightDelay=90 ;重新计算辐射光照的间隔</p>
							<p>RadLevelFactor=0.2 ;辐射伤害参数，公式为RadLevel * RadLevelFactor</p>
							<p>RadLightFactor=0.1 ;辐射光照参数</p>
							<p>RadTintFactor=1.0 ;辐射染色参数</p>
							<p>RadColor=0,255,0  ;辐射颜色的RGB值</p>
							<p>RadSiteWarhead=RadSite ;辐射伤害的弹头</p>
							<p>RadSiteWarhead.Detonate=false ;辐射弹头效果是否开启</p>
							<p>RadSiteWarhead.Detonate.Full=true ;是否开启全部弹头效果</p>
							<p>RadHasOwner=true ;辐射是否带所属</p>
							<p>RadHasInvoker=true ;辐射击杀是否给辐射源单位经验</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">激光拖尾</h4>
					<div class="col-content">
						<p>激光拖尾是一种全新的拖尾方式，其可定义透明度、宽度和颜色。</p>
						<p>激光拖尾可以使用在单位、抛射体和VXL碎片上。</p>
						<p>附着对象是单位时支持多个激光拖尾，并可以定义其FLH坐标。对于有多个组件（如坦克的炮塔）的单位，可以自定义激光拖尾附着的部件。</p>
						<p><b>代码示例：</b></p>
						<p>在<code>art.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LaserTrailTypes] ;激光拖尾的注册表</p>
							<p>0=NewTrail ;注册新的激光拖尾</p>
							<br>
							<p>[NewTrail] ;定义新的激光拖尾</p>
							<p>IsHouseColor=false ;激光拖尾是否是所属色</p>
							<p>Color=255,0,0 ;激光拖尾的RGB颜色</p>
							<p>FadeDuration=64 ;激光拖尾持续的时间，值越大持续时间越长</p>
							<p>Thickness=4 ;激光拖尾的宽度</p>
							<p>SegmentLength=128 ;每一段激光的长度</p>
							<p>IgnoreVertical=false ;附着对象在垂直移动时不会产生激光拖尾</p>
							<p>IsIntense=false ;boolean, whether the laser is "supported" (AKA prism forwarding)</p>
							<p>CloakVisible=false ;附着对象在隐身之后是否会显示激光拖尾</p>
							<p>CloakVisible.DetectedOnly=false  ;附着对象在被探测到（非显形）后是否会显示激光拖尾</p>
							<br>
							<p>[NewProjectile] ;抛射体图像</p>
							<p>LaserTrail.Types=NewTrail ;抛射体的激光拖尾，可以使用列表表示多个拖尾。</p>
							<br>
							<p>[NewUnit] ;单位图像</p>
							<p>LaserTrail1.Types=NewTrail ;单位的第一条激光拖尾</p>
							<p>LaserTrail2.Type=NewTrail ;单位的第二条激光拖尾</p>
							<p>LaserTrail1.FLH=0,-50,0 ;第一条激光拖尾的起始坐标</p>
							<p>LaserTrail2.FLH=0,50,0 ;第二条激光拖尾的起始坐标</p>
							<p>LaserTrail1.IsOnTurret=false ;第一条激光拖尾是否附着在单位的炮塔上</p>
							<p>LaserTrail2.IsOnTurret=false ;第二条激光拖尾是否附着在单位的炮塔上</p>
						</div>
						<br>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewVoxelAnim] ;VXL碎片</p>
							<p>LaserTrail.Types=NewTrail  ;VXL碎片的激光拖尾，可以使用列表表示多个拖尾。</p>
						</div>
						<p id="alert">注意：激光拖尾非常消耗性能，因为游戏不存在GPU渲染，过多的激光拖尾会让游戏变得非常卡，不论你的电脑多高端。一、建议不要为单位或抛射体过多的挂激光拖尾；二、建议将<code>SegmentLength</code>尽量调高。三、建议将<code>FadeDuration</code>尽量调低。</p>
					</div>
					<h4 type="button" class="collapsible">护盾</h4>
					<div class="col-content">
						<h5>护盾的注册：</h5>
						<p>护盾作为一种新的对象，是需要新建一个注册表的。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ShieldTypes]</p>
							<p>1=NewShield</p>
						</div>
						<h5>护盾的定义：</h5>
						<p>护盾本质上可以看做是让单位拥有一个独立装甲和强度（血量）的第二血条，具备以下基础特性：</p>
						<ul>
							<li>护盾在下列状态下不会掉强度：
								<ol>
									<li>被超时空弹头攻击时</li>
									<li>在被铁幕或者力场护盾保护时</li>
									<li>单位拥有<code>Immune=true</code>时<span id="version">DEV</span></li>
									<li>单位被自身所免疫的弹头攻击时<span id="version">DEV</span></li>
									<li>单位被盟友攻击时<span id="version">DEV</span></li>
								</ol>
							</li>
							<li>护盾在未消失的情况下，负数伤害会修复护盾强度，届时所有的负数伤害会被护盾吸收。除非负数伤害的弹头带有<code>Shield.Penetrate=true</code>语句，否则无法在有护盾的情况下为单位增加血量。</li>
							<li>当单位拥有护盾时，护盾定义中的<code>Armor</code>将会代替单位本身的<code>Armor</code>来计算伤害。如果想关闭这个机制，可以用<code>InheritArmorFromTechno=true</code>来让单位本身的<code>Armor</code>覆盖护盾的<code>Armor</code>。</li>
							<li>护盾的初始强度使用<code>InitialStrength</code>来定义，这个值可以不等于最大强度。</li>
						</ul>
						<p>当单位执行部署变形（无论是原版的武装直升机逻辑还是Ares的单位转换）时，如果单位A和单位B都有护盾，那么变形后相应的护盾会按照百分比保留之前护盾强度值。但如果单位A有护盾而单位B没有护盾的情况，单位A的护盾的状态将会被封存，直到从单位B再变形为单位A继续生效。</p>
						<p><code>Powered</code>定义护盾是否受电磁脉冲和遥控坦克停电效果的影响，参数为布尔值，True为受影响，False为不受影响。</p>
						<p><code>AbsorbOverDamage</code>定义护盾是否可以抵挡超额伤害，参数为布尔值，True为可以抵挡，False为超额伤害算进单位自身血量。</p>
						<p><code>SelfHealing</code>定义护盾恢复强度的值，参数为浮点值或者百分比。填入0.0的情况下护盾不会自动恢复，填入百分比的情况下每次恢复百分比值的强度。填入负数的情况每次恢复将会扣除强度。如果你想让护盾每次恢复1点强度，可以填入1到2的任意浮点值，比如1.1。</p>
						<p><code>Respawn</code>定义护盾重生的强度值，参数和<code>SelfHealing</code>一致。</p>
						<p><code>SelfHealing.Rate</code>定义护盾恢复强度的间隔，参数为浮点值，单位为分钟（游戏内）。设置为0.0的时候直接将护盾恢复成满强度。</p>
						<p><code>Respawn.Rate</code>定义护盾重生的间隔，参数为浮点值，单位为每分钟（游戏内）。设置为0.0的时候直接生成一个满强度护盾。</p>
						<h5>护盾的图像：</h5>
						<p><code>IdleAnim</code>定义护盾生效时播放的动画，该动画会无视<code>LoopCount</code>无限循环，并可以用下列代码定义：</p>
						<ul>
							<li><code>IdleAnim.ConditionYellow</code>和<code>IdleAnim.ConditionRed</code>定义该护盾在强度值呈黄色和红色的状态下所播放的不同的护盾动画。如果不设置<code>IdleAnim.ConditionRed</code>，在血条呈红色时将会调用<code>IdleAnim.ConditionYellow</code>的动画；如果<code>IdleAnim.ConditionYellow</code>也不设置，将直接使用<code>IdleAnim</code>的动画。血条呈黄色和红色的百分比可以在<code>[AudioVisual]</code>中的<code>ConditionYellow</code>和<code>ConditionRed</code>中设置。</li>
							<li><code>IdleAnimDamaged</code>定义残血单位的护盾动画，同样可以用<code>IdleAnimDamaged.ConditionYellow</code>和<code>IdleAnimDamaged.ConditionRed</code>定义不同护盾值下的动画，使用和<code>IdleAnim</code>相同的默认值逻辑。</li>
							<li>避免使用带有<code>Bouncer=true</code>和<code>IsMeteor=true</code>的动画。</li>
						</ul>
						<p><code>IdleAnim.OfflineAction</code>定义单位停电时的护盾动画。</p>
						<p><code>IdleAnim.TemporalAction</code>定义单位在被超时空弹头击中后的护盾动画。</p>
						<p><code>BreakAnim</code>定义破盾动画。</p>
						<p><code>HitAnim</code>定义护盾的受击动画。</p>
						<p><code>HitFlash</code>定义护盾的受击闪光。可以在弹头上使用<code>Shield.HitFlash=false</code>来关闭闪光。伤害越高闪光越亮，同时可以在护盾中定义<code>HitFlash.FixedSize</code>来控制亮度（取值范围以4为增量，从81到252，范围之外无效）。闪光颜色可以用<code>HitFlash.Red/Green/Blue</code>来控制RGB色，参数为布尔值，表示开启或关闭该颜色。如果把<code>HitFlash.Black</code>设置为True，则闪光会变成黑色，并无视一切颜色控制。<span id="version">DEV</span></p>
						<p><code>BreakWeapon</code>定义破盾时释放的武器，武器会在单位的地格引爆。</p>
						<p><code>AbsorbPercent</code>定义护盾能承受伤害的百分比，参数为浮点值，默认为1.0，即全部承受。如果小于1.0，那么伤害将会穿破护盾，扣除相应的单位血量。</p>
						<p><code>PassPercent</code>定义护盾会被穿透的伤害的百分比，参数为浮点值，默认为0.0，即不会被穿透。</p>
						<p><code>AllowTransfer</code>定义护盾是否在单位变形（原版武装直升机逻辑或者Ares的变形逻辑）后继承，默认为true，即可以继承。</p>
						<p>带有<code>Psychedelic=yes</code>的弹头（神经毒气）默认无视护盾，如果没有<code>ImmuneToBerserk</code>，带护盾的单位一样会无差别攻击。同时，免疫神经毒气的单位也无法避免被该类型弹头作为目标，因此可以使用自定义护甲来避免这种情况发生。</p>
						<h5>护盾的界面：</h5>
						<p>有护盾的单位会显示血条和护盾条，如果护盾是可再生的，那么护盾强度即便归零也会呈现为一个空框。护盾的护盾条图像可以在在<code>[AudioVisual]</code>部分定义，下列代码是关于护盾条的定义：</p>
						<ul>
							<li>默认情况下，建筑的血条使用<span style="color:orange">pips.shp</span>的第6帧作为护盾条，其他单位则使用第17针作为护盾条。</li>
							<li><code>Pips.Shield</code>可以自定义非建筑单位的护盾条，<code>Pips.Shield.Building</code>定义建筑单位的护盾条，参数为整数，表示第几帧。如果只填入一个值，代表护盾条一直会显示该帧的样式，如果填入三个值，那么三个值分别表示“绿色护盾条”“黄色护盾条”和“红色护盾条”所用帧的样式。如果填入-1，那么则使用上述的默认值。</li>
							<li><code>Pips.Shield.Background</code>可以定义非建筑单位的护盾条边框，默认使用<span style="color:orange">pipbrd.shp</span>，第四帧被用作步兵的护盾条边框，第三帧被用作其他单位的护盾条边框。</li>
							<li><code>Pips.Shield.Building.Empty</code>可以定义建筑单位的护盾条非满格时的底色，默认使用<span style="color:orange">pips.shp</span>的第一帧。</li>
							<li><code>BracketDelta</code>可以定义护盾条的纵向位置，和原版<code>PixelSelectionBracketDelta</code>类似，负值向上移动，正值向下移动，单位为像素。对建筑无效。</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[AudioVisual]</p>
							<p>Pips.Shield=-1,-1,-1 ;单位的护盾条</p>
							<p>Pips.Shield.Building=-1,-1,-1 ;建筑的护盾条</p>
							<p>Pips.Shield.Background=PIPBRD.SHP ;护盾条边框</p>
							<p>Pips.Shield.Building.Empty=0 ;建筑上非满强度护盾的底色</p>
						</div>
						<p>如果你不想使用全局定义的护盾条，也可以在不同类型的护盾上做微观定义：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Shield]</p>
							<p>Pips=-1,-1,-1 ;单位的护盾条</p>
							<p>Pips.Building=-1,-1,-1 ;建筑的护盾条</p>
							<p>Pips.Background=pipbrd.shp ;护盾条边框</p>
							<p>Pips.Building.Empty=0 ;建筑上非满强度护盾的底色</p>
						</div>
						<h5>弹头相关设置：</h5>
						<p><code>Shield.Penetrate</code>定义该弹头是否能无视护盾直接对目标血量造成伤害。</p>
						<p><code>Shield.Break</code>定义该弹头是否能在伤害计算之前就破盾。</p>
						<p><code>Shield.BreakAnim</code>定义该弹头在破盾时的动画，这个设置将覆盖护盾中<code>BreakAnim</code>所定义的动画。</p>
						<p><code>Shield.HitAnim</code>定义该弹头在击中护盾时的动画，这个设置将覆盖护盾中<code>HitAnim</code>所定义的动画。</p>
						<p><code>Shield.BreakWeapon</code>定义该弹头破盾后的破盾武器，这个设置将覆盖护盾中<code>BreakWeapon</code>所定义的武器。</p>
						<p><code>Shield.AbsorbPercent</code>定义该弹头被护盾所吸收的量，这个设置将覆盖护盾中<code>AbsorbPercent</code>所定义的量。</p>
						<p><code>Shield.PassPercent</code>定义该弹头能穿过护盾伤害生命值的量，这个设置将覆盖护盾中<code>PassPercent</code>所定义的量。</p>
						<p><code>Shield.Respawn.Rate</code>和<code>Shield.Respawn.Amount</code>定义该弹头击中护盾后该护盾的再生间隔和再生耐久值，这个设置将覆盖护盾中<code>Respawn.Rate</code>和<code>Respawn.Amount</code>所定义的值，如果间隔填入负值或者再生值填入小于等于0的值将不会覆盖。这个效果的时长由<code>Shield.Respawn.Duration</code>控制。</p>
						<p><code>Shield.Respawn.ResetTimer</code>定义被该弹头击中的护盾的再生计时器是否重置，填入布尔值。</p>
						<p><code>Shield.SelfHealing.Rate</code>和<code>Shield.SelfHealing.Amount</code>定义被该弹头击中的护盾的耐久恢复间隔和耐久恢复值，这个设置将覆盖护盾中<code>SelfHealing.Rate</code>和<code>SelfHealing.Amount</code>所定义的值，如果间隔填入负值或者恢复值填入小于等于0的值将不会覆盖。这个效果的时长由<code>Shield.SelfHealing.Duration</code>控制。</p>
						<p><code>Shield.SelfHealing.ResetTimer</code>定义被该弹头击中的护盾的耐久恢复计时器是否重置，填入布尔值。</p>
						<p><code>Shield.AffectsTypes</code>定义会被该弹头的护盾修改器所影响的护盾，填入护盾类型，支持列表。</p>
						<p><code>Shield.AttachTypes</code>和<code>Shield.RemoveTypes</code>定义被（正<code>Verses</code>值的）该弹头击中后附加一个护盾或者移除一个护盾，填入护盾类型，支持列表，但通常只有列表中第一个护盾会生效。</p>
						<p><code>Shield.ReplaceOnly</code>定义<code>Shield.AttachTypes</code>中的护盾是否会按位置替换Shield.RemoveTypes中的护盾，参数为布尔值。如果前者少于后者，那么多余的被移除的护盾被前者的最后一个护盾替换。默认no。</p>
						<p><code>Shield.ReplaceNonRespawning</code>定义<code>Shield.AttachTypes</code>中的护盾是否会替换无法再生的护盾。</p>
						<p><code>Shield.MinimumReplaceDelay</code>定义<code>Shield.ReplaceNonRespawning</code>在多长时间之后替换之前无法再生的护盾。</p>
						<p><code>Shield.InheritStateOnReplace</code>定义用<code>Shield.ReplaceOnly</code>替换的护盾是否继承之前护盾的强度值，并重置再生计时器和强度恢复计时器。</p>
					</div>
					<h3 id="new-logic-animations">动画</h3>
					<h4 type="button" class="collapsible">动画生成单位</h4>
					<div class="col-content">
						<p>动画可以在播放完毕后在单元格内生成一个载具单位。开发版可支持生成载具、飞行器或步兵。</p>
						<p><code>CreateUnit</code>定义该动画生成的单位，只能填一个。</p>
						<p><code>CreateUnit.Owner</code>定义该动画生成的单位所属，只有在动画附带所属信息时才会生效。参数为下列预设值：</p>
						<ul>
							<li><code>Invoker</code>：调用动画的对象的所属方</li>
							<li><code>Killer</code>：摧毁该单位的所属方。</li>
							<li><code>Victim</code>：被摧毁单位的所属方。</li>
							<li><code>Civilian</code>：平民方。</li>
							<li><code>Special</code>：特殊方。</li>
							<li><code>Neutral</code>：中立方。</li>
							<li><code>Random</code>：随机。</li>
						</ul>
						<p>动画带有所属信息的方法如下：</p>
						<ul>
							<li>Phobos的<code>DestroyAnim</code></li>
							<li>弹头的<code>AnimList</code>和Phobos的弹头<code>SplashList</code></li>
							<li>41号地图触发动作</li>
						</ul>
						<p><code>CreateUnit.RemapAnim</code>定义该动画是否用单位调色盘绘制并且自带所属色，参数为布尔值。</p>
						<p><code>CreateUnit.Mission</code>定义该动画生成的单位出现后的任务。</p>
						<p><code>CreateUnit.AIMission</code>定义该动画生成的单位所属方是AI控制时的任务。<span id="versionx">N/A</span></p>
						<p><code>CreateUnit.Facing</code>定义该动画生成的单位朝向，参数为0-255的值，0为两点钟方向，224为12点钟方向。</p>
						<p><code>CreateUnit.RandomFacing</code>定义该动画生成的单位朝向是否随机，参数为布尔值。</p>
						<p><code>CreateUnit.InheritFacings</code>定义该动画生成的单位朝向是否继承生成该动画的单位，单位为布尔值。</p>
						<p><code>CreateUnit.InheritTurretFacings</code>定义该动画生成的单位炮塔朝向是否继承生成该动画的单位，单位为布尔值，不支持Jumpjet类载具（如直升机等）。</p>
						<p><code>CreateUnit.ConsiderPathfinding</code>定义该动画生成时如果该单元格有其他单位是否会在周边找一个合适的单元格生成，参数为布尔值。</p>
						<p><code>CreateUnit.AlwaysSpawnOnGround</code>定义该动画生成的单位是否在地面生成，即便动画在空中，参数为布尔值。如果填入false，那么在地面爆炸的Jumpjet类载具会自动起飞。<span id="version">DEV</span></p>
						<p><code>CreateUnit.SpawnParachutedInAir</code>定义该动画生成的单位如果是在空中生成，是否会用降落伞降落到地面，参数为布尔值。在<code>CreateUnit.AlwaysSpawnOnGround=true</code>存在时无效。</p>
						<p><code>CreateUnit.SpawnAnim</code>定义该动画生成单位之后所播放的动画，参数为动画注册名。</p>
						<p><code>CreateUnit.SpawnHeight</code>定义该动画生成的单位初始高度，参数为高度，</p>
					</div>
					<h4 type="button" class="collapsible">动画附加粒子系统<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>现在可以将粒子系统附加到动画中。和VoxelAnims的标签类似，只支持带有<code>BehavesLike=Smoke</code>的粒子系统。</p>
						<p>如果动画带有<code>Next</code>，则在下一个动画开始时该粒子系统会被删除。</p>
						<p><code>AttachedSystem</code>定义该动画附加的粒子系统，参数为粒子系统的注册名。</p>
						<p>代码示例（该代码来自万世之战中蒸汽机车头的开火动画）：</p>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TRNSMK] ;Smoke for Steam Locomotive</p>
							<p>AttachedSystem=TrainSmokeSys ;动画附带的粒子系统名</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">自定义动画可视方<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">独立的动画音效<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>建筑</h3>
					<h4 type="button" class="collapsible">自定义建筑延伸<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">建筑插件扩展</h4>
					<div class="col-content">
						<p><code>PowersUp.Owner</code>定义该建筑插件现在可以定义放置的建筑的所属方，需要注意的是当插件放入建筑后，插件的所属方自动变更为该建筑所属方。参数为预设值，可填入下列值：</p>
						<ul>
							<li><code>none</code>：不可放置</li>
							<li><code>owner</code>或者<code>self</code>：仅可放在自己的建筑上</li>
							<li><code>allies</code>或者<code>ally</code>：仅可放在盟友的建筑上</li>
							<li><code>team</code>：可以放在自己和盟友的建筑上</li>
							<li><code>enemies</code>或者<code>enemy</code>：仅可放在敌人的建筑上</li>
							<li><code>all</code>：自己、盟友和敌人的建筑上均可放置</li>
						</ul>
						<p><code>PowersUp.Buildings</code>定义该建筑插件可以放在哪些建筑上，参数为列表，可以填入多个建筑。</p>
						<p id="alert">注意：因技术限制，使用Phobos的<code>PowersUp.Buildings</code>时，该插件不支持Ares提供的插件作为建造前提功能。如果使用原版的<code>PowersUpBuilding</code>则可以提供这个功能，请自行取舍。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewUpgrade] ;插件建筑</p>
							<p>PowersUp.Owner=Self ;放置建筑允许的所属方</p>
							<p>PowersUp.Buildings=NAPOWR,NANRCT ;可以放置的建筑</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">可摧毁障碍建筑<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">电厂增幅器</h4>
					<div class="col-content">
						<p>当电厂增幅器存在于地图上时，会改变该所属方的电厂电量，如果电厂增幅器被摧毁，电量则会回归原本数值。</p>
						<p>电厂增幅器和电厂最大的区别就在于，电厂是直接增减总电量，而电厂增幅器需要在有电厂的情况下才会改变总电量。</p>
						<p>代码展示：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NAPWRE] ;Power Enhancer</p>
							<p>PowerPlantEnhancer.PowerPlants=NAPOWR,NANRCT ;可以增幅的电厂</p>
							<p>PowerPlantEnhancer.Amount=0 ;增幅电力的量</p>
							<p>PowerPlantEnhancer.Factor=1.5 ;增幅电力的倍数</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">间谍效果<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<!--Enhanced Infantries-->
					<h3 id="new-logic-infantries">步兵</h3>
					<h4 type="button" class="collapsible">匍匐/部署步兵开火坐标</h4>
					<div class="col-content">
						<p>现在步兵在匍匐开火或部署开火时可以使用新的开火坐标定位来覆盖<code>PrimaryFireFLH</code>和<code>SecondaryFireFLH</code>，同时也可以自定义Burst开火时每一发的开火坐标。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[E1]</p>
							<p>PronePrimaryFireFLH=0,0,0 ;主武器匍匐开火时的坐标</p>
							<p>ProneSecondaryFireFLH=0,0,0 ;副武器匍匐开火时的坐标</p>
							<p>DeployedPrimaryFireFLH=0,0,0 ;主武器部署开火时的坐标</p>
							<p>DeployedSecondaryFireFLH=0,0,0 ;副武器部署开火时的坐标</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">默认间谍伪装</h4>
					<div class="col-content">
						<p>步兵现在可以使用<code>DefaultDisguise</code>微观定义默认的间谍伪装，读取阵营高于Ares中阵营的<code>DefaultDisguise</code>。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[SSPY] ;Soviet Spy</p>
							<p>DefaultDisguise=E2 ;默认伪装的步兵</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">非人类步兵死亡动画</h4>
					<div class="col-content">
						<p>拥有<code>NotHuman=yes</code>标签的步兵现在在死亡时可以随机从动画序列中挑选<code>Die1</code>到<code>Die5</code>播放。注意，确保你的步兵是有这些动画序列的，如果没有，在死亡时将不会播放任何动画。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[YDOG] ;Yuri Dog</p>
							<p>NotHuman.RandomDeathSequence=yes ;是否播放随机死亡动画</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">分享弹药</h4>
					<div class="col-content">
						<p>如果一个带有<code>OpenTopped=yes</code>的载具使用了弹药机制（<code>Ammo</code>），同时乘员也使用了弹药机制，就可以让载具为乘员补充弹药，并可以定义哪些乘员才可以补充弹药。注意，载具必须可以自动补充弹药。</p>
						<p><code>Ammo.Shared</code>定义乘员和载具是否分享弹药，参数为布尔值。</p>
						<p><code>Ammo.Shared.Group</code>定义该弹药的分组，相当于规定弹药的规格，参数为整数。只有乘员和载具设置了相同的数值时才可以分享弹药。填入-1则载具可以给所有乘员补充弹药。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[BFRT] ;Battle Fortress</p>
							<p>...</p>
							<p>OpenTopped=yes ;乘员是否可以向外射击</p>
							<p>Ammo=5 ;弹药</p>
							<p>Reload=120 ;装填时间</p>
							<p>Ammo.Shared=yes ;是否分享弹药</p>
							<p>Ammo.Shared.Group=1 ;弹药分组</p>
							<br>
							<p>[SNIPE] ;Sniper</p>
							<p>Ammo.Shared=yes ;是否分享弹药</p>
							<p>Ammo.Shared.Group=1 ;弹药分组</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">奴隶阵营自定义</h4>
					<div class="col-content">
						<p>现在可以自定义奴隶矿场被摧毁后奴隶的归属。</p>
						<p><code>Slaved.OwnerWhenMasterKilled</code>定义奴隶矿场被摧毁后奴隶的归属，参数为以下预设值：</p>
						<ul>
							<li><code>suicide</code>：奴隶在奴隶矿场被摧毁后死亡。</li>
							<li><code>master</code>：奴隶在奴隶矿场被摧毁后归属奴隶矿场的所属方。</li>
							<li><code>neutral</code>：奴隶在奴隶矿场被摧毁后归属中立方。</li>
							<li><code>killer</code>：奴隶在奴隶矿场被摧毁后归属摧毁奴隶矿场的所属方。（原版方案）</li>
						</ul>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div id="slaves-house" class="code-presentation">
							<p>[SLAV]</p>
							<p>Slaved=yes ;是否为奴隶</p>
							<p>Slaved.OwnerWhenMasterKilled=killer ;奴隶矿场被摧毁后的归属方</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">自定义奴隶解救语音<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">在水中使用陆地动作序列<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<!--Enhanced Projectile-->
					<h3 id="new-logic-projectiles">抛射体</h3>
					<h4 type="button" class="collapsible">抛射体拦截</h4>
					<div class="col-content">
						<p>现在Phobos实现了类似《将军：绝命时刻》中美国复仇者防空车的抛射体拦截功能。拥有此功能的单位会自动扫描射程内可以拦截的抛射体，并使用相应的武器进行拦截。</p>
						<h5>抛射体的定义：</h5>
						<p><code>Interceptable</code>定义该抛射体是否可以被拦截，参数为布尔值。</p>
						<p><code>Armor</code>定义该抛射体所使用的装甲。</p>
						<p><code>Strength</code>定义该抛射体的血量，血量被将至0或以下抛射体引爆。</p>
						<p><code>Interceptable.DeleteOnIntercept</code>定义该抛射体在被摧毁时是否会直接被删除而不会引爆弹头。</p>
						<p><code>Interceptable.WeaponOverride</code>将会覆盖该弹头被拦截后引爆的武器，拦截单位上的相同设置拥有更高优先级。</p>
						<h5>拦截单位的定义：</h5>
						<p><code>Interceptor</code>定义该单位是否可以拦截抛射体，参数为布尔值。</p>
						<p><code>Interceptor.Weapon</code>定义该单位用哪个武器拦截抛射体，参数为0或1，0代表主武器，1代表副武器。根据拦截抛射体的高度，拦截武器的抛射体可能需要加入<code>AG=yes</code>和<code>AA=yes</code>。</p>
						<p><code>Interceptor.CanTargetHouses</code>定义该单位可以拦截哪些所属方的抛射体，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：不能拦截任何所属方的抛射体。</li>
							<li><code>owner/self</code>：只能拦截自己所发射的抛射体。</li>
							<li><code>allies/ally</code>：只能拦截盟友的抛射体。</li>
							<li><code>team</code>：可以拦截自己和盟友所发射的抛射体。</li>
							<li><code>enemies/enemy</code>：可以拦截敌人所发射的抛射体。</li>
							<li><code>all</code>：可以拦截所有所属方的抛射体。</li>
						</ul>
						<p><code>Interceptor.GuardRange</code>定义该单位对抛射体的警戒范围，同时可以用<code>Interceptor.RookieGuardRange</code>定义新兵等级的警戒范围、<code>Interceptor.VeteranGuardRange</code>定义老兵等级的警戒范围、<code>Interceptor.EliteGuardRange</code>定义精英等级的警戒范围，参数为浮点值。</p>
						<p><code>Interceptor.MinimumGuardRange</code>定义该单位对抛射体的最近警戒范围，同时可以用<code>Interceptor.RookieMinimumGuardRange</code>定义新兵登记的最近警戒范围、<code>Interceptor.VeteranMinimumGuardRange</code>定义老兵等级的最近警戒范围、<code>Interceptor.EliteMinimumGuardRange</code>定义精英等级的最近警戒范围，参数为浮点值。</p>
						<p><code>Interceptable.DeleteOnIntercept</code>定义该单位是否可以在摧毁抛射体时直接删除该抛射体而不会引爆弹头，这将覆盖抛射体上的设定，参数为布尔值。</p>
						<p><code>Interceptable.WeaponOverride</code>将会覆盖拦截抛射体所引爆的武器，参数为武器注册名。</p>
						<p><code>Interceptor.WeaponReplaceProjectile</code>定义该单位拦截抛射体后是否会将该抛射体的性质改变为<code>Interceptable.WeaponOverride</code>的武器中定义的抛射体的性质，如<code>Image</code>和<code>Speed</code>，但不支持修改Ares所提供的粒子系统<code>AttachedSystem</code>，参数为布尔值。</p>
						<p><code>Interceptor.WeaponCumulativeDamage</code>定义该单位拦截抛射体并将抛射体的引爆武器覆盖后，引爆武器是否叠加该单位用于拦截抛射体的武器的伤害，参数为布尔值。</p>
						<p><code>Interceptor.KeepIntact</code>定义该单位拦截抛射体后被拦截的抛射体是否还可以沿着原先的轨迹继续移动，<code>Interceptable.WeaponOverride</code>等覆盖武器的效果此时不受影响，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewRocket]</p>
							<p>...</p>
							<p>Interceptable=true ;该抛射体是否可以被拦截</p>
							<p>Interceptable.DeleteOnIntercept=false ;该抛射体在被拦截后是否被直接删除</p>
							<p>Interceptable.WeaponOverride=DEMOBOMB ;该抛射体在被拦截后引爆的武器</p>
							<p>Strength=50</p>
							<p>Armor=special_2</p>
							<br>
							<p>[AVGR] ;Avenger</p>
							<p>...</p>
							<p>Primary=MachineGun</p>
							<p>Secondary=InterceptLaser</p>
							<p>Interceptor=true ;该单位是否是抛射体拦截单位</p>
							<p>Interceptor.Weapon=1 ;该单位用于拦截抛射体的武器</p>
							<p>Interceptor.CanTargetHouses=enemies ;该单位能拦截哪些阵营的抛射体</p>
							<p>Interceptor.GuardRange=3.0 ;该单位对抛射体的警戒范围</p>
							<p>Interceptor.VeteranGuardRange=3.5 ;老兵级别对抛射体的警戒范围</p>
							<p>Interceptor.EliteGuardRange=4.0 ;精英级别对抛射体的警戒范围</p>
							<p>Interceptor.MinimumGuardRange=0.0 ;该单位对抛射体的最近警戒范围</p>
							<p>Interceptor.VeteranMinimumGuardRange=0.0 ;老兵级别对抛射体的最近警戒范围</p>
							<p>Interceptor.EliteMinimumGuardRange=0.0 ;精英级别对抛射体的最近警戒范围</p>
							<p>Interceptor.DeleteOnIntercept=false ;是否直接删除抛射体</p>
							<p>Interceptor.WeaponOverride=SmallExplosion ;被拦截的抛射体引爆的武器</p>
							<p>Interceptor.WeaponReplaceProjectile=false ;是否改变抛射体性质</p>
							<p>Interceptor.WeaponCumulativeDamage=false ;是否叠加引爆伤害</p>
							<p>Interceptor.KeepIntact=false ;拦截后抛射体是否继续移动</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">弹道类抛射体</h4>
					<div class="col-content">
						<p>弹道类抛射体是一种全新的抛射体模式，其独立于四大抛射体（<code>Invisio</code>，<code>ROT</code>，<code>Arcing</code>，<code>Vertical</code>）之外，因此禁止和四大抛射体混用。目前弹道类抛射体只推出了两种弹道模式，即直线弹道和轰炸弹道。</p>
						<p><code>Trajectory</code>定义使用哪种弹道的抛射体，参数为弹道模式的预设名称，<code>Straight</code>为直线弹道（平射），<code>Bombard</code>为轰击弹道（曲射）。</p>
						<p><code>Trajectory.Speed</code>定义抛射体的速度，参数为浮点值。和原版在武器上用<code>Speed</code>控制速度不同，弹道类抛射体的速度需要再抛射体代码中定义。</p>
						<h5>直线弹道</h5>
						<p>如字面意义解释，直线弹道的弹体会以一条直线飞向目标。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.DetonationDistance</code>定义抛射体在离目标多少距离之外即被引爆，参数为浮点值，单位为单元格。填入0的情况下视为不设置最大距离。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.ApplyRangeModifiers</code>定义是否在武器射程增减（如附加效果）后对<code>Trajectory.Straight.DetonationDistance</code>的距离进行等值的增减，参数为布尔值。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.TargetSnapDistance</code>定义最远的预判距离，即在该距离之内，弹道会预判敌人的走向，参数为浮点值，单位为单元格。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.PassThrough</code>定义抛射体是否会在击中目标后不引爆弹头，而是朝着<code>Trajectory.Straight.DetonationDistance</code>所指定的距离继续飞行，参数为布尔值。这个设置将改变抛射体的角度，如果在同一高度抛射体则会直线飞行。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MGBullet]</p>
							<p>Trajectory=Straight ;使用直线弹道</p>
							<p>Trajectory.Speed=150.0 ;弹道速度</p>
							<p>Trajectory.Straight.DetonationDistance=0.4 ;抛射体自爆的最大距离</p>
							<p>Trajectory.Straight.ApplyRangeModifiers=false ;引爆距离是否根据武器射程变化而变化</p>
							<p>Trajectory.Straight.TargetSnapDistance=0.5 ;预判距离</p>
							<p>Trajectory.Straight.PassThrough=false ;击中目标是否穿透然后继续飞行</p>
						</div>
						<p id="comment">笔者注：直线弹道配合激光拖尾可以轻松实现机枪曳光弹效果，但为了命中率考虑弹道速度应该加大。</p>
						<h5>轰击弹道</h5>
						<p>和直线弹道类似，但抛射体会瞄准目标上方，发射后作自由落体下坠然后在目标引爆。</p>
						<p><code>Trajectory.Bombard.Height</code>定义抛射体会瞄准距离目标多高的位置，填入浮点值，单位为高度值</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Howitzer]</p>
							<p>Trajectory=Bombard ;使用轰炸弹道</p>
							<p>Trajectory.Bombard.Height=5.0 ;轰炸弹道的曲线高度</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">溅射逻辑扩展</h4>
					<div class="col-content">
						<p>溅射逻辑现在可以在地面或者建筑上触发。</p>
						<p><code>Shrapnel.AffectsGround</code>定义该抛射体在地面引爆时是否会触发溅射，参数为布尔值。</p>
						<p><code>Shrapnel.AffectsBuildings</code>定义该抛射体在建筑引爆时是否会触发溅射，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LargeCometP]</p>
							<p>ShrapnelWeapon=CometFragment ;溅射武器，需要在[WeaponTypes]注册</p>
							<p>ShrapnelCount=5 ;溅射数量</p>
							<p>Shrapnel.AffectsGround=true ;打到地面是否溅射</p>
							<p>Shrapnel.AffectsBuildings=true ;打到建筑是否溅射</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">抛射体阻挡逻辑扩展<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">末端反射武器<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 id="new-logic-superweapons">超级武器</h3>
					<h4 type="button" class="collapsible">AI使用超级武器延时<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">单位变形<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">电磁脉冲设定<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">虚拟投送</h4>
					<div class="col-content">
						<p>虚拟投送的定义是在地图之外投送一个建筑物，这个建筑物是无法在游戏中看到的，也无法被攻击。虚拟投送的目的是，在视觉上不建造建筑的情况下可以实现一些建筑的效果。</p>
						<p>和Ares的超级武器定义比较不同，它不受超级武器<code>Type</code>和释放坐标的限制。可以理解为超级武器的一个衍生功能。</p>
						<p><code>LimboDelivery.Types</code>定义该超级武器所投放的建筑类型，参数为建筑的注册名的列表。</p>
						<p><code>LimboDelivery.IDs</code>定义该超级武器所投放的建筑编号，参数为整数，目的是让建筑可以被摧毁。</p>
						<p><code>LimboKill.Affects</code>定义该超级武器可以移除哪一所属方的虚拟投送的建筑，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：没有阵营的虚拟建筑会被移除。</li>
							<li><code>owner/self</code>：移除使用该超级武器的阵营的虚拟投放建筑。</li>
							<li><code>allies/ally</code>：移除使用该超级武器的阵营的盟友的虚拟投放建筑。</li>
							<li><code>team</code>：移除使用该超级武器的阵营和其盟友的虚拟投放建筑。</li>
							<li><code>enemies/enemy</code>：移除使用该超级武器的阵营的敌人的虚拟投放建筑。</li>
							<li><code>all</code>：移除所有阵营的虚拟投放建筑。</li>
						</ul>
						<p><code>LimboKill.IDs</code>定义该超级武器可以移除什么编号的建筑，参数为整数。</p>
						<p><code>LimboDelivery.RollChance</code>定义每一个虚拟投放建筑被投放的概率，参数为百分比的列表。</p>
						<p><code>LimboDelivery.RandomWeightsN</code>定义第N个建筑的每次的权重增加，N为从序列数，从0开始，代表在<code>LimboDelivery.Types</code>建筑列表中的第几个建筑，参数为正整数，等于0时则不增加权重。</p>
						<p>虚拟投送的建筑并不支持所有的建筑功能，但以下功能是经过了测试的：</p>
						<ul>
							<li>工业工厂</li>
							<li>矿石精炼器</li>
							<li>间谍卫星</li>
							<li>续存（Ares3.0功能）</li>
							<li>建造前提</li>
							<li>超级武器前提</li>
						</ul>
						<p>如果希望这个建筑可作用于<a href="ai-tutorial.html#ai-trigger" target="_blank">AI触发前提中的“己方拥有某建筑”和“敌方拥有某建筑”</a>，需要为该投放的建筑添加<code>LegalTarget=yes</code>标签。</p>
						<p id="alert">记住，虚拟投放的建筑不存在于场上，也就是说这些建筑不应该拥有需要交互的逻辑（比如工厂、维修厂、克隆中心），也最好带上<code>KeepAlive=no</code>标签或者用<code>LimboKill.IDs</code>主动删除，不然游戏会永远无法正常结束。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ForceShieldSpecial] ;力场护盾</p>
							<p>...</p>
							<p>LimboDelivery.Types=GASPYSAT,GAOREP,NAINDP ;释放后虚拟投放的建筑</p>
							<p>LimboDelivery.IDs=1,2,3 ;三个建筑的ID</p>
							<p>LimboDelivery.RollChance=33%,33%,33% ;三个建筑被投放的概率</p>
							<p>LimboDelivery.RandomWeights0=10 ;间谍卫星的权重增量</p>
							<p>LimboDelivery.RandomWeights2=10 ;矿石精炼器的权重增量</p>
							<p>LimboDelivery.RandomWeights3=10 ;工业工厂的权重增量</p>
							<br>
							<p>[LimboKillSpecial] ;删除虚拟建筑超级武器</p>
							<p>...</p>
							<p>SW.AutoFire=yes ;自动发射</p>
							<p>...</p>
							<p>LimboKill.IDs=1,2,3 ;删除建筑的ID</p>
							<p>LimboKill.Affects=self ;删除建筑的所属方</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">超级武器连续释放<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">弹头和武器释放<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义超级武器栏目<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 id="new-logic-technos">单位</h3>
					<h4 type="button" class="collapsible">自动删除乘员</h4>
					<div class="col-content">
						<p>可装载乘员的载具可以逐渐删除乘员，乘员越多耗时越长，并可以像部队回收站那样使用。可以搭配Ares的超时空监狱效果实现自动清除被困的敌人。</p>
						<p><code>PassengerDeletion.Rate</code>定义多长时间删除一个乘员，参数为整数，单位为帧。</p>
						<p><code>PassengerDeletion.Rate.SizeMultiply</code>定义占据大于1的格子的单位是否需要更多时间来删除，时长等于<code>PassengerDeletion.Rate</code>乘以单位的<code>Size</code>，参数为布尔值。</p>
						<p><code>PassengerDeletion.Soylent</code>删除乘员是否返还金钱，参数为布尔值。</p>
						<p><code>PassengerDeletion.SoylentFriendlies</code>删除自己或盟友的乘员是否返还金钱，参数为布尔值。</p>
						<p><code>PassengerDeletion.ReportSound</code>删除乘员时播放的声音，参数为声音注册名。</p>
						<p><code>PassengerDeletion.Anim</code>删除乘员时的动画。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MGRD] ;Mobile Grinder</p>
							<p>...</p>
							<p>Passengers=3 ;乘员数量</p>
							<p>PipScale=Passengers ;乘员格子</p>
							<p>PassengerDeletion.Rate=1 ;删除一个乘员的间隔</p>
							<p>PassengerDeletion.Rate.SizeMultiply=false ;删除多格子乘员是否用更多时间</p>
							<p>PassengerDeletion.Soylent=true ;删除乘员是否返还金钱。</p>
							<p>PassengerDeletion.SoylentFriendlies=true ;删除友军乘员是否返还金钱。</p>
							<p>PassengerDeletion.ReportSound=GrinderGrinding ;删除乘员声音</p>
							<p>PassengerDeletion.Anim=UCINIT ;删除乘员动画</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">乘员同步载具的所属方</h4>
					<div class="col-content">
						<p>乘员的所属方会随着载具所属方的更改而更改。</p>
						<p><code>Passengers.SyncOwner</code>定义该载具的乘员是否会同步所属方，参数为布尔值，如果是乘员可以开火的载具被心灵控制时，乘员将重新选择目标。注意，通过<code>Abductor=true</code>获取的乘员无法使用该逻辑。</p>
						<p><code>Passengers.SyncOwner.RevertOnExit</code>定义该载具的乘员是否在卸载后将所属方变成上车前的所属方，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[FV]</p>
							<p>Passengers.SyncOwner=true ;是否同步乘员所属</p>
							<p>Passengers.SyncOwner.RevertOnExit=false ;乘员卸载后是否回归所属</p>
						</div>
						<p id="comment">笔者注：多功能步兵车在改变所属后乘员即便没有改变所属其炮塔和武器也不会改变，只有在卸载乘员之后乘员是原有所属方。另外，如果是通过脚本动作改变的所属方，即便会同步乘员，还是会有一个乘员不会改变所属。</p>
					</div>
					<h4 type="button" class="collapsible">自动开火武器</h4>
					<div class="col-content">
						<p>单位可以在不需要扫描目标的情况下自动开火，这样的开火模式要么选择单位所在的地格作为目标，要么选择单位自己作为目标。</p>
						<p><code>AutoFire</code>定义单位是否会自动开火，参数为布尔值，默认为对自己开火。</p>
						<p><code>AutoFire.TargetSelf</code>定义单位是否自动对自己开火，参数为布尔值，如果为false，单位则会对所在的地格自动开火。</p>
						<p>代码示例（改代码来自万世之战中的蒸汽机车头）：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LOCOMOTIVE]</p>
							<p>AutoFire=true ;单位是否自动开火</p>
							<p>AutoFire.TargetSelf=false ;单位是否对自身自动开火</p>
							<p>Primary=TrainSmoke ;自动开火的武器</p>
						</div>
						<p id="comment">这个功能最大的问题在于单位开火时，可以看到一条红色的攻击示意线。然而，这个功能最大的优势是可以附带FLH坐标，因可以看做是一个可以定义FLH坐标的动画生成器。万世之战的蒸汽机车就是用这个功能模拟冒烟效果。</p>
					</div>		
					<h4 type="button" class="collapsible">建造上限组<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义乘员开火</h4>
					<div class="col-content">
						<p>现在你可以微观定义乘员开火载具的属性，以覆盖宏观定义。</p>
						<p><code>OpenTopped.RangeBonus</code>定义乘员在载具内开火所获得额外的射程，参数为整数。</p>
						<p><code>OpenTopped.DamageMultiplier</code>定义乘员在载具内开火所获得的火力加成，参数为浮点值，伤害将乘以这个值。</p>
						<p><code>OpenTopped.WarpDistance</code>定义使用超时空武器的乘员在（从载具到目标）多少距离外武器停止攻击，参数为整数。</p>
						<p><code>OpenTopped.IgnoreRangefinding</code>定义载具是否会根据最近射程的乘员来接近目标，参数为布尔值。</p>
						<p><code>OpenTopped.AllowFiringIfDeactivated</code>定义载具在瘫痪（停电、EMP等）时乘员是否可以开火。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[BFRT] ;Battle Fortress</p>
							<p>...</p>
							<p>OpenTopped=yes</p>
							<p>OpenTopped.RangeBonus=1 ;乘员获得额外的射程</p>
							<p>OpenTopped.DamageMultiplier=1.1 ;乘员获得额外的火力</p>
							<p>OpenTopped.WarpDistance=7 ;超时空的最大距离</p>
							<p>OpenTopped.IgnoreRangefinding=true ;是否移动到所有乘员都能攻击到目标的距离</p>
							<p>OpenTopped.AllowFiringIfDeactivated=true ;是否在瘫痪后乘员依然可以开火</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">关闭副武器自动推算</h4>
					<div class="col-content">
						<p>在原版中，如果主武器不能攻击的情况下，单位会选择副武器攻击目标，而现在可以通过以下代码来关闭副武器自动推算。</p>
						<p><code>NoSecondaryWeaponFallback</code>定义是否关闭副武器自动推算，参数为布尔值。这个设置不能关闭手动设置的推算。</p>
						<p>所谓手动设置的推算，情况如下：</p>
						<ul>
							<li><code>OpenTransportWeapon=1</code>的单位进入可对外开火的载具所使用的武器，例如原版的重装步兵进入战斗要塞。</li>
							<li>带有Ares的<code>NoAmmoWeapon=1</code>的单位所使用的武器，例如万世之战中的战斗要塞。</li>
							<li><code>DeployFireWeapon=1</code>的单位部署后所使用的武器，例如原版的武装直升机。</li>
							<li>带有<code>DrainWeapon=true</code>的单位在吸建筑时的武器，例如原版的镭射飞碟。</li>
							<li>主武器带有<code>IsLocomotor=true</code>的弹头在攻击建筑时的武器，例如原版的磁电坦克。</li>
							<li>带有<code>ElectricAssault=true</code>的弹头在为线圈充能是的武器，例如原版的磁暴步兵。</li>
							<li>带有<code>Overpowerable=true</code>的建筑在充能时攻击所使用的武器，例如原版的磁暴线圈。</li>
							<li>使用多武器机制的单位所使用的武器，例如原版的盖特坦克或者多功能步兵车。</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[APOC] ;Apocalypse Tank</p>
							<p>Primary=120mmx</p>
							<p>Secondary=MammothTusk</p>
							<p>NoSecondaryWeaponFallback=true ;是否关闭副武器自动推算</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">间谍伪装逻辑扩展<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义Burst开火坐标</h4>
					<div class="col-content">
						<p>在原版中，如果武器带有<code>Burst=2</code>，并且在art中，单位开火坐标的第二个值不等于0，那么该武器就可以实现左右开弓发射这个武器的Burst。</p>
						<p>现在Phobos将这个功能做了更多拓展，可以定义每一个<code>Burst</code>的开火坐标。</p>
						<p><code>(Elite)(Prone/Deployed)PrimaryFire|SecondaryFire|WeaponX|FLH.BurstN</code>定义某个级别在某个状态下用某种武器的第N个Burst的坐标，参数为FLH，代码的组合方式如下：</p>
						<p id="highlight">A + B + C + .Burst + N</p>
						<p>其中，A可以带入以下代码：</p>
						<ul>
							<li><code>Elite</code>：代表精英级别时所用武器</li>
						</ul>
						<p>B可以带入以下代码：</p>
						<ul>
							<li><code>Prone</code>：代表步兵匍匐时</li>
							<li><code>Deployed</code>：代表步兵部署时</li>
						</ul>
						<p>C可以带入以下代码</p>
						<ul>
							<li><code>PrimaryFire</code>：代表主武器</li>
							<li><code>SecondaryFire</code>：代表副武器</li>
							<li><code>WeaponX</code>：代表多武器单位的第X个武器</li>
						</ul>
						<p>N代表第N个Burst，武器中有多少Burst就写多少个坐标。</p>
						<p>代码示例：</p>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[FV]</p>
							<p>EliteWeapon5.Burst1=170,50,90 ;多功能步兵车的第五个武器的第一个Burst的开火坐标</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">初始血量和克隆血量</h4>
					<div class="col-content">
						<p>单位现在可以自定义初始血量，即造出来后可以不是满血。当然，就算指定的初始血量高于单位的<code>Strength</code>，单位也不会初始拥有更多的血量。</p>
						<p><code>InitialStrength</code>定义单位在出厂后的血量，参数为整数。</p>
						<p><code>InitialStrength.Cloning</code>定义该带有<code>Cloning=yes</code>克隆建筑出厂的单位的初始血量，参数为小数、百分比或用英文逗号<code>,</code>隔开的范围值。如果是范围值，那么出厂单位将随机在范围内取值作为初始血量。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[INIT]</p>
							<p>Strength=100</p>
							<p>InitialStrength=91 ;初始血量</p>
							<br>
							<p>[NACLON]</p>
							<p>Cloning=yes</p>
							<p>InitialStrength.Cloning=50% ;克隆单位的初始血量</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">单位自动消失</h4>
					<div class="col-content">
						<p>单位可以在某些条件下自动消失，并且可以以不同的方式消失。</p>
						<p><code>AutoDeath.OnAmmoDepletion</code>定义单位是否在弹药耗尽后消失，参数为布尔值。</p>
						<p><code>AutoDeath.AfterDelay</code>定义单位是否在一定的时间后消失，参数为整数，单位为帧。</p>
						<p><code>AutoDeath.Behavior</code>定义单位以什么方式消失，参数为预设值，解释如下：</p>
						<ul>
							<li><code>kill</code>：被摧毁，一切摧毁相关的效果都会生效，比如爆炸动画和碎片。</li>
							<li><code>vanish</code>：直接删除，不会产生爆炸动画和碎片。</li>
							<li><code>sell</code>：被变卖，可获得金钱，建筑将会播放建造动画，不会产生爆炸动画和碎片。</li>
						</ul>
						<p>该逻辑支持虚拟投放超级武器，因此如果你想删除被虚拟投放的建筑，也可以在建筑上直接添加自动消失相关代码。</p>
						<p>代码示例（该代码来自万世之战的灰熊坦克残骸）：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GTNKWK] ;Grizzly Tank Wreckage</p>
							<p>...</p>
							<p>AutoDeath.OnAmmoDepletion=false ;单位是否在弹药耗尽时消失</p>
							<p>AutoDeath.AfterDelay=2000 ;单位在指定时间内消失</p>
							<p>AutoDeath.Behavior=kill</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">心灵控制扩展</h4>
					<div class="col-content">
						<p>Phobos为心灵控制提供了新的标签，以实现以下功能：</p>
						<ol>
							<li>心灵控制现在可以规定有效距离。</li>
							<li>如果单位有多个心灵控制槽，在控制了最大数目的单位时，再控制单位时可以释放第一个被控制的单位。</li>
							<li>可微观定义心灵控制的动画。</li>
						</ol>
						<p><code>MindControlRangeLimit</code>定义心灵控制的有效距离，参数为浮点值，填入大于0的数生效。</p>
						<p><code>MultiMindControl.ReleaseVictim</code>定义是否在心灵控制槽满了以后控制单位时，释放第一个被控制的单位。</p>
						<p><code>MindControl.Anim</code>定义被该弹头心灵控制的单位的动画，参数为动画注册名，将覆盖全局的<code>ControlledAnimationType</code>。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[YURI] ;Yuri</p>
							<p>...</p>
							<p>MindControlRangeLimit=10 ;心灵控制有效范围</p>
							<p>MultiMindControl.ReleaseVictim=true ;是否释放第一个心灵控制的单位</p>
							<br>
							<p>[Controller]	;Warhead</p>
							<p>...</p>
							<p>MindControl.Anim=MINDANIM ;心灵控制的动画</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">禁止手动移动</h4>
					<div class="col-content">
						<p>现在可以让一个单位完全无法手动移动。</p>
						<p><code>NoManualMove</code>定义该单位是否不可以手动移动，参数为布尔值。</p>
						<p>代码示例（该代码来自万世之战中灰熊坦克残骸）：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GTNKWK] ;Grizzly Tank Wreckage</p>
							<p>NoManualMove=true ;是否允许手动移动</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">强制特定武器对付特定目标</h4>
					<div class="col-content">
						<p>该功能将覆盖部分原版水下目标选取的逻辑。</p>
						<p><code>ForceWeapon.Naval.Decloaked</code>定义海军单位使用什么武器对付已经显形的水下单位，参数为整数，-1为关闭该功能，0为主武器，1为副武器。</p>
					</div>
					<h4 type="button" class="collapsible">全方位武器强制面向目标<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">子机升级</h4>
					<div class="col-content">
						<p>单位发射的子机现在可以设置为同步单位等级。</p>
						<p><code>Promote.IncludeSpawns</code>定义该单位的子机是否会同步该单位的等级，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CARRIER]</p>
							<p>Trainable=yes</p>
							<p>Promote.IncludeSpawns=true ;子机是否随着航母升级而升级</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">复仇武器<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">航母子机扩展</h4>
					<div class="col-content">
						<p>航母子机（飞行器类子机）现在可以增加最远航程、自定义子机补充速度以及子机起飞后直接执行攻击指令。</p>
						<p><code>Spawner.LimitRange</code>定义子机的航程是否被限制，参数为布尔值，航程由该单位子机武器的<code>Range</code>所决定。限制了航程的子机在单位远离目标时会放弃攻击指令直接返航。</p>
						<p><code>Spawner.ExtraLimitRange</code>定义子机可以在原有航程下增加多少格的航程，参数为整数，单位为单元格。</p>
						<p><code>Spawner.DelayFrames</code>定义子机的补充速度，参数为整数，单位为帧。这将直接覆盖原版写死的子机补充速度，即导弹类子机为9帧，其他类型子机为20帧。</p>
						<p><span id="version">DEV</span><code>Spawner.AttackImmediately</code>定义航母在释放子机后是否立刻进入攻击模式而不用等待其他子机释放，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CARRIER]</p>
							<p>Spawner.LimitRange=true ;航母子机是否限制航程</p>
							<p>Spawner.ExtraLimitRange=2 ;额外增加两格航程</p>
							<p>Spawner.DelayFrames=25 ;子机补充速度</p>
							<p>Spawner.AttackImmediately=true ;子机是否直接执行攻击指令</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">超时空传送武器</h4>
					<div class="col-content">
						<p>现在可以让武器在单位传送后开火，会在传送动画（<code>WarpIn</code>和<code>WarpOut</code>）播放的同时开火。</p>
						<p><code>WarpInWeapon</code>定义传送时开火的武器，参数值为武器注册名。</p>
						<p><code>WarpInMinRangeWeapon</code>定义在传送距离小于<code>ChronoRangeMinimum</code>时代替<code>WarpInWeapon</code>。它会无视<code>ChronoTrigger</code>设置与否而触发。如果未设置，默认为<code>WarpInWeapon</code>。</p>
						<p><code>WarpInWeapon.UseDistanceAsDamage</code>定义是否用超时空传送的单元格距离作为伤害，</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CLEG]</p>
							<p>WarpInWeapon=NeutronRifle ;超时空传送后发射的武器</p>
							<p>WarpInMinRangeWeapon=NeutronRifle ;超时空传送到最小距离后发射的武器</p>
							<p>WarpInWeapon.UseDistanceAsDamage=true ;是否用移动距离的单元格取代伤害</p>
							<p>WarpOutWeapon=NeutronRifle ;超时空传送前在原地发射的武器</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">单位自定义染色<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义单位变卖声音</h4>
					<div class="col-content">
						<p>当单位被变卖后，将会播放一个变卖音效和相应的EVA语音，现在可以微观定义这些声音。</p>
						<p><code>EVA.Sold</code>定义该单位被变卖的EVA语音，参数为EVA语音注册名，建筑默认是<code>EVA_StructureSold</code>，载具默认是<code>EVA_UnitSold</code>。</p>
						<p><code>SellSound</code>定义该单位被变卖的音效，参数为音效注册名，默认值为<code>[AudioVisual]</code>中的<code>SellSound</code>所定义的音效。注意，在原版中，载具的变卖音效是全局音效，Phobos将其修复为局部音效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[HTNK]</p>
							<p>EVA.Sold=EVA_TankSold</p>
							<p>SellSound=GrinderGrinding</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">单位出厂语音<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">单位升级动画<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">改变阵营时变形<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 id="new-logic-terrains">地形</h3>
					<h4 type="button" class="collapsible">摧毁动画和音效</h4>
					<div class="col-content">
						<p>现在可以设定地形对象的摧毁动画和音效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TREE01]</p>
							<p>DestroyAnim=TREEFALL ;地形对象被摧毁时的动画</p>
							<p>DestroySound=TreeFall ;地形对象被摧毁时的音效</p>
						</div>
					</div>
					<h3 id="new-logic-warheads">弹头</h3>
					<h4 type="button" class="collapsible">心控解除</h4>
					<div class="col-content">
						<p>心控解除弹头可以解除单位的心灵控制，但对永久心灵控制无效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MindControlReliever]</p>
							<p>...</p>
							<p>RemoveMindControl=true ;是否可以解除心灵控制</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">暴击</h4>
					<div class="col-content">
						<p>现在弹头可以实现暴击机制，即在一定的概率下使用不同的伤害和弹头进行攻击。</p>
						<p><code>Crit.Chance</code>定义该弹头的暴击概率，参数为0.0-1.0的浮点值。</p>
						<p><code>Crit.ApplyChancePerTarget</code>定义暴击的概率是否随目标刷新，参数为布尔值。</p>
						<p><code>Crit.ExtraDamage</code>定义该弹头在暴击时所打出的额外伤害，参数为整数。</p>
						<p><code>Crit.Warhead</code>定义该弹头在暴击时所使用的弹头，参数为弹头的注册名。</p>
						<p><code>Crit.Affects</code>定义该弹头对哪些对象可以暴击，参数为以下预设值：</p>
						<ul>
							<li><code>none</code>：无论如何都不会暴击。</li>
							<li><code>land</code>：对地面单位攻击可以暴击。</li>
							<li><code>water</code>：对水面单位攻击可以暴击。</li>
							<li><code>empty</code>：对空地攻击可以暴击。</li>
							<li><code>infantry</code>：对步兵攻击可以暴击。</li>
							<li><code>units</code>：对载具攻击可以暴击。</li>
							<li><code>buildings</code>：对建筑攻击可以暴击。</li>
							<li><code>all</code>：对所有对象攻击都可以暴击。</li>
						</ul>
						<p><code>Crit.AffectsBelowPercent</code>定义该弹头对血量在该百分比以下的单位会暴击，参数为0.0-1.0的浮点值。</p>
						<p><code>Crit.AnimList</code>定义该弹头在暴击时所使用的动画以取代<code>AnimList</code>，参数为动画注册名的列表。</p>
						<p><code>Crit.AnimList.PickRandom=</code>定义该弹头是否从暴击动画列表中随机播放一个动画，参数为布尔值。</p>
						<p><code>Crit.AnimOnAffectedTargets</code>定义该弹头暴击的动画是否在每一个造成暴击的单位上播放，参数为布尔值，</p>
						<p><code>Crit.SuppressWhenIntercepted</code>定义弹头的抛射体被拦截时是否去掉暴击效果，参数为布尔值。</p>
						<p><code>ImmuneToCrit</code>定义该单位是否免疫暴击效果，即是否不会受到暴击，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[120mm]</p>
							<p>...</p>
							<p>Crit.Chance=0.5 ;武器的暴击率</p>
							<p>Crit.ApplyChancePerTarget=false ;暴击率是否随不同目标刷新</p>
							<p>Crit.ExtraDamage=25 ;暴击伤害</p>
							<p>Crit.Warhead=RHINAPE ;暴击时所使用的弹头</p>
							<p>Crit.Affects=units ;攻击什么类型的目标会触发暴击</p>
							<p>Crit.AffectBelowPercent=1.0 ;目标血量在多少以下会触发暴击</p>
							<p>Crit.AnimList=VTEXPLOD ;暴击时的弹头动画列表</p>
							<P>Crit.AnimList.PickRandom=false ;暴击时是否随机播放弹头动画</P>
							<p>Crit.AnimOnAffectedTargets=false ;是否在每一个造成暴击的单位上播放弹头动画</p>
							<p>Crit.SuppressWhenIntercepted=false ;暴击效果是否在被拦截时触发</p>
							<br>
							<p>[APOC] ;Apocalypse Tank</p>
							<p>...</p>
							<p>ImmuneToCrit=yes ;是否免疫暴击</p>
						</div>
						<p id="alert">如果你将某个弹头的<code>Crit.Warhead</code>设置为相同的弹头，那将可能会形成一个无限暴击循环，从而卡死游戏。</p>
					</div>
					<h4 type="button" class="collapsible">自定义水花动画</h4>
					<div class="col-content">
						<p>在原版中，带有<code>Conventional</code>标签的弹头在打在水面上会溅起水花，水花的动画只能在全局代码<code>[CombatDamage]</code>中的<code>SplashList</code>中随机选中。Phobos现在提供了可以在每个弹头上微观定义水花的方式。</p>
						<p><code>SplashList</code>定义该弹头打在水上的水花，参数为动画注册名的列表，默认为全局设置的动画。</p>
						<p><code>SplashList.PickRandom</code>定义是否随机选取水花动画，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[120mmx]</p>
							<p>...</p>
							<p>Conventional=yes ;弹头在水面爆炸是否用水花动画替代原有弹头动画</p>
							<p>SplashList=VTEXPLOD ;水花动画列表</p>
							<p>SplashList.PickRandom=false ;水花动画是否随机播放</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">全局引爆</h4>
					<div class="col-content">
						<p>顾名思义，弹头可以在全局内对每一个目标引爆。</p>
						<p><code>DetonateOnAllMapObjects</code>定义该弹头是否全局引爆，参数为布尔值。这个功能只适用于抛射体搭载的弹头，如果是动画的弹头或者Ares中的弹头超级武器，则无法生效，而弹头附带的<code>Crit.Warhead</code>或者动画中的<code>Weapon</code>则会生效。同时，抛射体所携带的空爆武器或者溅射武器也会对全局目标生效，而Ares的<code>PreImpactAnim</code>动画也会在引爆前播放。</p>
						<p><code>DetonateOnAllMapObjects.AffectTargets</code>用于过滤全局引爆适用于哪些目标，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：不过滤全局引爆范围</li>
							<li><code>aircraft</code>：只对飞行器生效</li>
							<li><code>buildings</code>：只对建筑生效</li>
							<li><code>infantry</code>：只对步兵生效</li>
							<li><code>units</code>：只对载具生效</li>
							<li><code>all</code>：对所有对象一律生效</li>
						</ul>
						<p><code>DetonateOnAllMapObjects.AffectHouses</code>用于过滤全局引爆适用于哪些所属方，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：对任何所属方都不生效</li>
							<li><code>owner/self</code>：只对自己生效</li>
							<li><code>allies/ally</code>：只对盟友生效</li>
							<li><code>team</code>：只对自己和盟友生效</li>
							<li><code>enemies/enemy</code>：只对敌人生效</li>
							<li><code>all</code>：对所有所属方一律生效</li>
						</ul>
						<p><code>DetonateOnAllMapObjects.AffectTypes</code>定义该全局弹头只对哪些特定的单位生效，参数为单位注册名列表。注意，上述的目标过滤和所属方过滤被设置后，将优先读取，因此这个功能将被覆盖。</p>
						<p><code>DetonateOnAllMapObjects.IgnoreTypes</code>定义哪些单位无视该全局弹头，参数为单位注册名列表。</p>
						<p><code>DetonateOnAllMapObjects.RequireVerses</code>定义该全局弹头是否只作用于<code>Verses</code>非0的单位，即如果该弹头对付某一装甲的<code>Verses</code>值为0，那么该装甲的单位不会受到该弹头的攻击。这个功能的优先级低于上述所有功能。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NUKE]</p>
							<p>...</p>
							<p>DetonateOnAllMapObjects=true ;是否全局引爆弹头</p>
							<p>DetonateOnAllMapObjects.AffectTargets=none ;全局引爆弹头可击中的目标类型</p>
							<p>DetonateOnAllMapObjects.AffectHouses=none ;全局引爆弹头可击中的所属方</p>
							<p>DetonateOnAllMapObjects.AffectTypes= ;全局引爆弹头可击中的特定目标</p>
							<p>DetonateOnAllMapObjects.IgnoreTypes=  ;全局引爆弹头不可击中的特定目标</p>
							<p>DetonateOnAllMapObjects.RequireVerses=false ;全局引爆弹头是否需要可用的Verses值</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">爆金币</h4>
					<div class="col-content">
						<p>该弹头可以在引爆后增加或减少所属方的资金。</p>
						<p><code>TransactMoney</code>定义该弹头在引爆后会给弹头发射单位的所属方增加或减少多少资金，参数为整数，正数为增加，负数为减少。</p>
						<p><code>TransactMoney.Display</code>定义该弹头在引爆后增加或减少所属方资金时是否显示资金的值，参数为布尔值。增加为绿色的数字，减少为红色的数字。</p>
						<p><code>TransactMoney.Display.AtFirer</code>定义在显示资金增减值时，该值是否在弹头的发射单位上出现，填入布尔值。如果该弹头没有发射者信息，则会在弹头引爆的地方出现。</p>
						<p><code>TransactMoney.Display.Houses</code>定义哪些所属方可以看到该弹头引爆时资金的增减值，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：所有所属方均无法看见该值</li>
							<li><code>owner/self</code>：只有弹头发射单位的所属方可以看见该值</li>
							<li><code>allies/ally</code>：只有弹头发射单位的盟友可以看见该值</li>
							<li><code>team</code>：弹头发射单位的所属方和其盟友都可以看见该值</li>
							<li><code>enemies/enemy</code>：只有弹头发射单位的敌人可以看见该值</li>
							<li><code>all</code>：所有所属方均可以看见该值</li>
						</ul>
						<p><code>TransactMoney.Display.Offset</code>定义显示资金增减的值出现的位置调整，参数为用逗号隔开的X,Y值，单位为像素，起点为发射单位或引爆地格的中心点。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GimmeSomeMoney]</p>
							<p>...</p>
							<p>TransactMoney=1000</p>
							<p>TransactMoney.Display=true</p>
							<p>TransactMoney.Display.AtFirer=true</p>
							<p>TransactMoney.Display.Houses=self</p>
							<p>TransactMoney.Display.Offset=0,0</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">超级武器引信</h4>
					<div class="col-content">
						<p>现在弹头可以作为超级武器的引信使用，即在弹头引爆的区域释放超级武器。</p>
						<p><code>LaunchSW</code>定义该弹头在引爆时所发射的超级武器，参数为超级武器的注册名的列表。</p>
						<p><code>LaunchSW.RealLaunch</code>定义该弹头引爆时发射的超级武器是否需要满足条件，同时需要有足够的资金（Ares的超级武器<code>Money.Amout</code>功能），参数为布尔值。</p>
						<p><code>LaunchSW.IgnoreInhibitors</code>定义该弹头在引爆时发射的超级武器是否无视抑制器，参数为布尔值。</p>
						<p><code>LaunchSW.IgnoreDesignators</code>定义该弹头在引爆时发射的超级武器是否无视指向器，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ParticleCannonPointer]</p>
							<p>...</p>
							<p>LaunchSW=ParticleCannonSpecial ;引爆弹头时发射的超级武器</p>
							<p>LaunchSW.RealLaunch=true ;该超级武器是否需要满足条件</p>
							<p>LaunchSW.IgnoreInhibitors=false ;该超级武器是否无视抑制器</p>
							<p>LaunchSW.IgnoreDesignators=true ;该超级武器是否无视指向器</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">移除伪装</h4>
					<div class="col-content">
						<p>被该弹头击中的单位会移除伪装效果，对付拥有<code>PermaDisguise</code>的单位时会相当有效。</p>
						<p><code>RemoveDisguise</code>定义该弹头是否可以移除伪装效果，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TakeOffYourClothes]</p>
							<p>...</p>
							<p>RemoveDisguise=true ;是否可以移除伪装</p>
						</div>
						<p id="comment">笔者注：逻辑上来讲，使用这个弹头的单位要么可以识破伪装，要么是范围伤害，否则很难发挥出效果。</p>
					</div>
					<h4 type="button" class="collapsible">开图</h4>
					<div class="col-content">
						<p>该弹头引爆时将会为弹头发射单位的所属方显示全地图。</p>
						<p><code>SpySat</code>定义该弹头在引爆时是否会为发射单位的所属方显示全地图，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[OpenTheMap]</p>
							<p>...</p>
							<p>SpySat=true ;是否显示全地图</p>
						</div>
						<p id="comment">考虑到平衡性，这个功能实际上比较鸡肋，虽说可以用来模拟NP的开图超级武器，但还是比较鸡肋……</p>
					</div>
					<h4 type="button" class="collapsible">黑幕</h4>
					<div class="col-content">
						<p>该弹头引爆时会将发射单位的敌人的地图覆盖黑幕。</p>
						<p><code>BigGap</code>定义该弹头引爆时是否将敌人的视野覆盖满黑幕，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[DeepDarkFantasy]</p>
							<p>...</p>
							<p>BigGap=true ;是否给敌人的视野覆盖黑幕</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">触发指定的非人死亡动画</h4>
					<div class="col-content">
						<p>该弹头在杀死带有<code>NotHuman=yes</code>的步兵时可以指定该步兵的死亡动画。</p>
						<p><code>NotHuman.DeathSequence</code>定义该弹头摧毁非人步兵时是否播放指定的死亡动画，参数为1-5的整数，代表<code>Die1</code>到<code>Die5</code>的动画序列。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Melt]</p>
							<p>...</p>
							<p>NotHuman.DeathSequence=5 ;指定哪一个死亡动画序列</p>
						</div>
					</div>
					<h3 id="new-logic-weapons">武器</h3>
					<h4 type="button" class="collapsible">自定义范围攻击目标</h4>
					<div class="col-content">
						<p>在原版中，带有<code>AreaFire</code>的武器在开火时会选择自己脚下的地面作为目标进行攻击，而在Phobos中，这种攻击模式可以自定义攻击目标。</p>
						<p><code>AreaFire.Target</code>定义该单位范围攻击的目标，参数为下列预设值：</p>
						<ul>
							<li><code>base</code>：攻击单位下方的地面单元格</li>
							<li><code>self</code>：攻击单位自身，遵从武器的目标筛选机制</li>
							<li><code>random</code>：攻击range范围内随机单元格，无视武器的目标筛选机制</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[PsiWave]</p>
							<p>...</p>
							<p>Range=3</p>
							<p>AreaFire=yes ;是否为范围攻击</p>
							<p>AreaFire.Target=random ;范围攻击的目标</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">Burst开火延迟</h4>
					<div class="col-content">
						<p>敬请期待……</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
						</div>
					</div>
					<h4 type="button" class="collapsible">反馈武器</h4>
					<div class="col-content">
						<p>敬请期待……</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
						</div>
					</div>
					<h4 type="button" class="collapsible">辐射扩展</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义飞行器扫射</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">目标选择筛选</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h2 id="fixed-logic">修复或改善的逻辑</h2>
					<h3>BUG修复和杂项</h3>
					<h3>其他平台的问题修复</h3>
					<h3>飞行器</h3>
					<h3>动画</h3>
					<h3>建筑</h3>
					<h3>粒子系统</h3>
					<h3>粒子</h3>
					<h3>抛射体</h3>
					<h3>单位</h3>
					<h3>地形</h3>
					<h3>矿石</h3>
					<h3>载具</h3>
					<h3>藤蔓与废料</h3>
					<h3>VXL碎片</h3>
					<h3>弹头</h3>
					<h3>武器</h3>
					<h3>杂项</h3>
					<h2 id="ai-script">AI编写和地图编辑</h2>
					<h3>BUG修复和杂项</h3>
					<h3>单人任务地图</h3>
					<h3>脚本动作</h3>
					<h3>触发动作</h3>
					<h3>触发事件</h3>
					<h2 id="user-interface">用户界面</h2>
					<h2 id="misc">杂项</h2>
				</div>
			</div>
		</div>
	</main>
	<!--Footer-->
	<footer>
		<div class="footer-container">
			<div class="footer-left">
				<div class="footer-logo">
					<img src="../../src/favicon.svg" alt="Bellum Aeternum" width="64" height="64">
					<p>万世<br>之战</p>
				</div>
				<div class="lang-selector">
					<p>语言切换</p>
					<div class="lang-list">
						<a href="https://ra2be.com">EN</a>
						<a href="https://ra2be.com/zh/">中</a>
					</div>
				</div>
			</div>
			<div class="footer-right">
				<div class="footer-column">
				<p>阵营</p>
				<ul>
					<li><a href="../allied.html">盟军</a></li>
					<li><a href="../soviet.html">苏联</a></li>
				</ul>
				</div>
				<div class="footer-column">
				<p>文章</p>
				<ul>
					<li><a href="../archives.html">资料库</a></li>
					<li><a href="../blog.html">博客</a></li>
				</ul>
				</div>
				<div class="footer-column">
				<p>关于</p>
				<ul>
					<li><a href="#contact">联系作者</a></li>
				</ul>
				</div>
			</div>
		</div>
		<div class="footer-portals">
			<a href="https://space.bilibili.com/3546721533561614"><img src="../../src/bilibili.svg" width="auto" height="16px">&ensp;B站主页</a>
		</div>
	</footer>
	<script>
		var coll = document.getElementsByClassName("collapsible");
		var i;

		for (i = 0; i < coll.length; i++) {
		  coll[i].addEventListener("click", function() {
		    this.classList.toggle("active");
		    var content = this.nextElementSibling;
		    if (content.style.maxHeight){
		      content.style.maxHeight = null;
		    } else {
		      content.style.maxHeight = content.scrollHeight + "px";
		    } 
		  });
		}
	</script>
</body>