<!DOCTYPE html>
<html lang="zh-Hans">
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" type="text/css" href="../../style.css">
	<meta name="description" content="红色警戒2：尤里的复仇原版AI案例分析，提供最全面的原版AI参考。">
	<link rel="icon" type="image/svg" href="../../src/favicon.svg">
	<meta name="robots" content="noindex, nofollow">
	<title>Phobos中文教程 | 万世之战：为红警2带来前所未有的体验</title>
	<style>
		#version {
			vertical-align: middle;
			font-size: 12px;
			font-family: monospace;
			background-color: #f00;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: center;
			line-height: 16px;
		}

		.collapsible #version {
			vertical-align: middle;
			font-size: 12px;
			font-family: monospace;
			background-color: #f00;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 0.5em;
			color: #ccc;
			text-align: left;
			line-height: 1em;
		}

		#versionx {
			vertical-align: middle;
			font-size: 12px;
			font-family: monospace;
			background-color: #900;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: center;
			line-height: 16px;	
		}

		.collapsible #versionx {
			vertical-align: top;
			font-size: 12px;
			font-family: monospace;
			background-color: #900;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: left;
			line-height: 20px;
		}

		code {
			font-family: monospace;
			font-size: 12px;
			font-weight: normal;
			border: 1px dotted #fff;
			border-radius: 4px;
			background-color: #000;
			padding: 0.2em 0.4em;
			margin: 0 0.2em 0 0;
			user-select: text;
			text-align: center;
		}

		#comment {
			border: 1px dashed #fff;
			font-size: 14px;
			font-weight: 100;
			padding: 0.2em;
		}

		#alert {
			border: 1px dashed #fcc;
			font-size: 14px;
			font-weight: normal;
			padding: 0.2em;
			background-color: #933;
		}

		.blog-content h4{
			font-size: 18px;
			margin: 2px auto;
		}

		h5{
			font-size: 20px;
			font-weight: bold;
			line-height: 1em;
			margin: 1em auto;
		}

		h5:before {
			content:'\2605';
			color: #f00;
		}
	</style>
</head>
<body>
	<header>
		<div class="navigation-buttons">
			<div class="navigation-button">
				<a href="https://ra2be.com/zh">主页</a>
			</div>
			<div class="navigation-button">
				<a href="../archives.html">档案库</a>
			</div>
			<div class="navigation-button">
				<a href="../blog.html">博客</a>
			</div>
			<div class="navigation-button">
				<a href="../download.html">下载</a>
			</div>
		</div>
		<div class="responsive-navigation">
			<a href="https://ra2be.com/zh"><img src="../../src/favicon.svg" alt="logo" width="36px" height="36px"></a>
			<div class="responsive-navigation-buttons">
				<a href="../archives.html">档案库</a>
				<a href="../blog.html">博客</a>
				<a href="../download.html">下载</a>
			</div>
		</div>
	</header>
	<!--Main-->
	<main>
		<div class="blog">
			<h1></h1>
			<div class="blog-info">
				<div class="update-time">
					<p>最后更新时间：<time datetime="2024-11-19 18:00">2024/11/19</time></p>
				</div>
			</div>			
			<div class="blog-main">
				<div class="blog-left">
					<div class="blog-info"></div>
					<div class="chap-nav">
						<p>快速导航</p>
						<div class="chaps">
							<a id="h2" href="#new-enhanced-logic">全新或增强的逻辑</a>
							<a id="h2" href="#fixed-logic">修复或改善的逻辑</a>
							<a id="h2" href="#ai-script">AI编写和地图编辑</a>
							<a id="h2" href="#user-interface">用户图形界面</a>
							<a id="h2" href="#misc">杂项</a>
						</div>
					</div>
				</div>
				<div class="blog-content">
					<h1>Phobos中文教程</h1>
					<h2>前言</h2>
					<h3>关于教程</h3>
					<p>本教程基于Phobos的英文版教程和中文版教程编撰，转载请署名nuke，并给出本页面的超链接。</p>
					<p>因为Phobos版本比较多，前言中会做出相应的介绍，以免实操的时候出现“货不对板”的情况。</p>
					<h3>Phobos的版本和说明</h3>
					<p>Phobos总共有三个类型：</p>
					<ol>
						<li>稳定版：通过大量测试，Bug最少的版本。时至教程编撰日期，Phobos的稳定版本号为v0.3.0.1。</li>
						<li>开发版：通过测试，Bug比较少的版本。时至教程编撰日期，Phobos的开发版为b44。</li>
						<li>测试版：集合了最新功能，但可能存在Bug。</li>
					</ol>
					<p>如果是新入门的Modder，比较推荐使用稳定版。如果是比较有经验的Modder，推荐使用功能更多的开发版。如果是深度精通代码的Modder可以使用测试版，但这类Modder通常能看懂原文，所以不做讨论。</p>
					<p>本教程所有的内容都会以v0.3.0.1稳定版作为基础，开发版相关的内容会以<span id="version">DEV</span>的标签标记，意为开发版。如果是只有测试版才有的功能，在教程中会标注<span id="versionx">N/A</span>的标签标记，意为暂时无法直接下载使用。</p>
					<h3>代码术语目录表</h3>
					<ul>
						<li>布尔值（Boolean）：开关参数值，填入true或false，或者yes或no。</li>
						<li>列表（List）：多个值的集合，用英文的逗号<code>,</code>隔开。</li>
						<li>浮点值（Float）：指的是用小数表示任意实数的值，比如1为整数，其浮点值就要写为1.0或者1.00等待小数点的值。</li>
					</ul>
					<h3>红警内部属于目录表：</h3>
					<ul>
						<li>对象（ObjectType）：所有游戏内可视物的总称，包括单位、动画、粒子、地形、覆盖物、污染等。</li>
						<li>单位（TechnoType）：建筑、步兵、载具和飞行器的总称。</li>
						<li>建筑插件（PowersUp）：指的是类似泰伯利亚之日中GDI发电厂涡轮、必须以其他建筑为基础才能放置的建筑。</li>
					</ul>
					<!--New Logic-->
					<h2 id="new-enhanced-logic">全新或增强的逻辑</h2>
					<h3>新的机制</h3>
					<h4 type="button" class="collapsible">附加效果（AE）<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>和Ares的附加效果逻辑类似，但Phobos的附加效果逻辑可以明确地定义类型。</p>
						<p><code>Duration</code>定义该附加效果可以持续多长时间，可以被单位和弹头上的<span>DurationOverrides</span>覆盖。数据类型为整数，单位为帧，可以填入负数代表不定时长。</p>
						<p><code>Cumulative</code>定义该附加效果的时长是否可叠加，参数为布尔值。如果被设置为<code>True</code>，表示相同附加效果的存在时长可以叠加。</p>
						<p><code>Cumulative.MaxCount</code>定义该附加效果的最大叠加层数。为正整数来定义相同附加效果可以叠加的层数，如果设为负数，相同附加效果则可以无限叠加。如果某单位的附加效果已经达到了可携带的最高层数但继续附加，则最新的附加效果会替换掉持续时长最短的效果。</p>
						<p><code>Powered</code>定义拥有该附加效果的单位在<abbr title="遥控坦克断电或被电磁脉冲击中">瘫痪</abbr>中是否会改变附加效果的动画。</p>
						<p><code>DiscardOn</code>定义该附加效果会在什么条件下会消失，默认为<code>none</code>，可以填入多个参数，参数详解如下：</p>
						<ul>
							<li><code>entry</code>：单位离开地图时，如进入建筑或进入载具。</li>
							<li><code>move</code>：单位移动时，如果是建筑则无视这个效果。</li>
							<li><code>stationary</code>：单位静止时，如果是建筑则无视这个效果。</li>
							<li><code>drain</code>：单位被带有<code>DrainWeapon=true</code>的吸取武器攻击时。</li>
							<li><code>inrange</code>：单位在附加效果来源的攻击范围之内时，可通过<code>DiscardOn.RangeOverride</code>来覆盖距离。</li>
							<li><code>outofrange</code>：单位在附加效果来源的攻击范围之外时，可通过<code>DiscardOn.RangeOverride</code>来覆盖距离。</li>
							<li><code>firing</code>：单位开火时，子机武器或吸取武器等特殊武器同样受影响。</li>
						</ul>
						<p><code>PenetratesIronCurtain</code>定义该附加效果是否对带有铁幕的单位有效，参数为布尔值。</p>
						<p><code>PenetratesForceShield</code>定义该附加效果是否对带有力场护盾的单位有效，参数为布尔值，默认为<code>PenetratesIronCurtain</code>的值。</p>
						<br>
						<p><code>Animation</code>定义该附加效果的动画，该动画会自动循环播放，无视Art.ini中的LoopCount。</p>
					</div>
					<h4 type="button" class="collapsible">自定义辐射类型</h4>
					<div class="col-content">
						<p>现在任何武器都可以拥有自定义的辐射类型。使用自定义辐射需要创建一个新的注册表<code>[RadiationTypes]</code>，并注册新的辐射名称。</p>
						<p><b>全局定义：</b></p>
						<p>开启自定义辐射参数需要在全局代码<code>[Radiation]</code>中加入<code>UseGlobalRadApplicationDelay</code>，参数为布尔值。如果设定为True，那么新增加的辐射会使用全局的辐射参数，反之设定为False，那么则可以定义辐射的属性。</p>
						<p><b>辐射定义：</b></p>
						<p><code>RadApplicationDelay.Building</code>定义该辐射类型的对建筑的效果，参数为整数，填入大于0的值将伤害建筑。</p>
						<p><code>RadBuildingDamageMaxCount</code><span id="version">DEV</span>限制辐射对建筑的最多伤害的次数，参数为整数。和<code>CellSpread</code>的机制类似，因为建筑通常占有多个地格，因此辐射也会对建筑造成每个地格叠加的伤害，所以需要用这段代码来控制伤害。填入负值代表不做限制。</p>
						<p><code>RadSiteWarhead.Detonate</code>定义是否让辐射的弹头附带其他弹头效果而不是单纯的伤害比例控制，参数为布尔值。原版中辐射场的弹头只用于伤害控制，因此单位走到辐射场中不会有受击的动画。</p>
						<p id="comment">笔者注：若非特殊需求建议把这个功能关掉，非常消耗性能。</p>
						<p><code>RadSiteWarhead.Detonate.Full</code>定义是否只保留弹头的范围伤害和Phobos专属的弹头效果，参数为布尔值。</p>
						<p><code>RadHasOwner</code>定义该辐射类型是否附带所属信息，填入布尔值。填入true则被该辐射所击杀的敌军单位会记录在玩家游戏数据中，同时也可以自定义其他相关的弹头设置，比如利用<code>AffectsAllies</code>来控制辐射是否影响友军。</p>
						<p><code>RadHasInvoker</code>定义该辐射类型是否附带击杀者信息，填入布尔值。填入true则释放该辐射的单位可以通过辐射击杀的单位获得经验值。</p>
						<p><b>为武器添加自定义辐射：</b></p>
						<p><code>RadType</code>：定义武器附带的辐射类型。</p>
						<p><b>代码示例：</b></p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Radiation]	;全局控制</p>
							<p>UseGlobalRadApplicationDelay=no ;开启自定义辐射参数</p>
							<br>
							<p>[RadiationTypes] ;新的注册表</p>
							<p>0=NewRadiation ;注册新的辐射类型</p>
							<br>
							<p>[NewWeapon] ;带辐射的武器</p>
							<p>RadType=NewRadiation ;辐射类型</p>
							<p>RadLevel=200 ;辐射量，一定要高于RadLevelDelay的值。</p>
							<br>
							<p>[NewRadiation] ;定义新的辐射类型</p>
							<p>RadDurationMultiple=1 ;控制辐射的存续时间，公式为RadLevel * RadDurationMultiple<p>
							<p>RadApplicationDelay=16 ;控制辐射造成伤害的间隔</p>
							<p>RadApplicationDelay.Building=32 ;控制辐射对建筑造成伤害的间隔</p>
							<p>RadBuildingDamageMaxCount=-1 ;控制辐射对建筑造成伤害的最高次数</p>
							<p>RadLevelMax=500 ;控制辐射的在单元格内最高值</p>
							<p>RadLevelDelay=90 ;重新计算辐射量的间隔</p>
							<p>RadLightDelay=90 ;重新计算辐射光照的间隔</p>
							<p>RadLevelFactor=0.2 ;辐射伤害参数，公式为RadLevel * RadLevelFactor</p>
							<p>RadLightFactor=0.1 ;辐射光照参数</p>
							<p>RadTintFactor=1.0 ;辐射染色参数</p>
							<p>RadColor=0,255,0  ;辐射颜色的RGB值</p>
							<p>RadSiteWarhead=RadSite ;辐射伤害的弹头</p>
							<p>RadSiteWarhead.Detonate=false ;辐射弹头效果是否开启</p>
							<p>RadSiteWarhead.Detonate.Full=true ;是否开启全部弹头效果</p>
							<p>RadHasOwner=true ;辐射是否带所属</p>
							<p>RadHasInvoker=true ;辐射击杀是否给辐射源单位经验</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">激光拖尾</h4>
					<div class="col-content">
						<p>激光拖尾是一种全新的拖尾方式，其可定义透明度、宽度和颜色。</p>
						<p>激光拖尾可以使用在单位、抛射体和VXL碎片上。</p>
						<p>附着对象是单位时支持多个激光拖尾，并可以定义其FLH坐标。对于有多个组件（如坦克的炮塔）的单位，可以自定义激光拖尾附着的部件。</p>
						<p><b>代码示例：</b></p>
						<p>在<code>art.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LaserTrailTypes] ;激光拖尾的注册表</p>
							<p>0=NewTrail ;注册新的激光拖尾</p>
							<br>
							<p>[NewTrail] ;定义新的激光拖尾</p>
							<p>IsHouseColor=false ;激光拖尾是否是所属色</p>
							<p>Color=255,0,0 ;激光拖尾的RGB颜色</p>
							<p>FadeDuration=64 ;激光拖尾持续的时间，值越大持续时间越长</p>
							<p>Thickness=4 ;激光拖尾的宽度</p>
							<p>SegmentLength=128 ;每一段激光的长度</p>
							<p>IgnoreVertical=false ;附着对象在垂直移动时不会产生激光拖尾</p>
							<p>IsIntense=false ;boolean, whether the laser is "supported" (AKA prism forwarding)</p>
							<p>CloakVisible=false ;附着对象在隐身之后是否会显示激光拖尾</p>
							<p>CloakVisible.DetectedOnly=false  ;附着对象在被探测到（非显形）后是否会显示激光拖尾</p>
							<br>
							<p>[NewProjectile] ;抛射体图像</p>
							<p>LaserTrail.Types=NewTrail ;抛射体的激光拖尾，可以使用列表表示多个拖尾。</p>
							<br>
							<p>[NewUnit] ;单位图像</p>
							<p>LaserTrail1.Types=NewTrail ;单位的第一条激光拖尾</p>
							<p>LaserTrail2.Type=NewTrail ;单位的第二条激光拖尾</p>
							<p>LaserTrail1.FLH=0,-50,0 ;第一条激光拖尾的起始坐标</p>
							<p>LaserTrail2.FLH=0,50,0 ;第二条激光拖尾的起始坐标</p>
							<p>LaserTrail1.IsOnTurret=false ;第一条激光拖尾是否附着在单位的炮塔上</p>
							<p>LaserTrail2.IsOnTurret=false ;第二条激光拖尾是否附着在单位的炮塔上</p>
						</div>
						<br>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewVoxelAnim] ;VXL碎片</p>
							<p>LaserTrail.Types=NewTrail  ;VXL碎片的激光拖尾，可以使用列表表示多个拖尾。</p>
						</div>
						<p id="alert">注意：激光拖尾非常消耗性能，因为游戏不存在GPU渲染，过多的激光拖尾会让游戏变得非常卡，不论你的电脑多高端。一、建议不要为单位或抛射体过多的挂激光拖尾；二、建议将<code>SegmentLength</code>尽量调高。三、建议将<code>FadeDuration</code>尽量调低。</p>
					</div>
					<h4 type="button" class="collapsible">护盾</h4>
					<div class="col-content">
						<h5>护盾的注册：</h5>
						<p>护盾作为一种新的对象，是需要新建一个注册表的。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ShieldTypes]</p>
							<p>1=NewShield</p>
						</div>
						<h5>护盾的定义：</h5>
						<p>护盾本质上可以看做是让单位拥有一个独立装甲和强度（血量）的第二血条，具备以下基础特性：</p>
						<ul>
							<li>护盾在下列状态下不会掉强度：
								<ol>
									<li>被超时空弹头攻击时</li>
									<li>在被铁幕或者力场护盾保护时</li>
									<li>单位拥有<code>Immune=true</code>时<span id="version">DEV</span></li>
									<li>单位被自身所免疫的弹头攻击时<span id="version">DEV</span></li>
									<li>单位被盟友攻击时<span id="version">DEV</span></li>
								</ol>
							</li>
							<li>护盾在未消失的情况下，负数伤害会修复护盾强度，届时所有的负数伤害会被护盾吸收。除非负数伤害的弹头带有<code>Shield.Penetrate=true</code>语句，否则无法在有护盾的情况下为单位增加血量。</li>
							<li>当单位拥有护盾时，护盾定义中的<code>Armor</code>将会代替单位本身的<code>Armor</code>来计算伤害。如果想关闭这个机制，可以用<code>InheritArmorFromTechno=true</code>来让单位本身的<code>Armor</code>覆盖护盾的<code>Armor</code>。</li>
							<li>护盾的初始强度使用<code>InitialStrength</code>来定义，这个值可以不等于最大强度。</li>
						</ul>
						<p>当单位执行部署变形（无论是原版的武装直升机逻辑还是Ares的单位转换）时，如果单位A和单位B都有护盾，那么变形后相应的护盾会按照百分比保留之前护盾强度值。但如果单位A有护盾而单位B没有护盾的情况，单位A的护盾的状态将会被封存，直到从单位B再变形为单位A继续生效。</p>
						<p><code>Powered</code>定义护盾是否受电磁脉冲和遥控坦克停电效果的影响，参数为布尔值，True为受影响，False为不受影响。</p>
						<p><code>AbsorbOverDamage</code>定义护盾是否可以抵挡超额伤害，参数为布尔值，True为可以抵挡，False为超额伤害算进单位自身血量。</p>
						<p><code>SelfHealing</code>定义护盾恢复强度的值，参数为浮点值或者百分比。填入0.0的情况下护盾不会自动恢复，填入百分比的情况下每次恢复百分比值的强度。填入负数的情况每次恢复将会扣除强度。如果你想让护盾每次恢复1点强度，可以填入1到2的任意浮点值，比如1.1。</p>
						<p><code>Respawn</code>定义护盾重生的强度值，参数和<code>SelfHealing</code>一致。</p>
						<p><code>SelfHealing.Rate</code>定义护盾恢复强度的间隔，参数为浮点值，单位为分钟（游戏内）。设置为0.0的时候直接将护盾恢复成满强度。</p>
						<p><code>Respawn.Rate</code>定义护盾重生的间隔，参数为浮点值，单位为每分钟（游戏内）。设置为0.0的时候直接生成一个满强度护盾。</p>
						<h5>护盾的图像：</h5>
						<p><code>IdleAnim</code>定义护盾生效时播放的动画，该动画会无视<code>LoopCount</code>无限循环，并可以用下列代码定义：</p>
						<ul>
							<li><code>IdleAnim.ConditionYellow</code>和<code>IdleAnim.ConditionRed</code>定义该护盾在强度值呈黄色和红色的状态下所播放的不同的护盾动画。如果不设置<code>IdleAnim.ConditionRed</code>，在血条呈红色时将会调用<code>IdleAnim.ConditionYellow</code>的动画；如果<code>IdleAnim.ConditionYellow</code>也不设置，将直接使用<code>IdleAnim</code>的动画。血条呈黄色和红色的百分比可以在<code>[AudioVisual]</code>中的<code>ConditionYellow</code>和<code>ConditionRed</code>中设置。</li>
							<li><code>IdleAnimDamaged</code>定义残血单位的护盾动画，同样可以用<code>IdleAnimDamaged.ConditionYellow</code>和<code>IdleAnimDamaged.ConditionRed</code>定义不同护盾值下的动画，使用和<code>IdleAnim</code>相同的默认值逻辑。</li>
							<li>避免使用带有<code>Bouncer=true</code>和<code>IsMeteor=true</code>的动画。</li>
						</ul>
						<p><code>IdleAnim.OfflineAction</code>定义单位停电时的护盾动画。</p>
						<p><code>IdleAnim.TemporalAction</code>定义单位在被超时空弹头击中后的护盾动画。</p>
						<p><code>BreakAnim</code>定义破盾动画。</p>
						<p><code>HitAnim</code>定义护盾的受击动画。</p>
						<p><code>HitFlash</code>定义护盾的受击闪光。可以在弹头上使用<code>Shield.HitFlash=false</code>来关闭闪光。伤害越高闪光越亮，同时可以在护盾中定义<code>HitFlash.FixedSize</code>来控制亮度（取值范围以4为增量，从81到252，范围之外无效）。闪光颜色可以用<code>HitFlash.Red/Green/Blue</code>来控制RGB色，参数为布尔值，表示开启或关闭该颜色。如果把<code>HitFlash.Black</code>设置为True，则闪光会变成黑色，并无视一切颜色控制。<span id="version">DEV</span></p>
						<p><code>BreakWeapon</code>定义破盾时释放的武器，武器会在单位的地格引爆。</p>
						<p><code>AbsorbPercent</code>定义护盾能承受伤害的百分比，参数为浮点值，默认为1.0，即全部承受。如果小于1.0，那么伤害将会穿破护盾，扣除相应的单位血量。</p>
						<p><code>PassPercent</code>定义护盾会被穿透的伤害的百分比，参数为浮点值，默认为0.0，即不会被穿透。</p>
						<p><code>AllowTransfer</code>定义护盾是否在单位变形（原版武装直升机逻辑或者Ares的变形逻辑）后继承，默认为true，即可以继承。</p>
						<p>带有<code>Psychedelic=yes</code>的弹头（神经毒气）默认无视护盾，如果没有<code>ImmuneToBerserk</code>，带护盾的单位一样会无差别攻击。同时，免疫神经毒气的单位也无法避免被该类型弹头作为目标，因此可以使用自定义护甲来避免这种情况发生。</p>
						<h5>护盾的界面：</h5>
						<p>有护盾的单位会显示血条和护盾条，如果护盾是可再生的，那么护盾强度即便归零也会呈现为一个空框。护盾的护盾条图像可以在在<code>[AudioVisual]</code>部分定义，下列代码是关于护盾条的定义：</p>
						<ul>
							<li>默认情况下，建筑的血条使用<span style="color:orange">pips.shp</span>的第6帧作为护盾条，其他单位则使用第17针作为护盾条。</li>
							<li><code>Pips.Shield</code>可以自定义非建筑单位的护盾条，<code>Pips.Shield.Building</code>定义建筑单位的护盾条，参数为整数，表示第几帧。如果只填入一个值，代表护盾条一直会显示该帧的样式，如果填入三个值，那么三个值分别表示“绿色护盾条”“黄色护盾条”和“红色护盾条”所用帧的样式。如果填入-1，那么则使用上述的默认值。</li>
							<li><code>Pips.Shield.Background</code>可以定义非建筑单位的护盾条边框，默认使用<span style="color:orange">pipbrd.shp</span>，第四帧被用作步兵的护盾条边框，第三帧被用作其他单位的护盾条边框。</li>
							<li><code>Pips.Shield.Building.Empty</code>可以定义建筑单位的护盾条非满格时的底色，默认使用<span style="color:orange">pips.shp</span>的第一帧。</li>
							<li><code>BracketDelta</code>可以定义护盾条的纵向位置，和原版<code>PixelSelectionBracketDelta</code>类似，负值向上移动，正值向下移动，单位为像素。对建筑无效。</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[AudioVisual]</p>
							<p>Pips.Shield=-1,-1,-1 ;单位的护盾条</p>
							<p>Pips.Shield.Building=-1,-1,-1 ;建筑的护盾条</p>
							<p>Pips.Shield.Background=PIPBRD.SHP ;护盾条边框</p>
							<p>Pips.Shield.Building.Empty=0 ;建筑上非满强度护盾的底色</p>
						</div>
						<p>如果你不想使用全局定义的护盾条，也可以在不同类型的护盾上做微观定义：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Shield]</p>
							<p>Pips=-1,-1,-1 ;单位的护盾条</p>
							<p>Pips.Building=-1,-1,-1 ;建筑的护盾条</p>
							<p>Pips.Background=pipbrd.shp ;护盾条边框</p>
							<p>Pips.Building.Empty=0 ;建筑上非满强度护盾的底色</p>
						</div>
						<h5>弹头相关设置：</h5>
						<p><code>Shield.Penetrate</code>定义该弹头是否能无视护盾直接对目标血量造成伤害。</p>
						<p><code>Shield.Break</code>定义该弹头是否能在伤害计算之前就破盾。</p>
						<p><code>Shield.BreakAnim</code>定义该弹头在破盾时的动画，这个设置将覆盖护盾中<code>BreakAnim</code>所定义的动画。</p>
						<p><code>Shield.HitAnim</code>定义该弹头在击中护盾时的动画，这个设置将覆盖护盾中<code>HitAnim</code>所定义的动画。</p>
						<p><code>Shield.BreakWeapon</code>定义该弹头破盾后的破盾武器，这个设置将覆盖护盾中<code>BreakWeapon</code>所定义的武器。</p>
						<p><code>Shield.AbsorbPercent</code>定义该弹头被护盾所吸收的量，这个设置将覆盖护盾中<code>AbsorbPercent</code>所定义的量。</p>
						<p><code>Shield.PassPercent</code>定义该弹头能穿过护盾伤害生命值的量，这个设置将覆盖护盾中<code>PassPercent</code>所定义的量。</p>
						<p><code>Shield.Respawn.Rate</code>和<code>Shield.Respawn.Amount</code>定义该弹头击中护盾后该护盾的再生间隔和再生耐久值，这个设置将覆盖护盾中<code>Respawn.Rate</code>和<code>Respawn.Amount</code>所定义的值，如果间隔填入负值或者再生值填入小于等于0的值将不会覆盖。这个效果的时长由<code>Shield.Respawn.Duration</code>控制。</p>
						<p><code>Shield.Respawn.ResetTimer</code>定义被该弹头击中的护盾的再生计时器是否重置，填入布尔值。</p>
						<p><code>Shield.SelfHealing.Rate</code>和<code>Shield.SelfHealing.Amount</code>定义被该弹头击中的护盾的耐久恢复间隔和耐久恢复值，这个设置将覆盖护盾中<code>SelfHealing.Rate</code>和<code>SelfHealing.Amount</code>所定义的值，如果间隔填入负值或者恢复值填入小于等于0的值将不会覆盖。这个效果的时长由<code>Shield.SelfHealing.Duration</code>控制。</p>
						<p><code>Shield.SelfHealing.ResetTimer</code>定义被该弹头击中的护盾的耐久恢复计时器是否重置，填入布尔值。</p>
						<p><code>Shield.AffectsTypes</code>定义会被该弹头的护盾修改器所影响的护盾，填入护盾类型，支持列表。</p>
						<p><code>Shield.AttachTypes</code>和<code>Shield.RemoveTypes</code>定义被（正<code>Verses</code>值的）该弹头击中后附加一个护盾或者移除一个护盾，填入护盾类型，支持列表，但通常只有列表中第一个护盾会生效。</p>
						<p><code>Shield.ReplaceOnly</code>定义<code>Shield.AttachTypes</code>中的护盾是否会按位置替换Shield.RemoveTypes中的护盾，参数为布尔值。如果前者少于后者，那么多余的被移除的护盾被前者的最后一个护盾替换。默认no。</p>
						<p><code>Shield.ReplaceNonRespawning</code>定义<code>Shield.AttachTypes</code>中的护盾是否会替换无法再生的护盾。</p>
						<p><code>Shield.MinimumReplaceDelay</code>定义<code>Shield.ReplaceNonRespawning</code>在多长时间之后替换之前无法再生的护盾。</p>
						<p><code>Shield.InheritStateOnReplace</code>定义用<code>Shield.ReplaceOnly</code>替换的护盾是否继承之前护盾的强度值，并重置再生计时器和强度恢复计时器。</p>
					</div>
					<h3>动画</h3>
					<h4 type="button" class="collapsible">动画生成单位</h4>
					<div class="col-content">
						<p>动画可以在播放完毕后在单元格内生成一个载具单位。开发版可支持生成载具、飞行器或步兵。</p>
						<p><code>CreateUnit</code>定义该动画生成的单位，只能填一个。</p>
						<p><code>CreateUnit.Owner</code>定义该动画生成的单位所属，只有在动画附带所属信息时才会生效。参数为下列预设值：</p>
						<ul>
							<li><code>Invoker</code>：调用动画的对象的所属方</li>
							<li><code>Killer</code>：摧毁该单位的所属方。</li>
							<li><code>Victim</code>：被摧毁单位的所属方。</li>
							<li><code>Civilian</code>：平民方。</li>
							<li><code>Special</code>：特殊方。</li>
							<li><code>Neutral</code>：中立方。</li>
							<li><code>Random</code>：随机。</li>
						</ul>
						<p>动画带有所属信息的方法如下：</p>
						<ul>
							<li>Phobos的<code>DestroyAnim</code></li>
							<li>弹头的<code>AnimList</code>和Phobos的弹头<code>SplashList</code></li>
							<li>41号地图触发动作</li>
						</ul>
						<p><code>CreateUnit.RemapAnim</code>定义该动画是否用单位调色盘绘制并且自带所属色，参数为布尔值。</p>
						<p><code>CreateUnit.Mission</code>定义该动画生成的单位出现后的任务。</p>
						<p><code>CreateUnit.AIMission</code>定义该动画生成的单位所属方是AI控制时的任务。<span id="versionx">N/A</span></p>
						<p><code>CreateUnit.Facing</code>定义该动画生成的单位朝向，参数为0-255的值，0为两点钟方向，224为12点钟方向。</p>
						<p><code>CreateUnit.RandomFacing</code>定义该动画生成的单位朝向是否随机，参数为布尔值。</p>
						<p><code>CreateUnit.InheritFacings</code>定义该动画生成的单位朝向是否继承生成该动画的单位，单位为布尔值。</p>
						<p><code>CreateUnit.InheritTurretFacings</code>定义该动画生成的单位炮塔朝向是否继承生成该动画的单位，单位为布尔值，不支持Jumpjet类载具（如直升机等）。</p>
						<p><code>CreateUnit.ConsiderPathfinding</code>定义该动画生成时如果该单元格有其他单位是否会在周边找一个合适的单元格生成，参数为布尔值。</p>
						<p><code>CreateUnit.AlwaysSpawnOnGround</code>定义该动画生成的单位是否在地面生成，即便动画在空中，参数为布尔值。如果填入false，那么在地面爆炸的Jumpjet类载具会自动起飞。<span id="version">DEV</span></p>
						<p><code>CreateUnit.SpawnParachutedInAir</code>定义该动画生成的单位如果是在空中生成，是否会用降落伞降落到地面，参数为布尔值。在<code>CreateUnit.AlwaysSpawnOnGround=true</code>存在时无效。</p>
						<p><code>CreateUnit.SpawnAnim</code>定义该动画生成单位之后所播放的动画，参数为动画注册名。</p>
						<p><code>CreateUnit.SpawnHeight</code>定义该动画生成的单位初始高度，参数为高度，</p>
					</div>
					<h4 type="button" class="collapsible">动画附加粒子系统<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义动画可视方<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">独立的动画音效<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>建筑</h3>
					<h4 type="button" class="collapsible">自定义建筑延伸<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">建筑插件扩展</h4>
					<div class="col-content">
						<p><code>PowersUp.Owner</code>定义该建筑插件现在可以定义放置的建筑的所属方，需要注意的是当插件放入建筑后，插件的所属方自动变更为该建筑所属方。参数为预设值，可填入下列值：</p>
						<ul>
							<li><code>none</code>：不可放置</li>
							<li><code>owner</code>或者<code>self</code>：仅可放在自己的建筑上</li>
							<li><code>allies</code>或者<code>ally</code>：仅可放在盟友的建筑上</li>
							<li><code>team</code>：可以放在自己和盟友的建筑上</li>
							<li><code>enemies</code>或者<code>enemy</code>：仅可放在敌人的建筑上</li>
							<li><code>all</code>：自己、盟友和敌人的建筑上均可放置</li>
						</ul>
						<p><code>PowersUp.Buildings</code>定义该建筑插件可以放在哪些建筑上，参数为列表，可以填入多个建筑。</p>
						<p id="alert">注意：因技术限制，使用Phobos的<code>PowersUp.Buildings</code>时，该插件不支持Ares提供的插件作为建造前提功能。如果使用原版的<code>PowersUpBuilding</code>则可以提供这个功能，请自行取舍。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewUpgrade] ;插件建筑</p>
							<p>PowersUp.Owner=Self ;放置建筑允许的所属方</p>
							<p>PowersUp.Buildings=NAPOWR,NANRCT ;可以放置的建筑</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">可摧毁障碍建筑<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">电厂增幅器</h4>
					<div class="col-content">
						<p>当电厂增幅器存在于地图上时，会改变该所属方的电厂电量，如果电厂增幅器被摧毁，电量则会回归原本数值。</p>
						<p>电厂增幅器和电厂最大的区别就在于，电厂是直接增减总电量，而电厂增幅器需要在有电厂的情况下才会改变总电量。</p>
						<p>代码展示：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NAPWRE] ;Power Enhancer</p>
							<p>PowerPlantEnhancer.PowerPlants=NAPOWR,NANRCT ;可以增幅的电厂</p>
							<p>PowerPlantEnhancer.Amount=0 ;增幅电力的量</p>
							<p>PowerPlantEnhancer.Factor=1.5 ;增幅电力的倍数</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">间谍效果<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<!--Enhanced Infantries-->
					<h3>步兵</h3>
					<h4 type="button" class="collapsible">匍匐/部署步兵开火坐标</h4>
					<div class="col-content">
						<p>现在步兵在匍匐开火或部署开火时可以使用新的开火坐标定位来覆盖<code>PrimaryFireFLH</code>和<code>SecondaryFireFLH</code>，同时也可以自定义Burst开火时每一发的开火坐标。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[E1]</p>
							<p>PronePrimaryFireFLH=0,0,0 ;主武器匍匐开火时的坐标</p>
							<p>ProneSecondaryFireFLH=0,0,0 ;副武器匍匐开火时的坐标</p>
							<p>DeployedPrimaryFireFLH=0,0,0 ;主武器部署开火时的坐标</p>
							<p>DeployedSecondaryFireFLH=0,0,0 ;副武器部署开火时的坐标</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">默认间谍伪装</h4>
					<div class="col-content">
						<p>步兵现在可以使用<code>DefaultDisguise</code>微观定义默认的间谍伪装，读取阵营高于Ares中阵营的<code>DefaultDisguise</code>。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[SSPY] ;Soviet Spy</p>
							<p>DefaultDisguise=E2 ;默认伪装的步兵</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">非人类步兵死亡动画</h4>
					<div class="col-content">
						<p>拥有<code>NotHuman=yes</code>标签的步兵现在在死亡时可以随机从动画序列中挑选<code>Die1</code>到<code>Die5</code>播放。注意，确保你的步兵是有这些动画序列的，如果没有，在死亡时将不会播放任何动画。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[YDOG] ;Yuri Dog</p>
							<p>NotHuman.RandomDeathSequence=yes ;是否播放随机死亡动画</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">分享弹药</h4>
					<div class="col-content">
						<p>如果一个带有<code>OpenTopped=yes</code>的载具使用了弹药机制（<code>Ammo</code>），同时乘员也使用了弹药机制，就可以让载具为乘员补充弹药，并可以定义哪些乘员才可以补充弹药。注意，载具必须可以自动补充弹药。</p>
						<p><code>Ammo.Shared</code>定义乘员和载具是否分享弹药，参数为布尔值。</p>
						<p><code>Ammo.Shared.Group</code>定义该弹药的分组，相当于规定弹药的规格，参数为整数。只有乘员和载具设置了相同的数值时才可以分享弹药。填入-1则载具可以给所有乘员补充弹药。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[BFRT] ;Battle Fortress</p>
							<p>...</p>
							<p>OpenTopped=yes ;乘员是否可以向外射击</p>
							<p>Ammo=5 ;弹药</p>
							<p>Reload=120 ;装填时间</p>
							<p>Ammo.Shared=yes ;是否分享弹药</p>
							<p>Ammo.Shared.Group=1 ;弹药分组</p>
							<br>
							<p>[SNIPE] ;Sniper</p>
							<p>Ammo.Shared=yes ;是否分享弹药</p>
							<p>Ammo.Shared.Group=1 ;弹药分组</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">奴隶阵营自定义</h4>
					<div class="col-content">
						<p>现在可以自定义奴隶矿场被摧毁后奴隶的归属。</p>
						<p><code>Slaved.OwnerWhenMasterKilled</code>定义奴隶矿场被摧毁后奴隶的归属，参数为以下预设值：</p>
						<ul>
							<li><code>suicide</code>：奴隶在奴隶矿场被摧毁后死亡。</li>
							<li><code>master</code>：奴隶在奴隶矿场被摧毁后归属奴隶矿场的所属方。</li>
							<li><code>neutral</code>：奴隶在奴隶矿场被摧毁后归属中立方。</li>
							<li><code>killer</code>：奴隶在奴隶矿场被摧毁后归属摧毁奴隶矿场的所属方。（原版方案）</li>
						</ul>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div id="slaves-house" class="code-presentation">
							<p>[SLAV]</p>
							<p>Slaved=yes ;是否为奴隶</p>
							<p>Slaved.OwnerWhenMasterKilled=killer ;奴隶矿场被摧毁后的归属方</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">自定义奴隶解救语音<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">在水中使用陆地动作序列<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<!--Enhanced Projectile-->
					<h3>抛射体</h3>
					<h4 type="button" class="collapsible">抛射体拦截</h4>
					<div class="col-content">
						<p>现在Phobos实现了类似《将军：绝命时刻》中美国复仇者防空车的抛射体拦截功能。拥有此功能的单位会自动扫描射程内可以拦截的抛射体，并使用相应的武器进行拦截。</p>
						<h5>抛射体的定义：</h5>
						<p><code>Interceptable</code>定义该抛射体是否可以被拦截，参数为布尔值。</p>
						<p><code>Armor</code>定义该抛射体所使用的装甲。</p>
						<p><code>Strength</code>定义该抛射体的血量，血量被将至0或以下抛射体引爆。</p>
						<p><code>Interceptable.DeleteOnIntercept</code>定义该抛射体在被摧毁时是否会直接被删除而不会引爆弹头。</p>
						<p><code>Interceptable.WeaponOverride</code>将会覆盖该弹头被拦截后引爆的武器，拦截单位上的相同设置拥有更高优先级。</p>
						<h5>拦截单位的定义：</h5>
						<p><code>Interceptor</code>定义该单位是否可以拦截抛射体，参数为布尔值。</p>
						<p><code>Interceptor.Weapon</code>定义该单位用哪个武器拦截抛射体，参数为0或1，0代表主武器，1代表副武器。根据拦截抛射体的高度，拦截武器的抛射体可能需要加入<code>AG=yes</code>和<code>AA=yes</code>。</p>
						<p><code>Interceptor.CanTargetHouses</code>定义该单位可以拦截哪些所属方的抛射体，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：不能拦截任何所属方的抛射体。</li>
							<li><code>owner/self</code>：只能拦截自己所发射的抛射体。</li>
							<li><code>allies/ally</code>：只能拦截盟友的抛射体。</li>
							<li><code>team</code>：可以拦截自己和盟友所发射的抛射体。</li>
							<li><code>enemies/enemy</code>：可以拦截敌人所发射的抛射体。</li>
							<li><code>all</code>：可以拦截所有所属方的抛射体。</li>
						</ul>
						<p><code>Interceptor.GuardRange</code>定义该单位对抛射体的警戒范围，同时可以用<code>Interceptor.RookieGuardRange</code>定义新兵等级的警戒范围、<code>Interceptor.VeteranGuardRange</code>定义老兵等级的警戒范围、<code>Interceptor.EliteGuardRange</code>定义精英等级的警戒范围，参数为浮点值。</p>
						<p><code>Interceptor.MinimumGuardRange</code>定义该单位对抛射体的最近警戒范围，同时可以用<code>Interceptor.RookieMinimumGuardRange</code>定义新兵登记的最近警戒范围、<code>Interceptor.VeteranMinimumGuardRange</code>定义老兵等级的最近警戒范围、<code>Interceptor.EliteMinimumGuardRange</code>定义精英等级的最近警戒范围，参数为浮点值。</p>
						<p><code>Interceptable.DeleteOnIntercept</code>定义该单位是否可以在摧毁抛射体时直接删除该抛射体而不会引爆弹头，这将覆盖抛射体上的设定，参数为布尔值。</p>
						<p><code>Interceptable.WeaponOverride</code>将会覆盖拦截抛射体所引爆的武器，参数为武器注册名。</p>
						<p><code>Interceptor.WeaponReplaceProjectile</code>定义该单位拦截抛射体后是否会将该抛射体的性质改变为<code>Interceptable.WeaponOverride</code>的武器中定义的抛射体的性质，如<code>Image</code>和<code>Speed</code>，但不支持修改Ares所提供的粒子系统<code>AttachedSystem</code>，参数为布尔值。</p>
						<p><code>Interceptor.WeaponCumulativeDamage</code>定义该单位拦截抛射体并将抛射体的引爆武器覆盖后，引爆武器是否叠加该单位用于拦截抛射体的武器的伤害，参数为布尔值。</p>
						<p><code>Interceptor.KeepIntact</code>定义该单位拦截抛射体后被拦截的抛射体是否还可以沿着原先的轨迹继续移动，<code>Interceptable.WeaponOverride</code>等覆盖武器的效果此时不受影响，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewRocket]</p>
							<p>...</p>
							<p>Interceptable=true ;该抛射体是否可以被拦截</p>
							<p>Interceptable.DeleteOnIntercept=false ;该抛射体在被拦截后是否被直接删除</p>
							<p>Interceptable.WeaponOverride=DEMOBOMB ;该抛射体在被拦截后引爆的武器</p>
							<p>Strength=50</p>
							<p>Armor=special_2</p>
							<br>
							<p>[AVGR] ;Avenger</p>
							<p>...</p>
							<p>Primary=MachineGun</p>
							<p>Secondary=InterceptLaser</p>
							<p>Interceptor=true ;该单位是否是抛射体拦截单位</p>
							<p>Interceptor.Weapon=1 ;该单位用于拦截抛射体的武器</p>
							<p>Interceptor.CanTargetHouses=enemies ;该单位能拦截哪些阵营的抛射体</p>
							<p>Interceptor.GuardRange=3.0 ;该单位对抛射体的警戒范围</p>
							<p>Interceptor.VeteranGuardRange=3.5 ;老兵级别对抛射体的警戒范围</p>
							<p>Interceptor.EliteGuardRange=4.0 ;精英级别对抛射体的警戒范围</p>
							<p>Interceptor.MinimumGuardRange=0.0 ;该单位对抛射体的最近警戒范围</p>
							<p>Interceptor.VeteranMinimumGuardRange=0.0 ;老兵级别对抛射体的最近警戒范围</p>
							<p>Interceptor.EliteMinimumGuardRange=0.0 ;精英级别对抛射体的最近警戒范围</p>
							<p>Interceptor.DeleteOnIntercept=false ;是否直接删除抛射体</p>
							<p>Interceptor.WeaponOverride=SmallExplosion ;被拦截的抛射体引爆的武器</p>
							<p>Interceptor.WeaponReplaceProjectile=false ;是否改变抛射体性质</p>
							<p>Interceptor.WeaponCumulativeDamage=false ;是否叠加引爆伤害</p>
							<p>Interceptor.KeepIntact=false ;拦截后抛射体是否继续移动</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">弹道类抛射体</h4>
					<div class="col-content">
						<p>弹道类抛射体是一种全新的抛射体模式，其独立于四大抛射体（<code>Invisio</code>，<code>ROT</code>，<code>Arcing</code>，<code>Vertical</code>）之外，因此禁止和四大抛射体混用。目前弹道类抛射体只推出了两种弹道模式，即直线弹道和轰炸弹道。</p>
						<p><code>Trajectory</code>定义使用哪种弹道的抛射体，参数为弹道模式的预设名称，<code>Straight</code>为直线弹道（平射），<code>Bombard</code>为轰击弹道（曲射）。</p>
						<p><code>Trajectory.Speed</code>定义抛射体的速度，参数为浮点值。和原版在武器上用<code>Speed</code>控制速度不同，弹道类抛射体的速度需要再抛射体代码中定义。</p>
						<h5>直线弹道</h5>
						<p>如字面意义解释，直线弹道的弹体会以一条直线飞向目标。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.DetonationDistance</code>定义抛射体在离目标多少距离之外即被引爆，参数为浮点值，单位为单元格。填入0的情况下视为不设置最大距离。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.ApplyRangeModifiers</code>定义是否在武器射程增减（如附加效果）后对<code>Trajectory.Straight.DetonationDistance</code>的距离进行等值的增减，参数为布尔值。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.TargetSnapDistance</code>定义最远的预判距离，即在该距离之内，弹道会预判敌人的走向，参数为浮点值，单位为单元格。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.PassThrough</code>定义抛射体是否会在击中目标后不引爆弹头，而是朝着<code>Trajectory.Straight.DetonationDistance</code>所指定的距离继续飞行，参数为布尔值。这个设置将改变抛射体的角度，如果在同一高度抛射体则会直线飞行。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MGBullet]</p>
							<p>Trajectory=Straight ;使用直线弹道</p>
							<p>Trajectory.Speed=150.0 ;弹道速度</p>
							<p>Trajectory.Straight.DetonationDistance=0.4 ;抛射体自爆的最大距离</p>
							<p>Trajectory.Straight.ApplyRangeModifiers=false ;引爆距离是否根据武器射程变化而变化</p>
							<p>Trajectory.Straight.TargetSnapDistance=0.5 ;预判距离</p>
							<p>Trajectory.Straight.PassThrough=false ;击中目标是否穿透然后继续飞行</p>
						</div>
						<p id="comment">笔者注：直线弹道配合激光拖尾可以轻松实现机枪曳光弹效果，但为了命中率考虑弹道速度应该加大。</p>
						<h5>轰击弹道</h5>
						<p>和直线弹道类似，但抛射体会瞄准目标上方，发射后作自由落体下坠然后在目标引爆。</p>
						<p><code>Trajectory.Bombard.Height</code>定义抛射体会瞄准距离目标多高的位置，填入浮点值，单位为高度值</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Howitzer]</p>
							<p>Trajectory=Bombard ;使用轰炸弹道</p>
							<p>Trajectory.Bombard.Height=5.0 ;轰炸弹道的曲线高度</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">溅射逻辑扩展</h4>
					<div class="col-content">
						<p>溅射逻辑现在可以在地面或者建筑上触发。</p>
						<p><code>Shrapnel.AffectsGround</code>定义该抛射体在地面引爆时是否会触发溅射，参数为布尔值。</p>
						<p><code>Shrapnel.AffectsBuildings</code>定义该抛射体在建筑引爆时是否会触发溅射，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LargeCometP]</p>
							<p>ShrapnelWeapon=CometFragment ;溅射武器，需要在[WeaponTypes]注册</p>
							<p>ShrapnelCount=5 ;溅射数量</p>
							<p>Shrapnel.AffectsGround=true ;打到地面是否溅射</p>
							<p>Shrapnel.AffectsBuildings=true ;打到建筑是否溅射</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">抛射体阻挡逻辑扩展<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">末端反射武器<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>超级武器</h3>
					<h4 type="button" class="collapsible">AI使用超级武器延时<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">单位变形<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">电磁脉冲设定<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">虚拟投送</h4>
					<div class="col-content">
						<p>虚拟投送的定义是在地图之外投送一个建筑物，这个建筑物是无法在游戏中看到的，也无法被攻击。虚拟投送的目的是，在视觉上不建造建筑的情况下可以实现一些建筑的效果。</p>
						<p>和Ares的超级武器定义比较不同，它不受超级武器<code>Type</code>和释放坐标的限制。可以理解为超级武器的一个衍生功能。</p>
						<p><code>LimboDelivery.Types</code>定义该超级武器所投放的建筑类型，参数为建筑的注册名的列表。</p>
						<p><code>LimboDelivery.IDs</code>定义该超级武器所投放的建筑编号，参数为整数，目的是让建筑可以被摧毁。</p>
						<p><code>LimboKill.Affects</code>定义该超级武器可以移除哪一所属方的虚拟投送的建筑，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：没有阵营的虚拟建筑会被移除。</li>
							<li><code>owner/self</code>：移除使用该超级武器的阵营的虚拟投放建筑。</li>
							<li><code>allies/ally</code>：移除使用该超级武器的阵营的盟友的虚拟投放建筑。</li>
							<li><code>team</code>：移除使用该超级武器的阵营和其盟友的虚拟投放建筑。</li>
							<li><code>enemies/enemy</code>：移除使用该超级武器的阵营的敌人的虚拟投放建筑。</li>
							<li><code>all</code>：移除所有阵营的虚拟投放建筑。</li>
						</ul>
						<p><code>LimboKill.IDs</code>定义该超级武器可以移除什么编号的建筑，参数为整数。</p>
						<p><code>LimboDelivery.RollChance</code>定义每一个虚拟投放建筑被投放的概率，参数为百分比的列表。</p>
						<p><code>LimboDelivery.RandomWeightsN</code>定义第N个建筑的每次的权重增加，N为从序列数，从0开始，代表在<code>LimboDelivery.Types</code>建筑列表中的第几个建筑，参数为正整数，等于0时则不增加权重。</p>
						<p>虚拟投送的建筑并不支持所有的建筑功能，但以下功能是经过了测试的：</p>
						<ul>
							<li>工业工厂</li>
							<li>矿石精炼器</li>
							<li>间谍卫星</li>
							<li>续存（Ares3.0功能）</li>
							<li>建造前提</li>
							<li>超级武器前提</li>
						</ul>
						<p>如果希望这个建筑可作用于<a href="ai-tutorial.html#ai-trigger" target="_blank">AI触发前提中的“己方拥有某建筑”和“敌方拥有某建筑”</a>，需要为该投放的建筑添加<code>LegalTarget=yes</code>标签。</p>
						<p id="alert">记住，虚拟投放的建筑不存在于场上，也就是说这些建筑不应该拥有需要交互的逻辑（比如工厂、维修厂、克隆中心），也最好带上<code>KeepAlive=no</code>标签或者用<code>LimboKill.IDs</code>主动删除，不然游戏会永远无法正常结束。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ForceShieldSpecial] ;力场护盾</p>
							<p>...</p>
							<p>LimboDelivery.Types=GASPYSAT,GAOREP,NAINDP ;释放后虚拟投放的建筑</p>
							<p>LimboDelivery.IDs=1,2,3 ;三个建筑的ID</p>
							<p>LimboDelivery.RollChance=33%,33%,33% ;三个建筑被投放的概率</p>
							<p>LimboDelivery.RandomWeights0=10 ;间谍卫星的权重增量</p>
							<p>LimboDelivery.RandomWeights2=10 ;矿石精炼器的权重增量</p>
							<p>LimboDelivery.RandomWeights3=10 ;工业工厂的权重增量</p>
							<br>
							<p>[LimboKillSpecial] ;删除虚拟建筑超级武器</p>
							<p>...</p>
							<p>SW.AutoFire=yes ;自动发射</p>
							<p>...</p>
							<p>LimboKill.IDs=1,2,3 ;删除建筑的ID</p>
							<p>LimboKill.Affects=self ;删除建筑的所属方</p>
						</div>
					</div>
					<h4 type="button" class="collapsible">超级武器连续释放<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">弹头和武器释放<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义超级武器栏目<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>单位</h3>
					<h4 type="button" class="collapsible">自定义子机扩展<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自动删除乘员</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">乘员随载具更改所属方</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自动开火武器</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义乘员开火</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">关闭副武器自动推算</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义Burst开火坐标</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">初始血量</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">单位自动消失</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">心灵控制扩展</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">禁止手动移动</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">水下单位显形</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>地形</h3>
					<h4 type="button" class="collapsible">破坏动画和声音</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>弹头</h3>
					<h4 type="button" class="collapsible">心控解除</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">暴击</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义水花动画</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">全局引爆</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">爆金币</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">超级武器引信</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">移除伪装</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">开图</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">黑幕</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">触发指定的非人死亡动画</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3>武器</h3>
					<h4 type="button" class="collapsible">自定义范围攻击目标</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">Burst开火延迟</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">反馈武器</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">辐射扩展</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">自定义飞行器扫射</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h4 type="button" class="collapsible">目标选择筛选</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h2 id="fixed-logic">修复或改善的逻辑</h2>
					<h3>BUG修复和杂项</h3>
					<h3>其他平台的问题修复</h3>
					<h3>飞行器</h3>
					<h3>动画</h3>
					<h3>建筑</h3>
					<h3>粒子系统</h3>
					<h3>粒子</h3>
					<h3>抛射体</h3>
					<h3>单位</h3>
					<h3>地形</h3>
					<h3>矿石</h3>
					<h3>载具</h3>
					<h3>藤蔓与废料</h3>
					<h3>VXL碎片</h3>
					<h3>弹头</h3>
					<h3>武器</h3>
					<h3>杂项</h3>
					<h2 id="ai-script">AI编写和地图编辑</h2>
					<h3>BUG修复和杂项</h3>
					<h3>单人任务地图</h3>
					<h3>脚本动作</h3>
					<h3>触发动作</h3>
					<h3>触发事件</h3>
					<h2 id="user-interface">用户界面</h2>
					<h2 id="misc">杂项</h2>
				</div>
			</div>
		</div>
	</main>
	<!--Footer-->
	<footer>
		<div class="footer-container">
			<div class="footer-left">
				<div class="footer-logo">
					<img src="../../src/favicon.svg" alt="Bellum Aeternum" width="64" height="64">
					<p>万世<br>之战</p>
				</div>
				<div class="lang-selector">
					<p>语言切换</p>
					<div class="lang-list">
						<a href="https://ra2be.com">EN</a>
						<a href="https://ra2be.com/zh/">中</a>
					</div>
				</div>
			</div>
			<div class="footer-right">
				<div class="footer-column">
				<p>阵营</p>
				<ul>
					<li><a href="allied.html">盟军</a></li>
					<li><a href="soviet.html">苏联</a></li>
				</ul>
				</div>
				<div class="footer-column">
				<p>文章</p>
				<ul>
					<li><a href="blog.html#concept">概念</a></li>
					<li><a href="blog.html#tutorial">教程</a></li>
				</ul>
				</div>
				<div class="footer-column">
				<p>关于</p>
				<ul>
					<li><a href="#contact">联系作者</a></li>
				</ul>
				</div>
			</div>
		</div>
		<div class="footer-portals">
			<a href="https://space.bilibili.com/3546721533561614"><img src="../src/bilibili.svg" width="auto" height="16px">&ensp;B站主页</a>
		</div>
	</footer>
	<script>
		var coll = document.getElementsByClassName("collapsible");
		var i;

		for (i = 0; i < coll.length; i++) {
		  coll[i].addEventListener("click", function() {
		    this.classList.toggle("active");
		    var content = this.nextElementSibling;
		    if (content.style.maxHeight){
		      content.style.maxHeight = null;
		    } else {
		      content.style.maxHeight = content.scrollHeight + "px";
		    } 
		  });
		}
	</script>
</body>