<!DOCTYPE html>
<html lang="zh-Hans">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" type="text/css" href="../../style.css">
	<meta name="description" content="红色警戒2：尤里的复仇Phobos平台中文教程。">
	<link rel="icon" type="image/svg" href="../../src/favicon.svg">
	<meta name="robots" content="noindex, nofollow">
	<title>Phobos中文教程 | 万世之战：为红警2带来前所未有的体验</title>
	<style>
		.blog-content ul {
			list-style-position: outside;
			background-color: #66666650;
			padding: 1em;
		}

		.blog-content ol {
			list-style-position: outside;
			background-color: #66666650;
			padding: 1em;
		}

		.blog-content li {
			margin: 0.25em;
			line-height: 1.5em;
		}

		#version {
			vertical-align: middle;
			font-size: 12px;
			font-family: HarmonyOS Sans;
			font-weight: bold;
			background-color: #f00;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: center;
			line-height: 16px;
		}

		.collapsible #version {
			vertical-align: middle;
			font-size: 12px;
			font-family: HarmonyOS Sans;
			font-weight: bold;
			background-color: #f00;
			border-radius: 4px;
			padding: 1px 4px;
			margin: 0 0.5em;
			color: #ccc;
			text-align: left;
			line-height: 1em;
		}

		#versionx {
			vertical-align: middle;
			font-size: 12px;
			font-family: HarmonyOS Sans;
			font-weight: bold;
			background-color: #900;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: center;
			line-height: 16px;	
		}

		.collapsible #versionx {
			vertical-align: top;
			font-size: 12px;
			font-family: HarmonyOS Sans;
			font-weight: bold;
			background-color: #900;
			border-radius: 4px;
			padding: 1px 4px;
			margin: auto 2px;
			color: #ccc;
			text-align: left;
			line-height: 20px;
		}

		code {
			font-family: Neon;
			font-size: 16px;
			font-weight: normal;
			border: 1px dotted #fff;
			border-radius: 4px;
			background-color: #000;
			padding: 0.2em 0.4em;
			margin: 0 0.2em 0 0;
			user-select: text;
			text-align: center;
		}

		#comment {
			border: 1px dashed #fff;
			font-family: HarmonyOS Sans;
			font-size: 16px;
			font-weight: 300;
			padding: 0.5em 1em;
			margin: 0.5em auto;
		}

		#alert {
			border: 1px dashed #fcc;
			font-size: 14px;
			font-weight: normal;
			padding: 0.2em;
			background-color: #933;
			margin: 0.5em auto;
		}

		#highlight {
			border: 1px solid #fff;
			font-size: 14px;
			font-weight: bold;
			padding: 1em;
			background-color: #c63;
			margin: 0.5em auto;
			border-radius: 2px;
			text-align:center;
			text-shadow: 0 1px 1px #000;
		}

		.blog-content h3{
			font-size: 18px;
			margin: 2px auto;
		}

		.blog-content h4{
			font-size: 20px;
			font-weight: bold;
			line-height: 1em;
			margin: 1em auto;
		}

		.blog-content h4:before {
			content:'\2605';
			color: #f00;
		}

		.index-navigator {
			display: flex;
			flex-flow: column;
			width: 50%;
			margin: 1em 0;
			padding: 1vw;
			background-color: #666;
			border: 1px solid #fff;
		}

		.index-navigator a {
			font-size: 18px;
			font-weight: bold;
			color: #fff;
			text-decoration: none;
			text-shadow: 1px 1px 1px #333;
			text-align: left;
			margin: 0.5em;
			padding-left: 0.5em;
			border-left: 4px solid #fff;
		}

		.phobos-table {
			margin:5vh 0;
			overflow-x: auto;
			font-size: 14px;
		}

		.phobos-table table, th, tr, td {
			border: 1px solid #fff;
			border-collapse: collapse;
			padding: 0.5em;
			border-width: 1px;
		}

		.phobos-table tr {
			margin: 0.5em;
		}

		.phobos-table th {
			background-color:#993333;
			padding: 0.25em;
			text-align: center;
		}

		.phobos-table td {
			background-color:#08080850;
			padding: 0.5em 0.25em;
			text-align: left;
			line-height: 1.25em;
			min-width: 6em;
		}

		.phobos-table ul {
			background-color: #66666600;
		}

		.phobos-table li {
			margin: 0;
			line-height: 1.5em;
			font-size: 14px;
		}

		.phobos-table code {
			font-size: 14px;
		}
	</style>
</head>
<body>
	<header>
		<div class="navigation-buttons">
			<div class="navigation-button">
				<a href="https://ra2be.com/zh">主页</a>
			</div>
			<div class="navigation-button">
				<a href="../archives.html">档案库</a>
			</div>
			<div class="navigation-button">
				<a href="../blog.html">博客</a>
			</div>
			<div class="navigation-button">
				<a href="../download.html">下载</a>
			</div>
		</div>
		<div class="responsive-navigation">
			<a href="https://ra2be.com/zh"><img src="../../src/favicon.svg" alt="logo" width="36px" height="36px"></a>
			<div class="responsive-navigation-buttons">
				<a href="../archives.html">档案库</a>
				<a href="../blog.html">博客</a>
				<a href="../download.html">下载</a>
			</div>
		</div>
	</header>
	<!--Main-->
	<main>
		<div class="blog">
			<h1></h1>
			<div class="blog-info">
				<div class="update-time">
					<p>最后更新时间：<time datetime="2025-03-24 18:00">2025/3/24</time></p>
				</div>
			</div>			
			<div class="blog-main">
				<div class="blog-left">
					<div class="blog-info"></div>
					<div class="chap-nav">
						<p>快速导航</p>
						<div class="chaps">
						</div>
					</div>
				</div>
				<div class="blog-content">
					<h1>Phobos中文教程</h1>
					<h2>前言</h2>
					<h3>关于教程</h3>
					<p>本教程并非Phobos的全面教程，而是对Phobos官方教程中语焉不详的部分进行一定的查漏补缺。因此，本教程并不会覆盖Phobos的所有功能。</p>
					<p>本教程是以开发版的内容为基准撰写，直至教程编撰日期，Phobos的开发版为b46版本。如果你是稳定版用户，请移步Phobos的官方文档。</p>
					<h3>代码术语目录表</h3>
					<ul>
						<li>布尔值（Boolean）：开关参数值，填入true或false，或者yes或no。</li>
						<li>列表（List）：多个值的集合，用英文的逗号<code>,</code>隔开。</li>
						<li>浮点值（Float）：指的是用小数表示任意实数的值，比如1为整数，其浮点值就要写为1.0或者1.00等待小数点的值。</li>
					</ul>
					<h3>红警相关术语目录表：</h3>
					<ul>
						<li>对象（ObjectType）：所有游戏内可视物的总称，包括科技类型、动画、粒子、地形、覆盖物、污染等。</li>
						<li>科技类型（TechnoType）：包含建筑、步兵、载具和飞行器的总称。</li>
						<li>单位类型（UnitType）：包含步兵、载具和飞行器的总称。</li>
						<li>建筑插件（PowersUp）：指的是类似泰伯利亚之日中GDI发电厂涡轮、必须以其他建筑为基础才能放置的建筑。</li>
					</ul>
					<!--New Logic-->
					<h2 id="new-objects">新的类型</h2>
					<p>新的类型指的是需要新起一个注册表的逻辑，众所周知，红警里大部分类型都需要先注册再定义。</p>
					<h3 type="button" class="collapsible">附加效果（AE）</h3>
					<div class="col-content">
						<p>附加效果，言简意骇，就是在红警中做到类似buff的功能。因为原版教程的内容较复杂，在这里先用简单的文字描述其特性。</p>
						<p>官方教程里的附加效果代码较多，写的比较乱，这里我会将其分为三大类：“附加效果如何生成？”、“附加效果能干啥”以及“附加效果如何消失？”</p>
						<p>首先是如何生成，目前支持的方法如下：</p>
						<ol>
							<li>直接在科技类型上挂载。</li>
							<li>由弹头引爆赋予。</li>
						</ol>
						<p>其次是能干啥，目前支持的功能如下：</p>
						<ol>
							<li>提供隐形。</li>
							<li>修改单位基本属性：装甲、火力、速度和射速。</li>
							<li>修改武器射程。</li>
							<li>修改暴击属性。</li>
							<li>提供复仇武器。</li>
							<li>沉默（无法开火）。</li>
							<li>单位染色。</li>
							<li>附带动画。</li>
							<li>结束时发射武器。</li>
						</ol>
						<p>最后是如何消失，目前有如下条件可以让附加效果消失：</p>
						<ol>
							<li>计时器倒计时结束。</li>
							<li>单位处于特定状态：进入、移动、静止、吸取、射程内、射程外、开火。</li>
							<li>停电。</li>
						</ol>
						<p>和Ares的附加效果逻辑不同，Phobos将附加效果直接做成了一种对象，因此你定义的附加效果需要在新建的注册表中注册。</p>
						<h4>附加动画基本定义标签：</h4>
						<div class="phobos-table">
							<table>
								<tr>
									<th>标签</th>
									<th>参数类型</th>
									<th>参数单位</th>
									<th>默认值</th>
									<th>功能</th>
								</tr>
								<tr>
									<td><code>Duration</code></td>
									<td>整数</td>
									<td>帧</td>
									<td>0</td>
									<td>定义该附加效果可以持续多长时间，可以被单位和弹头上的<code>DurationOverrides</code>覆盖，可以填入负数代表不定时长。</td>
								</tr>
								<tr>
									<td><code>Cumulative</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该附加效果的时长是否可叠加。</td>
								</tr>
								<tr>
									<td><code>Cumulative.MaxCount</code></td>
									<td>整数</td>
									<td>无</td>
									<td>0</td>
									<td>定义该附加效果的最大叠加层数。为正整数来定义相同附加效果可以叠加的层数，如果设为负数，相同附加效果则可以无限叠加。如果某单位的附加效果已经达到了可携带的最高层数但继续附加，则最新的附加效果会替换掉持续时长最短的效果。</td>
								</tr>
								<tr>
									<td><code>Powered</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义拥有该附加效果的单位在<abbr title="遥控坦克断电或被电磁脉冲击中">瘫痪</abbr>中是否会改变附加效果的动画。</td>
								</tr>
								<tr>
									<td><code>DiscardOn</code></td>
									<td>预设值</td>
									<td>无</td>
									<td>none</td>
									<td>定义该附加效果会在什么条件下会消失，默认为<code>none</code>，可以填入多个参数，参数详解如下：</p>
										<ul>
											<li><code>entry</code>：单位离开地图时，如进入建筑或进入载具。</li>
											<li><code>move</code>：单位移动时，如果是建筑则无视这个效果。</li>
											<li><code>stationary</code>：单位静止时，如果是建筑则无视这个效果。</li>
											<li><code>drain</code>：单位被带有<code>DrainWeapon=true</code>的吸取武器攻击时。</li>
											<li><code>inrange</code>：单位在附加效果来源的攻击范围之内时，可通过<code>DiscardOn.RangeOverride</code>来覆盖距离。</li>
											<li><code>outofrange</code>：单位在附加效果来源的攻击范围之外时，可通过<code>DiscardOn.RangeOverride</code>来覆盖距离。</li>
											<li><code>firing</code>：单位开火时，子机武器或吸取武器等特殊武器同样受影响。</li>
										</ul>
									</td>
								</tr>
								<tr>
									<td><code>PenetratesIronCurtain</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该附加效果是否对带有铁幕的单位有效。</td>
								</tr>
								<tr>
									<td><code>PenetratesForceShield</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td><code>PenetratesIronCurtain</code>的值。</td>
									<td>定义该附加效果是否对带有力场护盾的单位有效。</td>
								</tr>
							</table>
						</div>
						<h4>定义附加动画表现形式的标签：</h4>
						<div class="phobos-table">
							<table>
								<tr>
									<th>标签</th>
									<th>参数类型</th>
									<th>参数单位</th>
									<th>默认值</th>
									<th>功能</th>
								</tr>
								<tr>
									<td><code>Animation</code></td>
									<td>动画注册名</td>
									<td>无</td>
									<td>none</td>
									<td>定义该附加效果的动画，该动画会自动循环播放，无视<code>Artmd.ini</code>中的<code>LoopCount</code>。</td>
								</tr>
							</table>
						</div>
						<p></p>
					</div>
					<h3 type="button" class="collapsible">自定义辐射类型</h3>
					<div class="col-content">
						<p>现在任何武器都可以拥有自定义的辐射类型。使用自定义辐射需要创建一个新的注册表<code>[RadiationTypes]</code>，并注册新的辐射名称。</p>
						<p><b>全局定义：</b></p>
						<p>开启自定义辐射参数需要在全局代码<code>[Radiation]</code>中加入<code>UseGlobalRadApplicationDelay</code>，参数为布尔值。如果设定为True，那么新增加的辐射会使用全局的辐射参数，反之设定为False，那么则可以定义辐射的属性。</p>
						<p><b>辐射定义：</b></p>
						<p><code>RadApplicationDelay.Building</code>定义该辐射类型的对建筑的效果，参数为整数，填入大于0的值将伤害建筑。</p>
						<p><code>RadBuildingDamageMaxCount</code>限制辐射对建筑的最多伤害的次数，参数为整数。和<code>CellSpread</code>的机制类似，因为建筑通常占有多个地格，因此辐射也会对建筑造成每个地格叠加的伤害，所以需要用这段代码来控制伤害。填入负值代表不做限制。</p>
						<p><code>RadSiteWarhead.Detonate</code>定义是否让辐射的弹头附带其他弹头效果而不是单纯的伤害比例控制，参数为布尔值。原版中辐射场的弹头只用于伤害控制，因此单位走到辐射场中不会有受击的动画。</p>
						<p id="comment">笔者注：若非特殊需求建议把这个功能关掉，非常消耗性能。</p>
						<p><code>RadSiteWarhead.Detonate.Full</code>定义是否只保留弹头的范围伤害和Phobos专属的弹头效果，参数为布尔值。</p>
						<p><code>RadHasOwner</code>定义该辐射类型是否附带所属信息，填入布尔值。填入true则被该辐射所击杀的敌军单位会记录在玩家游戏数据中，同时也可以自定义其他相关的弹头设置，比如利用<code>AffectsAllies</code>来控制辐射是否影响友军。</p>
						<p><code>RadHasInvoker</code>定义该辐射类型是否附带击杀者信息，填入布尔值。填入true则释放该辐射的单位可以通过辐射击杀的单位获得经验值。</p>
						<p><b>为武器添加自定义辐射：</b></p>
						<p><code>RadType</code>：定义武器附带的辐射类型。</p>
						<p><b>代码示例：</b></p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Radiation] ;全局控制</p>
							<p>UseGlobalRadApplicationDelay=no ;开启自定义辐射参数</p>
							<br>
							<p>[RadiationTypes] ;新的注册表</p>
							<p>0=NewRadiation ;注册新的辐射类型</p>
							<br>
							<p>[NewWeapon] ;带辐射的武器</p>
							<p>RadType=NewRadiation ;辐射类型</p>
							<p>RadLevel=200 ;辐射量，一定要高于RadLevelDelay的值。</p>
							<br>
							<p>[NewRadiation] ;定义新的辐射类型</p>
							<p>RadDurationMultiple=1 ;控制辐射的存续时间，公式为RadLevel * RadDurationMultiple<p>
							<p>RadApplicationDelay=16 ;控制辐射造成伤害的间隔</p>
							<p>RadApplicationDelay.Building=32 ;控制辐射对建筑造成伤害的间隔</p>
							<p>RadBuildingDamageMaxCount=-1 ;控制辐射对建筑造成伤害的最高次数</p>
							<p>RadLevelMax=500 ;控制辐射的在单元格内最高值</p>
							<p>RadLevelDelay=90 ;重新计算辐射量的间隔</p>
							<p>RadLightDelay=90 ;重新计算辐射光照的间隔</p>
							<p>RadLevelFactor=0.2 ;辐射伤害参数，公式为RadLevel * RadLevelFactor</p>
							<p>RadLightFactor=0.1 ;辐射光照参数</p>
							<p>RadTintFactor=1.0 ;辐射染色参数</p>
							<p>RadColor=0,255,0  ;辐射颜色的RGB值</p>
							<p>RadSiteWarhead=RadSite ;辐射伤害的弹头</p>
							<p>RadSiteWarhead.Detonate=false ;辐射弹头效果是否开启</p>
							<p>RadSiteWarhead.Detonate.Full=true ;是否开启全部弹头效果</p>
							<p>RadHasOwner=true ;辐射是否带所属</p>
							<p>RadHasInvoker=true ;辐射击杀是否给辐射源单位经验</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">激光拖尾</h4>
					<div class="col-content">
						<p>激光拖尾是一种全新的拖尾方式，其可定义透明度、宽度和颜色。</p>
						<p>激光拖尾可以使用在单位、抛射体和VXL碎片上。</p>
						<p>附着对象是单位时支持多个激光拖尾，并可以定义其FLH坐标。对于有多个组件（如坦克的炮塔）的单位，可以自定义激光拖尾附着的部件。</p>
						<p><b>代码示例：</b></p>
						<p>在<code>art.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LaserTrailTypes] ;激光拖尾的注册表</p>
							<p>0=NewTrail ;注册新的激光拖尾</p>
							<br>
							<p>[NewTrail] ;定义新的激光拖尾</p>
							<p>IsHouseColor=false ;激光拖尾是否是所属色</p>
							<p>Color=255,0,0 ;激光拖尾的RGB颜色</p>
							<p>FadeDuration=64 ;激光拖尾持续的时间，值越大持续时间越长</p>
							<p>Thickness=4 ;激光拖尾的宽度</p>
							<p>SegmentLength=128 ;每一段激光的长度</p>
							<p>IgnoreVertical=false ;附着对象在垂直移动时不会产生激光拖尾</p>
							<p>IsIntense=false ;boolean, whether the laser is "supported" (AKA prism forwarding)</p>
							<p>CloakVisible=false ;附着对象在隐身之后是否会显示激光拖尾</p>
							<p>CloakVisible.DetectedOnly=false  ;附着对象在被探测到（非显形）后是否会显示激光拖尾</p>
							<br>
							<p>[NewProjectile] ;抛射体图像</p>
							<p>LaserTrail.Types=NewTrail ;抛射体的激光拖尾，可以使用列表表示多个拖尾。</p>
							<br>
							<p>[NewUnit] ;单位图像</p>
							<p>LaserTrail1.Types=NewTrail ;单位的第一条激光拖尾</p>
							<p>LaserTrail2.Type=NewTrail ;单位的第二条激光拖尾</p>
							<p>LaserTrail1.FLH=0,-50,0 ;第一条激光拖尾的起始坐标</p>
							<p>LaserTrail2.FLH=0,50,0 ;第二条激光拖尾的起始坐标</p>
							<p>LaserTrail1.IsOnTurret=false ;第一条激光拖尾是否附着在单位的炮塔上</p>
							<p>LaserTrail2.IsOnTurret=false ;第二条激光拖尾是否附着在单位的炮塔上</p>
						</div>
						<br>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewVoxelAnim] ;VXL碎片</p>
							<p>LaserTrail.Types=NewTrail  ;VXL碎片的激光拖尾，可以使用列表表示多个拖尾。</p>
						</div>
						<p id="alert">注意：激光拖尾非常消耗性能，因为游戏不存在GPU渲染，过多的激光拖尾会让游戏变得非常卡，不论你的电脑多高端。一、建议不要为单位或抛射体过多的挂激光拖尾；二、建议将<code>SegmentLength</code>尽量调高。三、建议将<code>FadeDuration</code>尽量调低。</p>
					</div>
					<h3 type="button" class="collapsible">护盾</h4>
					<div class="col-content">
						<h5>护盾的注册：</h5>
						<p>护盾作为一种新的对象，是需要新建一个注册表的。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ShieldTypes]</p>
							<p>1=NewShield</p>
						</div>
						<h5>护盾的定义：</h5>
						<p>护盾本质上可以看做是让单位拥有一个独立装甲和强度（血量）的第二血条，具备以下基础特性：</p>
						<ul>
							<li>护盾在下列状态下不会掉强度：
								<ol>
									<li>被超时空弹头攻击时</li>
									<li>在被铁幕或者力场护盾保护时</li>
									<li>单位拥有<code>Immune=true</code>时</li>
									<li>单位被自身所免疫的弹头攻击时</li>
									<li>单位被盟友攻击时</li>
								</ol>
							</li>
							<li>护盾在未消失的情况下，负数伤害会修复护盾强度，届时所有的负数伤害会被护盾吸收。除非负数伤害的弹头带有<code>Shield.Penetrate=true</code>语句，否则无法在有护盾的情况下为单位增加血量。</li>
							<li>当单位拥有护盾时，护盾定义中的<code>Armor</code>将会代替单位本身的<code>Armor</code>来计算伤害。如果想关闭这个机制，可以用<code>InheritArmorFromTechno=true</code>来让单位本身的<code>Armor</code>覆盖护盾的<code>Armor</code>。</li>
							<li>护盾的初始强度使用<code>InitialStrength</code>来定义，这个值可以不等于最大强度。</li>
						</ul>
						<p>当单位执行部署变形（无论是原版的武装直升机逻辑还是Ares的单位转换）时，如果单位A和单位B都有护盾，那么变形后相应的护盾会按照百分比保留之前护盾强度值。但如果单位A有护盾而单位B没有护盾的情况，单位A的护盾的状态将会被封存，直到从单位B再变形为单位A继续生效。</p>
						<p><code>Powered</code>定义护盾是否受电磁脉冲和遥控坦克停电效果的影响，参数为布尔值，True为受影响，False为不受影响。</p>
						<p><code>AbsorbOverDamage</code>定义护盾是否可以抵挡超额伤害，参数为布尔值，True为可以抵挡，False为超额伤害算进单位自身血量。</p>
						<p><code>SelfHealing</code>定义护盾恢复强度的值，参数为浮点值或者百分比。填入0.0的情况下护盾不会自动恢复，填入百分比的情况下每次恢复百分比值的强度。填入负数的情况每次恢复将会扣除强度。如果你想让护盾每次恢复1点强度，可以填入1到2的任意浮点值，比如1.1。</p>
						<p><code>Respawn</code>定义护盾重生的强度值，参数和<code>SelfHealing</code>一致。</p>
						<p><code>SelfHealing.Rate</code>定义护盾恢复强度的间隔，参数为浮点值，单位为分钟（游戏内）。设置为0.0的时候直接将护盾恢复成满强度。</p>
						<p><code>Respawn.Rate</code>定义护盾重生的间隔，参数为浮点值，单位为每分钟（游戏内）。设置为0.0的时候直接生成一个满强度护盾。</p>
						<h5>护盾的图像：</h5>
						<p><code>IdleAnim</code>定义护盾生效时播放的动画，该动画会无视<code>LoopCount</code>无限循环，并可以用下列代码定义：</p>
						<ul>
							<li><code>IdleAnim.ConditionYellow</code>和<code>IdleAnim.ConditionRed</code>定义该护盾在强度值呈黄色和红色的状态下所播放的不同的护盾动画。如果不设置<code>IdleAnim.ConditionRed</code>，在血条呈红色时将会调用<code>IdleAnim.ConditionYellow</code>的动画；如果<code>IdleAnim.ConditionYellow</code>也不设置，将直接使用<code>IdleAnim</code>的动画。血条呈黄色和红色的百分比可以在<code>[AudioVisual]</code>中的<code>ConditionYellow</code>和<code>ConditionRed</code>中设置。</li>
							<li><code>IdleAnimDamaged</code>定义残血单位的护盾动画，同样可以用<code>IdleAnimDamaged.ConditionYellow</code>和<code>IdleAnimDamaged.ConditionRed</code>定义不同护盾值下的动画，使用和<code>IdleAnim</code>相同的默认值逻辑。</li>
							<li>避免使用带有<code>Bouncer=true</code>和<code>IsMeteor=true</code>的动画。</li>
						</ul>
						<p><code>IdleAnim.OfflineAction</code>定义单位停电时的护盾动画。</p>
						<p><code>IdleAnim.TemporalAction</code>定义单位在被超时空弹头击中后的护盾动画。</p>
						<p><code>BreakAnim</code>定义破盾动画，这个动画可以挂载粒子系统，但不能挂载弹头和碎片。</p>
						<p><code>HitAnim</code>定义护盾的受击动画，这个动画可以挂载粒子系统，但不能挂载弹头和碎片。</p>
						<p><code>HitFlash</code>定义护盾的受击闪光。可以在弹头上使用<code>Shield.HitFlash=false</code>来关闭闪光。伤害越高闪光越亮，同时可以在护盾中定义<code>HitFlash.FixedSize</code>来控制亮度（取值范围以4为增量，从81到252，范围之外无效）。闪光颜色可以用<code>HitFlash.Red/Green/Blue</code>来控制RGB色，参数为布尔值，表示开启或关闭该颜色。如果把<code>HitFlash.Black</code>设置为True，则闪光会变成黑色，并无视一切颜色控制。</p>
						<p><code>BreakWeapon</code>定义破盾时释放的武器，武器会在单位的地格引爆。</p>
						<p><code>AbsorbPercent</code>定义护盾能承受伤害的百分比，参数为浮点值，默认为1.0，即全部承受。如果小于1.0，那么伤害将会穿破护盾，扣除相应的单位血量。</p>
						<p><code>PassPercent</code>定义护盾会被穿透的伤害的百分比，参数为浮点值，默认为0.0，即不会被穿透。</p>
						<p><code>AllowTransfer</code>定义护盾是否在单位变形（原版武装直升机逻辑或者Ares的变形逻辑）后继承，默认为true，即可以继承。</p>
						<p>带有<code>Psychedelic=yes</code>的弹头（神经毒气）默认无视护盾，如果没有<code>ImmuneToBerserk</code>，带护盾的单位一样会无差别攻击。同时，免疫神经毒气的单位也无法避免被该类型弹头作为目标，因此可以使用自定义护甲来避免这种情况发生。</p>
						<h5>护盾的标识：</h5>
						<p>有护盾的单位会显示血条和护盾条，如果护盾是可再生的，那么护盾强度即便归零也会呈现为一个空框。护盾的护盾条图像可以在在<code>[AudioVisual]</code>部分定义，下列代码是关于护盾条的定义：</p>
						<ul>
							<li>默认情况下，建筑的血条使用<span style="color:orange">pips.shp</span>的第6帧作为护盾条，其他单位则使用第17针作为护盾条。</li>
							<li><code>Pips.Shield</code>可以自定义非建筑单位的护盾条，<code>Pips.Shield.Building</code>定义建筑单位的护盾条，参数为整数，表示第几帧。如果只填入一个值，代表护盾条一直会显示该帧的样式，如果填入三个值，那么三个值分别表示“绿色护盾条”“黄色护盾条”和“红色护盾条”所用帧的样式。如果填入-1，那么则使用上述的默认值。</li>
							<li><code>Pips.Shield.Background</code>可以定义非建筑单位的护盾条边框，默认使用<span style="color:orange">pipbrd.shp</span>，第四帧被用作步兵的护盾条边框，第三帧被用作其他单位的护盾条边框。</li>
							<li><code>Pips.Shield.Building.Empty</code>可以定义建筑单位的护盾条非满格时的底色，默认使用<span style="color:orange">pips.shp</span>的第一帧。</li>
							<li><code>BracketDelta</code>可以定义护盾条的纵向位置，和原版<code>PixelSelectionBracketDelta</code>类似，负值向上移动，正值向下移动，单位为像素。对建筑无效。</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[AudioVisual]</p>
							<p>Pips.Shield=-1,-1,-1 ;单位的护盾条</p>
							<p>Pips.Shield.Building=-1,-1,-1 ;建筑的护盾条</p>
							<p>Pips.Shield.Background=PIPBRD.SHP ;护盾条边框</p>
							<p>Pips.Shield.Building.Empty=0 ;建筑上非满强度护盾的底色</p>
						</div>
						<p>如果你不想使用全局定义的护盾条，也可以在不同类型的护盾上做微观定义：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Shield]</p>
							<p>Pips=-1,-1,-1 ;单位的护盾条</p>
							<p>Pips.Building=-1,-1,-1 ;建筑的护盾条</p>
							<p>Pips.Background=pipbrd.shp ;护盾条边框</p>
							<p>Pips.Building.Empty=0 ;建筑上非满强度护盾的底色</p>
						</div>
						<h5>弹头相关设置：</h5>
						<p><code>Shield.Penetrate</code>定义该弹头是否能无视护盾直接对目标血量造成伤害。</p>
						<p><code>Shield.Break</code>定义该弹头是否能在伤害计算之前就破盾。</p>
						<p><code>Shield.BreakAnim</code>定义该弹头在破盾时的动画，这个设置将覆盖护盾中<code>BreakAnim</code>所定义的动画。</p>
						<p><code>Shield.HitAnim</code>定义该弹头在击中护盾时的动画，这个设置将覆盖护盾中<code>HitAnim</code>所定义的动画。</p>
						<p><code>Shield.BreakWeapon</code>定义该弹头破盾后的破盾武器，这个设置将覆盖护盾中<code>BreakWeapon</code>所定义的武器。</p>
						<p><code>Shield.AbsorbPercent</code>定义该弹头被护盾所吸收的量，这个设置将覆盖护盾中<code>AbsorbPercent</code>所定义的量。</p>
						<p><code>Shield.PassPercent</code>定义该弹头能穿过护盾伤害生命值的量，这个设置将覆盖护盾中<code>PassPercent</code>所定义的量。</p>
						<p><code>Shield.Respawn.Rate</code>和<code>Shield.Respawn.Amount</code>定义该弹头击中护盾后该护盾的再生间隔和再生耐久值，这个设置将覆盖护盾中<code>Respawn.Rate</code>和<code>Respawn.Amount</code>所定义的值，如果间隔填入负值或者再生值填入小于等于0的值将不会覆盖。这个效果的时长由<code>Shield.Respawn.Duration</code>控制。</p>
						<p><code>Shield.Respawn.ResetTimer</code>定义被该弹头击中的护盾的再生计时器是否重置，填入布尔值。</p>
						<p><code>Shield.SelfHealing.Rate</code>和<code>Shield.SelfHealing.Amount</code>定义被该弹头击中的护盾的耐久恢复间隔和耐久恢复值，这个设置将覆盖护盾中<code>SelfHealing.Rate</code>和<code>SelfHealing.Amount</code>所定义的值，如果间隔填入负值或者恢复值填入小于等于0的值将不会覆盖。这个效果的时长由<code>Shield.SelfHealing.Duration</code>控制。</p>
						<p><code>Shield.SelfHealing.ResetTimer</code>定义被该弹头击中的护盾的耐久恢复计时器是否重置，填入布尔值。</p>
						<p><code>Shield.AffectsTypes</code>定义会被该弹头的护盾修改器所影响的护盾，填入护盾类型，支持列表。</p>
						<p><code>Shield.AttachTypes</code>和<code>Shield.RemoveTypes</code>定义被（正<code>Verses</code>值的）该弹头击中后附加一个护盾或者移除一个护盾，填入护盾类型，支持列表，但通常只有列表中第一个护盾会生效。</p>
						<p><code>Shield.ReplaceOnly</code>定义<code>Shield.AttachTypes</code>中的护盾是否会按位置替换Shield.RemoveTypes中的护盾，参数为布尔值。如果前者少于后者，那么多余的被移除的护盾被前者的最后一个护盾替换。默认no。</p>
						<p><code>Shield.ReplaceNonRespawning</code>定义<code>Shield.AttachTypes</code>中的护盾是否会替换无法再生的护盾。</p>
						<p><code>Shield.MinimumReplaceDelay</code>定义<code>Shield.ReplaceNonRespawning</code>在多长时间之后替换之前无法再生的护盾。</p>
						<p><code>Shield.InheritStateOnReplace</code>定义用<code>Shield.ReplaceOnly</code>替换的护盾是否继承之前护盾的强度值，并重置再生计时器和强度恢复计时器。</p>
					</div>
					<h2 id="animations">动画相关</h2>
					<h3 type="button" class="collapsible" id="anim-create-unit">动画生成单位</h4>
					<div class="col-content">
						<p>动画可以在播放完毕后在单元格内生成一个任何类型的单位（载具、飞行器或步兵）。</p>
						<div class="phobos-table">
							<table>
								<tr>
									<th>标签</th>
									<th width="30%">参数类型</th>
									<th>参数单位</th>
									<th>默认值</th>
									<th>功能</th>
								</tr>
								<tr>
									<td><code>CreateUnit</code></td>
									<td>单位注册名</td>
									<td>无</td>
									<td>none</td>
									<td>定义该动画生成的单位，只能填一个。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.Owner</code></td>
									<td>
										下列预设值：
										<ul>
											<li><code>Invoker</code>：调用动画的对象的所属方。</li>
											<li><code>Killer</code>：摧毁该单位的所属方。</li>
											<li><code>Victim</code>：被摧毁单位的所属方。</li>
											<li><code>Civilian</code>：平民方。</li>
											<li><code>Special</code>：特殊方。</li>
											<li><code>Neutral</code>：中立方。</li>
											<li><code>Random</code>：随机。</li>
										</ul>
									</td>
									<td>无</td>
									<td>Victim</td>
									<td>
										<p>定义该动画生成的单位所属，只有在动画附带所属信息时才会生效，动画带有所属信息的方法如下：</p>
										<ul>
											<li>Phobos的<code>DestroyAnim</code></li>
											<li>弹头的<code>AnimList</code>和Phobos的弹头<code>SplashList</code></li>
											<li>41号地图触发动作</li>
										</ul>
									</td>
								</tr>
								<tr>
									<td><code>CreateUnit.RemapAnim</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画是否用单位调色盘绘制并且自带所属色。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.Mission</code></td>
									<td>任务类型</td>
									<td>无</td>
									<td>Guard</td>
									<td>定义该动画生成的单位出现后的任务。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.AIMission</code></td>
									<td>任务类型</td>
									<td>无</td>
									<td>Guard</td>
									<td>定义该动画生成的单位所属方是AI控制时的任务。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.Facing</code></td>
									<td>整数[0-255]</td>
									<td>无</td>
									<td>0</td>
									<td>定义该动画生成的单位朝向，0为两点钟方向，224为12点钟方向。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.RandomFacing</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画生成的单位朝向是否随机。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.InheritFacings</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画生成的单位朝向是否继承生成该动画的单位。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.InheritTurretFacings</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画生成的单位炮塔朝向是否继承生成该动画的单位，不支持Jumpjet类载具（如直升机等）。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.ConsiderPathfinding</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画生成时如果该单元格有其他单位是否会在周边找一个合适的单元格生成</td>
								</tr>
								<tr>
									<td><code>CreateUnit.AlwaysSpawnOnGround</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画生成的单位是否在地面生成，即便动画在空中播放。如果填入false，那么在地面爆炸的Jumpjet类载具会自动起飞。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.SpawnParachutedInAir</code></td>
									<td>布尔值</td>
									<td>无</td>
									<td>false</td>
									<td>定义该动画生成的单位如果是在空中生成，是否会用降落伞降落到地面，在<code>CreateUnit.AlwaysSpawnOnGround=true</code>存在时无效。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.SpawnAnim</code></td>
									<td>动画注册名</td>
									<td>无</td>
									<td>none</td>
									<td>定义该动画生成单位之后所播放的动画。</td>
								</tr>
								<tr>
									<td><code>CreateUnit.SpawnHeight</code></td>
									<td>整数</td>
									<td>Lepton</td>
									<td>-1</td>
									<td>定义该动画生成的单位初始高度，设置为正整数时将覆盖动画的高度。在<code>CreatUnit.AlwaysSpawnOnGround</code>设置成true时无效。</td>
								</tr>
							</table>
						</div>
					</div>
					<h3 type="button" class="collapsible">动画附加粒子系统</h4>
					<div class="col-content">
						<p>现在可以将粒子系统附加到动画中。和VoxelAnims的标签类似，只支持带有<code>BehavesLike=Smoke</code>的粒子系统。</p>
						<p>如果动画带有<code>Next</code>，则在下一个动画开始时该粒子系统会被删除。</p>
						<p><code>AttachedSystem</code>定义该动画附加的粒子系统，参数为粒子系统的注册名。</p>
						<p>代码示例（该代码来自万世之战中蒸汽机车头的开火动画）：</p>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TRNSMK] ;Smoke for Steam Locomotive</p>
							<p>AttachedSystem=TrainSmokeSys ;动画附带的粒子系统名</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">自定义动画可视方</h4>
					<div class="col-content">
						<p>现在可以为动画定义可见的所属方。</p>
						<p><code>VisibleTo</code>定义哪些所属方可以看见该动画，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：所有所属方均不可见。</li>
							<li><code>owner</code>或<code>self</code>：只有生成该动画的所属方可见。</li>
							<li><code>allies</code>或<code>ally</code>：只有生成该动画的所属方的盟友可见。</li>
							<li><code>team</code>：生成该动画的所属方和其盟友均可见。</li>
							<li><code>enemies</code>或<code>enemy</code>：生成该动画的所属方的敌人均可见。</li>
							<li><code>all</code>：所有所属方均可见。</li>
						</ul>
						<p><code>VisibleTo.ConsiderInvokerAsOwner</code>是否将生成该动画的单位的所属方视为该动画的所属方，参数为布尔值。</p>
						<p><code>RestrictVisibilityIfCloaked</code>定义该动画在附加对象隐型时是否可视，参数为布尔值。</p>
						<p><code>DetachOnCloak</code>定义该动画是否在附加对象隐型时是否取消附加。</p>
					</div>
					<h3 type="button" class="collapsible">独立的动画音效</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">动画武器和伤害设置</h4>
					<div class="col-content">
						<p>现在可以为动画加入<code>Weapon</code>来给动画赋予武器，以免直接使用<code>Damage</code>和<code>Warhead</code>造成难以控制的伤害。</p>
						<p><code>Weapon</code>定义动画所使用的武器，参数为武器注册名，武器需要在<code>[WeaponTypes]</code>下注册，需要Ares来提供这个功能。</p>
						<p><code>Damage.Delay</code>定义动画造成伤害的间隔，参数为整数，单位为动画的帧，并受动画的<code>Rate</code>影响。参数为0时关闭动画伤害间隔。</p>
						<p><code>Damage.DealtByInvoker</code>定义动画伤害是否归属于生成动画的单位，参数为布尔值，这个设置用于传递单位、所属方等信息。</p>
						<p><code>Damage.ApplyOncePerLoop</code>定义动画伤害是否在动画每次循环只生效一次，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[FIRE01]</p>
							<p>...</p>
							<p>Weapon=FireballLauncher ;动画伤害所使用的武器</p>
							<p>Damage.Delay=60 ;动画伤害的间隔</p>
							<p>Damage.DealtByInvoker=true ;动画伤害是否归属于生成动画的单位</p>
							<p>Damage.ApplyOncePerLoop=true ;动画伤害是否每次循环只生效一次</p>
						</div>
						<p id="alert">如果和Ares一起使用，那么Phobos的动画伤害和武器将覆盖Ares的相同功能。</p>
					</div>
					<h3 type="button" class="collapsible">自定义附加动画位置</h4>
					<div class="col-content">
						<p>附加动画的位置现在可以指定在中心而不是在附加对象的角落。</p>
						<p><code>UseCenterCoordsIfAttached</code>定义是否在对象的中心显示附加动画，参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">自定义附加动画的层级</h4>
					<div class="col-content">
						<p>附加动画的层级（Layer）现在可以指定是否跟随附加对象。</p>
						<p><code>Layer.UseObjectLayer</code>定义是否在对象的层级上显示附加动画，参数为布尔值，如果不设置，则动画的层级默认为Ground。</p>
						<p>这个功能主要用于解决附加动画的覆盖问题，假如你想把附加动画做成BUFF放置到单位选框的右下角，而单位和其他单位重叠后会挡住动画。此时，就可以用这个功能来将动画放置到最高图层，即在动画上加<code>Layer.UseObjectLayer=false</code>以及<code>Layer=Top</code>。</p>
					</div>
					<h3 type="button" class="collapsible">矿石动画隐藏设置</h4>
					<div class="col-content">
						<p>现在可以指定矿石隐藏闪光动画的阶段。该功能对于那些把矿石改成物资箱的Mod很有用。</p>
						<p><code>HideIfNoOre.Threshold</code>定义矿石在什么阶段会隐藏该动画，矿石闪光动画在<code>[General]</code>中的<code>OreTwinkle</code>中指定。</p>
					</div>
					<h2>建筑相关</h2>
					<h3 type="button" class="collapsible">自定义建筑延伸</h4>
					<div class="col-content">
						<p>现在可以自定义建筑延伸的属性，</p>
						<p><code>Adjacent.Allowed</code>定义哪些建筑可以在该建筑周围<code>Adjacent</code>定义的距离内放置，参数为建筑类型注册名的列表。</p>
						<p><code>Adjacent.Disallowed</code>定义哪些建筑不能在该建筑周围<code>Adjacent</code>定义的距离内放置，参数为建筑类型注册名的列表。</p>
						<p><code>NoBuildAreaOnBuildup</code>定义在建筑播放建造动画时，其无法作为延伸建筑。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GAPOWR] ;Allied Power Plant</p>
							<p>...</p>
							<p>Adjacent.Allowed=GAPILE,GAREFN ;周围可放置的建筑类型。</p>
							<p>Adjacent.Disallowed=NAHAND,NAREFN ;周围不可放置的建筑类型。</p>
							<p>NoBuildAreaOnBuildup=false ;播放建造动画时是否可以作为延伸建筑。</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">建筑插件扩展</h4>
					<div class="col-content">
						<p><code>PowersUp.Owner</code>定义该建筑插件现在可以定义放置的建筑的所属方，需要注意的是当插件放入建筑后，插件的所属方自动变更为该建筑所属方。参数为预设值，可填入下列值：</p>
						<ul>
							<li><code>none</code>：不可放置</li>
							<li><code>owner</code>或者<code>self</code>：仅可放在自己的建筑上</li>
							<li><code>allies</code>或者<code>ally</code>：仅可放在盟友的建筑上</li>
							<li><code>team</code>：可以放在自己和盟友的建筑上</li>
							<li><code>enemies</code>或者<code>enemy</code>：仅可放在敌人的建筑上</li>
							<li><code>all</code>：自己、盟友和敌人的建筑上均可放置</li>
						</ul>
						<p><code>PowersUp.Buildings</code>定义该建筑插件可以放在哪些建筑上，参数为列表，可以填入多个建筑。</p>
						<p id="alert">注意：因技术限制，使用Phobos的<code>PowersUp.Buildings</code>时，该插件不支持Ares提供的插件作为建造前提功能。如果使用原版的<code>PowersUpBuilding</code>则可以提供这个功能，请自行取舍。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewUpgrade] ;插件建筑</p>
							<p>PowersUp.Owner=Self ;放置建筑允许的所属方</p>
							<p>PowersUp.Buildings=NAPOWR,NANRCT ;可以放置的建筑</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">可摧毁障碍建筑</h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">电厂增幅器</h4>
					<div class="col-content">
						<p>当电厂增幅器存在于地图上时，会改变该所属方的电厂电量，如果电厂增幅器被摧毁，电量则会回归原本数值。</p>
						<p>电厂增幅器和电厂最大的区别就在于，电厂是直接增减总电量，而电厂增幅器需要在有电厂的情况下才会改变总电量。</p>
						<p>代码展示：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NAPWRE] ;Power Enhancer</p>
							<p>PowerPlantEnhancer.PowerPlants=NAPOWR,NANRCT ;可以增幅的电厂</p>
							<p>PowerPlantEnhancer.Amount=0 ;增幅电力的量</p>
							<p>PowerPlantEnhancer.Factor=1.5 ;增幅电力的倍数</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">间谍效果</h4>
					<div class="col-content">
						<p>Phobos现在能实现更多的间谍效果。</p>
						<p><code>SpyEffect.Custom</code>定义该建筑是否使用自定义间谍效果，参数为布尔值，只有为true时，下面的效果才会生效。</p>
						<p><code>SpyEffect.VictimSuperWeapon</code>定义在间谍进入该建筑后立刻对该建筑释放的超级武器，参数为超级武器的注册名。</p>
						<p><code>SpyEffect.InfiltratorSuperWeapon</code>和上面的标签功能相同，但对建筑释放的超级武器的所属是间谍的所属方。</p>
					</div>
					<!--Enhanced Infantries-->
					<h2 id="new-logic-infantries">步兵</h2>
					<h3 type="button" class="collapsible">匍匐/部署步兵开火坐标</h4>
					<div class="col-content">
						<p>现在步兵在匍匐开火或部署开火时可以使用新的开火坐标定位来覆盖<code>PrimaryFireFLH</code>和<code>SecondaryFireFLH</code>，同时也可以自定义Burst开火时每一发的开火坐标。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[E1]</p>
							<p>PronePrimaryFireFLH=0,0,0 ;主武器匍匐开火时的坐标</p>
							<p>ProneSecondaryFireFLH=0,0,0 ;副武器匍匐开火时的坐标</p>
							<p>DeployedPrimaryFireFLH=0,0,0 ;主武器部署开火时的坐标</p>
							<p>DeployedSecondaryFireFLH=0,0,0 ;副武器部署开火时的坐标</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">默认间谍伪装</h4>
					<div class="col-content">
						<p>步兵现在可以使用<code>DefaultDisguise</code>微观定义默认的间谍伪装，读取阵营高于Ares中阵营的<code>DefaultDisguise</code>。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[SSPY] ;Soviet Spy</p>
							<p>DefaultDisguise=E2 ;默认伪装的步兵</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">非人类步兵死亡动画</h4>
					<div class="col-content">
						<p>拥有<code>NotHuman=yes</code>标签的步兵现在在死亡时可以随机从动画序列中挑选<code>Die1</code>到<code>Die5</code>播放。注意，确保你的步兵是有这些动画序列的，如果没有，在死亡时将不会播放任何动画。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[YDOG] ;Yuri Dog</p>
							<p>NotHuman.RandomDeathSequence=yes ;是否播放随机死亡动画</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">分享弹药</h4>
					<div class="col-content">
						<p>如果一个带有<code>OpenTopped=yes</code>的载具使用了弹药机制（<code>Ammo</code>），同时乘员也使用了弹药机制，就可以让载具为乘员补充弹药，并可以定义哪些乘员才可以补充弹药。注意，载具必须可以自动补充弹药。</p>
						<p><code>Ammo.Shared</code>定义乘员和载具是否分享弹药，参数为布尔值。</p>
						<p><code>Ammo.Shared.Group</code>定义该弹药的分组，相当于规定弹药的规格，参数为整数。只有乘员和载具设置了相同的数值时才可以分享弹药。填入-1则载具可以给所有乘员补充弹药。</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[BFRT] ;Battle Fortress</p>
							<p>...</p>
							<p>OpenTopped=yes ;乘员是否可以向外射击</p>
							<p>Ammo=5 ;弹药</p>
							<p>Reload=120 ;装填时间</p>
							<p>Ammo.Shared=yes ;是否分享弹药</p>
							<p>Ammo.Shared.Group=1 ;弹药分组</p>
							<br>
							<p>[SNIPE] ;Sniper</p>
							<p>Ammo.Shared=yes ;是否分享弹药</p>
							<p>Ammo.Shared.Group=1 ;弹药分组</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">奴隶阵营自定义</h4>
					<div class="col-content">
						<p>现在可以自定义奴隶矿场被摧毁后奴隶的归属。</p>
						<p><code>Slaved.OwnerWhenMasterKilled</code>定义奴隶矿场被摧毁后奴隶的归属，参数为以下预设值：</p>
						<ul>
							<li><code>suicide</code>：奴隶在奴隶矿场被摧毁后死亡。</li>
							<li><code>master</code>：奴隶在奴隶矿场被摧毁后归属奴隶矿场的所属方。</li>
							<li><code>neutral</code>：奴隶在奴隶矿场被摧毁后归属中立方。</li>
							<li><code>killer</code>：奴隶在奴隶矿场被摧毁后归属摧毁奴隶矿场的所属方。（原版方案）</li>
						</ul>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div id="slaves-house" class="code-presentation">
							<p>[SLAV]</p>
							<p>Slaved=yes ;是否为奴隶</p>
							<p>Slaved.OwnerWhenMasterKilled=killer ;奴隶矿场被摧毁后的归属方</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">自定义奴隶解救语音</h4>
					<div class="col-content">
						<p>奴隶矿工的解救语音现在可以微观定义。</p>
						<p><code>SlavesFreeSound</code>定义奴隶矿工的解救语音，参数为语音的注册名，这个标签在步兵代码中独立定义。</p>
					</div>
					<h3 type="button" class="collapsible">在水中使用陆地动作序列</h4>
					<div class="col-content">
						<p><code>OnlyUseLandSequences</code>定义步兵是否只播放在陆地上的动作序列，即便步兵在水中，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[SEAL]</p>
							<p>...</p>
							<p>OnlyUseLandSequences=true ;是否只显示陆地的动作序列。</p>
						</div>
					</div>
					<!--Enhanced Projectile-->
					<h2 id="new-logic-projectiles">抛射体相关</h3>
					<h3 type="button" class="collapsible">抛射体拦截</h4>
					<div class="col-content">
						<p>现在Phobos实现了类似《将军：绝命时刻》中美国复仇者防空车的抛射体拦截功能。拥有此功能的单位会自动扫描射程内可以拦截的抛射体，并使用相应的武器进行拦截。</p>
						<h5>抛射体的定义：</h5>
						<p><code>Interceptable</code>定义该抛射体是否可以被拦截，参数为布尔值。</p>
						<p><code>Armor</code>定义该抛射体所使用的装甲。</p>
						<p><code>Strength</code>定义该抛射体的血量，血量被将至0或以下抛射体引爆。</p>
						<p><code>Interceptable.DeleteOnIntercept</code>定义该抛射体在被摧毁时是否会直接被删除而不会引爆弹头。</p>
						<p><code>Interceptable.WeaponOverride</code>将会覆盖该弹头被拦截后引爆的武器，拦截单位上的相同设置拥有更高优先级。</p>
						<h5>拦截单位的定义：</h5>
						<p><code>Interceptor</code>定义该单位是否可以拦截抛射体，参数为布尔值。</p>
						<p><code>Interceptor.Weapon</code>定义该单位用哪个武器拦截抛射体，参数为0或1，0代表主武器，1代表副武器。根据拦截抛射体的高度，拦截武器的抛射体可能需要加入<code>AG=yes</code>和<code>AA=yes</code>。</p>
						<p><code>Interceptor.CanTargetHouses</code>定义该单位可以拦截哪些所属方的抛射体，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：不能拦截任何所属方的抛射体。</li>
							<li><code>owner/self</code>：只能拦截自己所发射的抛射体。</li>
							<li><code>allies/ally</code>：只能拦截盟友的抛射体。</li>
							<li><code>team</code>：可以拦截自己和盟友所发射的抛射体。</li>
							<li><code>enemies/enemy</code>：可以拦截敌人所发射的抛射体。</li>
							<li><code>all</code>：可以拦截所有所属方的抛射体。</li>
						</ul>
						<p><code>Interceptor.GuardRange</code>定义该单位对抛射体的警戒范围，同时可以用<code>Interceptor.RookieGuardRange</code>定义新兵等级的警戒范围、<code>Interceptor.VeteranGuardRange</code>定义老兵等级的警戒范围、<code>Interceptor.EliteGuardRange</code>定义精英等级的警戒范围，参数为浮点值。</p>
						<p><code>Interceptor.MinimumGuardRange</code>定义该单位对抛射体的最近警戒范围，同时可以用<code>Interceptor.RookieMinimumGuardRange</code>定义新兵登记的最近警戒范围、<code>Interceptor.VeteranMinimumGuardRange</code>定义老兵等级的最近警戒范围、<code>Interceptor.EliteMinimumGuardRange</code>定义精英等级的最近警戒范围，参数为浮点值。</p>
						<p><code>Interceptable.DeleteOnIntercept</code>定义该单位是否可以在摧毁抛射体时直接删除该抛射体而不会引爆弹头，这将覆盖抛射体上的设定，参数为布尔值。</p>
						<p><code>Interceptable.WeaponOverride</code>将会覆盖拦截抛射体所引爆的武器，参数为武器注册名。</p>
						<p><code>Interceptor.WeaponReplaceProjectile</code>定义该单位拦截抛射体后是否会将该抛射体的性质改变为<code>Interceptable.WeaponOverride</code>的武器中定义的抛射体的性质，如<code>Image</code>和<code>Speed</code>，但不支持修改Ares所提供的粒子系统<code>AttachedSystem</code>，参数为布尔值。</p>
						<p><code>Interceptor.WeaponCumulativeDamage</code>定义该单位拦截抛射体并将抛射体的引爆武器覆盖后，引爆武器是否叠加该单位用于拦截抛射体的武器的伤害，参数为布尔值。</p>
						<p><code>Interceptor.KeepIntact</code>定义该单位拦截抛射体后被拦截的抛射体是否还可以沿着原先的轨迹继续移动，<code>Interceptable.WeaponOverride</code>等覆盖武器的效果此时不受影响，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NewRocket]</p>
							<p>...</p>
							<p>Interceptable=true ;该抛射体是否可以被拦截</p>
							<p>Interceptable.DeleteOnIntercept=false ;该抛射体在被拦截后是否被直接删除</p>
							<p>Interceptable.WeaponOverride=DEMOBOMB ;该抛射体在被拦截后引爆的武器</p>
							<p>Strength=50</p>
							<p>Armor=special_2</p>
							<br>
							<p>[AVGR] ;Avenger</p>
							<p>...</p>
							<p>Primary=MachineGun</p>
							<p>Secondary=InterceptLaser</p>
							<p>Interceptor=true ;该单位是否是抛射体拦截单位</p>
							<p>Interceptor.Weapon=1 ;该单位用于拦截抛射体的武器</p>
							<p>Interceptor.CanTargetHouses=enemies ;该单位能拦截哪些阵营的抛射体</p>
							<p>Interceptor.GuardRange=3.0 ;该单位对抛射体的警戒范围</p>
							<p>Interceptor.VeteranGuardRange=3.5 ;老兵级别对抛射体的警戒范围</p>
							<p>Interceptor.EliteGuardRange=4.0 ;精英级别对抛射体的警戒范围</p>
							<p>Interceptor.MinimumGuardRange=0.0 ;该单位对抛射体的最近警戒范围</p>
							<p>Interceptor.VeteranMinimumGuardRange=0.0 ;老兵级别对抛射体的最近警戒范围</p>
							<p>Interceptor.EliteMinimumGuardRange=0.0 ;精英级别对抛射体的最近警戒范围</p>
							<p>Interceptor.DeleteOnIntercept=false ;是否直接删除抛射体</p>
							<p>Interceptor.WeaponOverride=SmallExplosion ;被拦截的抛射体引爆的武器</p>
							<p>Interceptor.WeaponReplaceProjectile=false ;是否改变抛射体性质</p>
							<p>Interceptor.WeaponCumulativeDamage=false ;是否叠加引爆伤害</p>
							<p>Interceptor.KeepIntact=false ;拦截后抛射体是否继续移动</p>
						</div>
					</div>
					<h3 id="projectile-trajectory" type="button" class="collapsible">弹道类抛射体</h3>
					<div class="col-content">
						<p>弹道类抛射体是一种全新的抛射体模式，其独立于四大抛射体（<code>Invisio</code>，<code>ROT</code>，<code>Arcing</code>，<code>Vertical</code>）之外，因此禁止和四大抛射体混用。目前弹道类抛射体只推出了两种弹道模式，即直线弹道和轰炸弹道。</p>
						<p><code>Trajectory</code>定义使用哪种弹道的抛射体，参数为弹道模式的预设名称，<code>Straight</code>为直线弹道（平射），<code>Bombard</code>为轰击弹道（曲射）。</p>
						<p><code>Trajectory.Speed</code>定义抛射体的速度，参数为浮点值。和原版在武器上用<code>Speed</code>控制速度不同，弹道类抛射体的速度需要再抛射体代码中定义。</p>
						<h5>直线弹道</h5>
						<p>如字面意义解释，直线弹道的弹体会以一条直线飞向目标。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.DetonationDistance</code>定义抛射体在离目标多少距离之外即被引爆，参数为浮点值，单位为单元格。填入0的情况下视为不设置最大距离。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.ApplyRangeModifiers</code>定义是否在武器射程增减（如附加效果）后对<code>Trajectory.Straight.DetonationDistance</code>的距离进行等值的增减，参数为布尔值。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.TargetSnapDistance</code>定义最远的预判距离，即在该距离之内，弹道会预判敌人的走向，参数为浮点值，单位为单元格。</p>
						<p><span id="version">DEV</span><code>Trajectory.Straight.PassThrough</code>定义抛射体是否会在击中目标后不引爆弹头，而是朝着<code>Trajectory.Straight.DetonationDistance</code>所指定的距离继续飞行，参数为布尔值。这个设置将改变抛射体的角度，如果在同一高度抛射体则会直线飞行。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MGBullet]</p>
							<p>Trajectory=Straight ;使用直线弹道</p>
							<p>Trajectory.Speed=150.0 ;弹道速度</p>
							<p>Trajectory.Straight.DetonationDistance=0.4 ;抛射体自爆的最大距离</p>
							<p>Trajectory.Straight.ApplyRangeModifiers=false ;引爆距离是否根据武器射程变化而变化</p>
							<p>Trajectory.Straight.TargetSnapDistance=0.5 ;预判距离</p>
							<p>Trajectory.Straight.PassThrough=false ;击中目标是否穿透然后继续飞行</p>
						</div>
						<p id="comment">笔者注：直线弹道配合激光拖尾可以轻松实现机枪曳光弹效果，但为了命中率考虑弹道速度应该加大。</p>
						<h5>轰击弹道</h5>
						<p>和直线弹道类似，但抛射体会瞄准目标上方，发射后作自由落体下坠然后在目标引爆。</p>
						<p><code>Trajectory.Bombard.Height</code>定义抛射体会瞄准距离目标多高的位置，填入浮点值，单位为高度值</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Howitzer]</p>
							<p>Trajectory=Bombard ;使用轰炸弹道</p>
							<p>Trajectory.Bombard.Height=5.0 ;轰炸弹道的曲线高度</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">溅射逻辑扩展</h4>
					<div class="col-content">
						<p>溅射逻辑现在可以在地面或者建筑上触发。</p>
						<p><code>Shrapnel.AffectsGround</code>定义该抛射体在地面引爆时是否会触发溅射，参数为布尔值。</p>
						<p><code>Shrapnel.AffectsBuildings</code>定义该抛射体在建筑引爆时是否会触发溅射，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LargeCometP]</p>
							<p>ShrapnelWeapon=CometFragment ;溅射武器，需要在[WeaponTypes]注册</p>
							<p>ShrapnelCount=5 ;溅射数量</p>
							<p>Shrapnel.AffectsGround=true ;打到地面是否溅射</p>
							<p>Shrapnel.AffectsBuildings=true ;打到建筑是否溅射</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">抛射体阻挡逻辑扩展<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">末端反射武器<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h2 id="new-logic-superweapons">超级武器相关</h2>
					<h3 type="button" class="collapsible">AI使用超级武器延时<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">单位变形<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">电磁脉冲设定<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">虚拟投送</h4>
					<div class="col-content">
						<p>虚拟投送的定义是在地图之外投送一个建筑物，这个建筑物是无法在游戏中看到的，也无法被攻击。虚拟投送的目的是，在视觉上不建造建筑的情况下可以实现一些建筑的效果。</p>
						<p>和Ares的超级武器定义比较不同，它不受超级武器<code>Type</code>和释放坐标的限制。可以理解为超级武器的一个衍生功能。</p>
						<p><code>LimboDelivery.Types</code>定义该超级武器所投放的建筑类型，参数为建筑的注册名的列表。</p>
						<p><code>LimboDelivery.IDs</code>定义该超级武器所投放的建筑编号，参数为整数，目的是让建筑可以被摧毁。</p>
						<p><code>LimboKill.Affects</code>定义该超级武器可以移除哪一所属方的虚拟投送的建筑，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：没有阵营的虚拟建筑会被移除。</li>
							<li><code>owner/self</code>：移除使用该超级武器的阵营的虚拟投放建筑。</li>
							<li><code>allies/ally</code>：移除使用该超级武器的阵营的盟友的虚拟投放建筑。</li>
							<li><code>team</code>：移除使用该超级武器的阵营和其盟友的虚拟投放建筑。</li>
							<li><code>enemies/enemy</code>：移除使用该超级武器的阵营的敌人的虚拟投放建筑。</li>
							<li><code>all</code>：移除所有阵营的虚拟投放建筑。</li>
						</ul>
						<p><code>LimboKill.IDs</code>定义该超级武器可以移除什么编号的建筑，参数为整数。</p>
						<p><code>LimboDelivery.RollChance</code>定义每一个虚拟投放建筑被投放的概率，参数为百分比的列表。</p>
						<p><code>LimboDelivery.RandomWeightsN</code>定义第N个建筑的每次的权重增加，N为从序列数，从0开始，代表在<code>LimboDelivery.Types</code>建筑列表中的第几个建筑，参数为正整数，等于0时则不增加权重。</p>
						<p>虚拟投送的建筑并不支持所有的建筑功能，但以下功能是经过了测试的：</p>
						<ul>
							<li>工业工厂</li>
							<li>矿石精炼器</li>
							<li>间谍卫星</li>
							<li>续存（Ares3.0功能）</li>
							<li>建造前提</li>
							<li>超级武器前提</li>
						</ul>
						<p>如果希望这个建筑可作用于<a href="ai-tutorial.html#ai-trigger" target="_blank">AI触发前提中的“己方拥有某建筑”和“敌方拥有某建筑”</a>，需要为该投放的建筑添加<code>LegalTarget=yes</code>标签。</p>
						<p id="alert">记住，虚拟投放的建筑不存在于场上，也就是说这些建筑不应该拥有需要交互的逻辑（比如工厂、维修厂、克隆中心），也最好带上<code>KeepAlive=no</code>标签或者用<code>LimboKill.IDs</code>主动删除，不然游戏会永远无法正常结束。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ForceShieldSpecial] ;力场护盾</p>
							<p>...</p>
							<p>LimboDelivery.Types=GASPYSAT,GAOREP,NAINDP ;释放后虚拟投放的建筑</p>
							<p>LimboDelivery.IDs=1,2,3 ;三个建筑的ID</p>
							<p>LimboDelivery.RollChance=33%,33%,33% ;三个建筑被投放的概率</p>
							<p>LimboDelivery.RandomWeights0=10 ;间谍卫星的权重增量</p>
							<p>LimboDelivery.RandomWeights2=10 ;矿石精炼器的权重增量</p>
							<p>LimboDelivery.RandomWeights3=10 ;工业工厂的权重增量</p>
							<br>
							<p>[LimboKillSpecial] ;删除虚拟建筑超级武器</p>
							<p>...</p>
							<p>SW.AutoFire=yes ;自动发射</p>
							<p>...</p>
							<p>LimboKill.IDs=1,2,3 ;删除建筑的ID</p>
							<p>LimboKill.Affects=self ;删除建筑的所属方</p>
						</div>
					</div>
					<h3 id="new-logic-technos">单位</h3>
					<h3 type="button" class="collapsible">自动删除乘员</h4>
					<div class="col-content">
						<p>可装载乘员的载具可以逐渐删除乘员，乘员越多耗时越长，并可以像部队回收站那样使用。可以搭配Ares的超时空监狱效果实现自动清除被困的敌人。</p>
						<p><code>PassengerDeletion.Rate</code>定义多长时间删除一个乘员，参数为整数，单位为帧。</p>
						<p><code>PassengerDeletion.Rate.SizeMultiply</code>定义占据大于1的格子的单位是否需要更多时间来删除，时长等于<code>PassengerDeletion.Rate</code>乘以单位的<code>Size</code>，参数为布尔值。</p>
						<p><code>PassengerDeletion.Soylent</code>删除乘员是否返还金钱，参数为布尔值。</p>
						<p><code>PassengerDeletion.SoylentFriendlies</code>删除自己或盟友的乘员是否返还金钱，参数为布尔值。</p>
						<p><code>PassengerDeletion.ReportSound</code>删除乘员时播放的声音，参数为声音注册名。</p>
						<p><code>PassengerDeletion.Anim</code>删除乘员时的动画。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MGRD] ;Mobile Grinder</p>
							<p>...</p>
							<p>Passengers=3 ;乘员数量</p>
							<p>PipScale=Passengers ;乘员格子</p>
							<p>PassengerDeletion.Rate=1 ;删除一个乘员的间隔</p>
							<p>PassengerDeletion.Rate.SizeMultiply=false ;删除多格子乘员是否用更多时间</p>
							<p>PassengerDeletion.Soylent=true ;删除乘员是否返还金钱。</p>
							<p>PassengerDeletion.SoylentFriendlies=true ;删除友军乘员是否返还金钱。</p>
							<p>PassengerDeletion.ReportSound=GrinderGrinding ;删除乘员声音</p>
							<p>PassengerDeletion.Anim=UCINIT ;删除乘员动画</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">乘员同步载具的所属方</h4>
					<div class="col-content">
						<p>乘员的所属方会随着载具所属方的更改而更改。</p>
						<p><code>Passengers.SyncOwner</code>定义该载具的乘员是否会同步所属方，参数为布尔值，如果是乘员可以开火的载具被心灵控制时，乘员将重新选择目标。注意，通过<code>Abductor=true</code>获取的乘员无法使用该逻辑。</p>
						<p><code>Passengers.SyncOwner.RevertOnExit</code>定义该载具的乘员是否在卸载后将所属方变成上车前的所属方，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[FV]</p>
							<p>Passengers.SyncOwner=true ;是否同步乘员所属</p>
							<p>Passengers.SyncOwner.RevertOnExit=false ;乘员卸载后是否回归所属</p>
						</div>
						<p id="comment">笔者注：多功能步兵车在改变所属后乘员即便没有改变所属其炮塔和武器也不会改变，只有在卸载乘员之后乘员是原有所属方。另外，如果是通过脚本动作改变的所属方，即便会同步乘员，还是会有一个乘员不会改变所属。</p>
					</div>
					<h3 type="button" class="collapsible">自动开火武器</h4>
					<div class="col-content">
						<p>单位可以在不需要扫描目标的情况下自动开火，这样的开火模式要么选择单位所在的地格作为目标，要么选择单位自己作为目标。</p>
						<p><code>AutoFire</code>定义单位是否会自动开火，参数为布尔值，默认为对自己开火。</p>
						<p><code>AutoFire.TargetSelf</code>定义单位是否自动对自己开火，参数为布尔值，如果为false，单位则会对所在的地格自动开火。</p>
						<p>代码示例（改代码来自万世之战中的蒸汽机车头）：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[LOCOMOTIVE]</p>
							<p>AutoFire=true ;单位是否自动开火</p>
							<p>AutoFire.TargetSelf=false ;单位是否对自身自动开火</p>
							<p>Primary=TrainSmoke ;自动开火的武器</p>
						</div>
						<p id="comment">这个功能最大的问题在于单位开火时，可以看到一条红色的攻击示意线。然而，这个功能最大的优势是可以附带FLH坐标，因可以看做是一个可以定义FLH坐标的动画生成器。万世之战的蒸汽机车就是用这个功能模拟冒烟效果。</p>
					</div>		
					<h3 type="button" class="collapsible">建造上限组<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">自定义乘员开火</h4>
					<div class="col-content">
						<p>现在你可以微观定义乘员开火载具的属性，以覆盖宏观定义。</p>
						<p><code>OpenTopped.RangeBonus</code>定义乘员在载具内开火所获得额外的射程，参数为整数。</p>
						<p><code>OpenTopped.DamageMultiplier</code>定义乘员在载具内开火所获得的火力加成，参数为浮点值，伤害将乘以这个值。</p>
						<p><code>OpenTopped.WarpDistance</code>定义使用超时空武器的乘员在（从载具到目标）多少距离外武器停止攻击，参数为整数。</p>
						<p><code>OpenTopped.IgnoreRangefinding</code>定义载具是否会根据最近射程的乘员来接近目标，参数为布尔值。</p>
						<p><code>OpenTopped.AllowFiringIfDeactivated</code>定义载具在瘫痪（停电、EMP等）时乘员是否可以开火。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[BFRT] ;Battle Fortress</p>
							<p>...</p>
							<p>OpenTopped=yes</p>
							<p>OpenTopped.RangeBonus=1 ;乘员获得额外的射程</p>
							<p>OpenTopped.DamageMultiplier=1.1 ;乘员获得额外的火力</p>
							<p>OpenTopped.WarpDistance=7 ;超时空的最大距离</p>
							<p>OpenTopped.IgnoreRangefinding=true ;是否移动到所有乘员都能攻击到目标的距离</p>
							<p>OpenTopped.AllowFiringIfDeactivated=true ;是否在瘫痪后乘员依然可以开火</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">关闭副武器自动推算</h4>
					<div class="col-content">
						<p>在原版中，如果主武器不能攻击的情况下，单位会选择副武器攻击目标，而现在可以通过以下代码来关闭副武器自动推算。</p>
						<p><code>NoSecondaryWeaponFallback</code>定义是否关闭副武器自动推算，参数为布尔值。这个设置不能关闭手动设置的推算。</p>
						<p>所谓手动设置的推算，情况如下：</p>
						<ul>
							<li><code>OpenTransportWeapon=1</code>的单位进入可对外开火的载具所使用的武器，例如原版的重装步兵进入战斗要塞。</li>
							<li>带有Ares的<code>NoAmmoWeapon=1</code>的单位所使用的武器，例如万世之战中的战斗要塞。</li>
							<li><code>DeployFireWeapon=1</code>的单位部署后所使用的武器，例如原版的武装直升机。</li>
							<li>带有<code>DrainWeapon=true</code>的单位在吸建筑时的武器，例如原版的镭射飞碟。</li>
							<li>主武器带有<code>IsLocomotor=true</code>的弹头在攻击建筑时的武器，例如原版的磁电坦克。</li>
							<li>带有<code>ElectricAssault=true</code>的弹头在为线圈充能是的武器，例如原版的磁暴步兵。</li>
							<li>带有<code>Overpowerable=true</code>的建筑在充能时攻击所使用的武器，例如原版的磁暴线圈。</li>
							<li>使用多武器机制的单位所使用的武器，例如原版的盖特坦克或者多功能步兵车。</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[APOC] ;Apocalypse Tank</p>
							<p>Primary=120mmx</p>
							<p>Secondary=MammothTusk</p>
							<p>NoSecondaryWeaponFallback=true ;是否关闭副武器自动推算</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">间谍伪装逻辑扩展<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">自定义Burst开火坐标</h4>
					<div class="col-content">
						<p>在原版中，如果武器带有<code>Burst=2</code>，并且在art中，单位开火坐标的第二个值不等于0，那么该武器就可以实现左右开弓发射这个武器的Burst。</p>
						<p>现在Phobos将这个功能做了更多拓展，可以定义每一个<code>Burst</code>的开火坐标。</p>
						<p><code>(Elite)(Prone/Deployed)PrimaryFire|SecondaryFire|WeaponX|FLH.BurstN</code>定义某个级别在某个状态下用某种武器的第N个Burst的坐标，参数为FLH，代码的组合方式如下：</p>
						<p id="highlight">A + B + C + .Burst + N</p>
						<p>其中，A可以带入以下代码：</p>
						<ul>
							<li><code>Elite</code>：代表精英级别时所用武器</li>
						</ul>
						<p>B可以带入以下代码：</p>
						<ul>
							<li><code>Prone</code>：代表步兵匍匐时</li>
							<li><code>Deployed</code>：代表步兵部署时</li>
						</ul>
						<p>C可以带入以下代码</p>
						<ul>
							<li><code>PrimaryFire</code>：代表主武器</li>
							<li><code>SecondaryFire</code>：代表副武器</li>
							<li><code>WeaponX</code>：代表多武器单位的第X个武器</li>
						</ul>
						<p>N代表第N个Burst，武器中有多少Burst就写多少个坐标。</p>
						<p>代码示例：</p>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[FV]</p>
							<p>EliteWeapon5.Burst1=170,50,90 ;多功能步兵车的第五个武器的第一个Burst的开火坐标</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">初始血量和克隆血量</h4>
					<div class="col-content">
						<p>单位现在可以自定义初始血量，即造出来后可以不是满血。当然，就算指定的初始血量高于单位的<code>Strength</code>，单位也不会初始拥有更多的血量。</p>
						<p><code>InitialStrength</code>定义单位在出厂后的血量，参数为整数。</p>
						<p><code>InitialStrength.Cloning</code>定义该带有<code>Cloning=yes</code>克隆建筑出厂的单位的初始血量，参数为小数、百分比或用英文逗号<code>,</code>隔开的范围值。如果是范围值，那么出厂单位将随机在范围内取值作为初始血量。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[INIT]</p>
							<p>Strength=100</p>
							<p>InitialStrength=91 ;初始血量</p>
							<br>
							<p>[NACLON]</p>
							<p>Cloning=yes</p>
							<p>InitialStrength.Cloning=50% ;克隆单位的初始血量</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">单位自动消失</h4>
					<div class="col-content">
						<p>单位可以在某些条件下自动消失，并且可以以不同的方式消失。</p>
						<p><code>AutoDeath.OnAmmoDepletion</code>定义单位是否在弹药耗尽后消失，参数为布尔值。</p>
						<p><code>AutoDeath.AfterDelay</code>定义单位是否在一定的时间后消失，参数为整数，单位为帧。</p>
						<p><code>AutoDeath.Behavior</code>定义单位以什么方式消失，参数为预设值，解释如下：</p>
						<ul>
							<li><code>kill</code>：被摧毁，一切摧毁相关的效果都会生效，比如爆炸动画和碎片。</li>
							<li><code>vanish</code>：直接删除，不会产生爆炸动画和碎片。</li>
							<li><code>sell</code>：被变卖，可获得金钱，建筑将会播放建造动画，不会产生爆炸动画和碎片。</li>
						</ul>
						<p>该逻辑支持虚拟投放超级武器，因此如果你想删除被虚拟投放的建筑，也可以在建筑上直接添加自动消失相关代码。</p>
						<p>代码示例（该代码来自万世之战的灰熊坦克残骸）：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GTNKWK] ;Grizzly Tank Wreckage</p>
							<p>...</p>
							<p>AutoDeath.OnAmmoDepletion=false ;单位是否在弹药耗尽时消失</p>
							<p>AutoDeath.AfterDelay=2000 ;单位在指定时间内消失</p>
							<p>AutoDeath.Behavior=kill</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">心灵控制扩展</h4>
					<div class="col-content">
						<p>Phobos为心灵控制提供了新的标签，以实现以下功能：</p>
						<ol>
							<li>心灵控制现在可以规定有效距离。</li>
							<li>如果单位有多个心灵控制槽，在控制了最大数目的单位时，再控制单位时可以释放第一个被控制的单位。</li>
							<li>可微观定义心灵控制的动画。</li>
						</ol>
						<p><code>MindControlRangeLimit</code>定义心灵控制的有效距离，参数为浮点值，填入大于0的数生效。</p>
						<p><code>MultiMindControl.ReleaseVictim</code>定义是否在心灵控制槽满了以后控制单位时，释放第一个被控制的单位。</p>
						<p><code>MindControl.Anim</code>定义被该弹头心灵控制的单位的动画，参数为动画注册名，将覆盖全局的<code>ControlledAnimationType</code>。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[YURI] ;Yuri</p>
							<p>...</p>
							<p>MindControlRangeLimit=10 ;心灵控制有效范围</p>
							<p>MultiMindControl.ReleaseVictim=true ;是否释放第一个心灵控制的单位</p>
							<br>
							<p>[Controller]	;Warhead</p>
							<p>...</p>
							<p>MindControl.Anim=MINDANIM ;心灵控制的动画</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">禁止手动移动</h4>
					<div class="col-content">
						<p>现在可以让一个单位完全无法手动移动。</p>
						<p><code>NoManualMove</code>定义该单位是否不可以手动移动，参数为布尔值。</p>
						<p>代码示例（该代码来自万世之战中灰熊坦克残骸）：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GTNKWK] ;Grizzly Tank Wreckage</p>
							<p>NoManualMove=true ;是否允许手动移动</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">强制特定武器对付特定目标</h4>
					<div class="col-content">
						<p>该功能将覆盖部分原版水下目标选取的逻辑。</p>
						<p><code>ForceWeapon.Naval.Decloaked</code>定义海军单位使用什么武器对付已经显形的水下单位，参数为整数，-1为关闭该功能，0为主武器，1为副武器。</p>
					</div>
					<h3 type="button" class="collapsible">全方位武器强制面向目标<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">子机升级</h4>
					<div class="col-content">
						<p>单位发射的子机现在可以设置为同步单位等级。</p>
						<p><code>Promote.IncludeSpawns</code>定义该单位的子机是否会同步该单位的等级，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CARRIER]</p>
							<p>Trainable=yes</p>
							<p>Promote.IncludeSpawns=true ;子机是否随着航母升级而升级</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">复仇武器<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">航母子机扩展</h4>
					<div class="col-content">
						<p>航母子机（飞行器类子机）现在可以增加最远航程、自定义子机补充速度以及子机起飞后直接执行攻击指令。</p>
						<p><code>Spawner.LimitRange</code>定义子机的航程是否被限制，参数为布尔值，航程由该单位子机武器的<code>Range</code>所决定。限制了航程的子机在单位远离目标时会放弃攻击指令直接返航。</p>
						<p><code>Spawner.ExtraLimitRange</code>定义子机可以在原有航程下增加多少格的航程，参数为整数，单位为单元格。</p>
						<p><code>Spawner.DelayFrames</code>定义子机的补充速度，参数为整数，单位为帧。这将直接覆盖原版写死的子机补充速度，即导弹类子机为9帧，其他类型子机为20帧。</p>
						<p><code>Spawner.AttackImmediately</code>定义航母在释放子机后是否立刻进入攻击模式而不用等待其他子机释放，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CARRIER]</p>
							<p>Spawner.LimitRange=true ;航母子机是否限制航程</p>
							<p>Spawner.ExtraLimitRange=2 ;额外增加两格航程</p>
							<p>Spawner.DelayFrames=25 ;子机补充速度</p>
							<p>Spawner.AttackImmediately=true ;子机是否直接执行攻击指令</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">超时空传送武器</h4>
					<div class="col-content">
						<p>现在可以让武器在单位传送后开火，会在传送动画（<code>WarpIn</code>和<code>WarpOut</code>）播放的同时开火。</p>
						<p><code>WarpInWeapon</code>定义传送时开火的武器，参数值为武器注册名。</p>
						<p><code>WarpInMinRangeWeapon</code>定义在传送距离小于<code>ChronoRangeMinimum</code>时代替<code>WarpInWeapon</code>。它会无视<code>ChronoTrigger</code>设置与否而触发。如果未设置，默认为<code>WarpInWeapon</code>。</p>
						<p><code>WarpInWeapon.UseDistanceAsDamage</code>定义是否用超时空传送的单元格距离作为伤害，</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CLEG]</p>
							<p>WarpInWeapon=NeutronRifle ;超时空传送后发射的武器</p>
							<p>WarpInMinRangeWeapon=NeutronRifle ;超时空传送到最小距离后发射的武器</p>
							<p>WarpInWeapon.UseDistanceAsDamage=true ;是否用移动距离的单元格取代伤害</p>
							<p>WarpOutWeapon=NeutronRifle ;超时空传送前在原地发射的武器</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">单位自定义染色<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">自定义单位变卖声音</h4>
					<div class="col-content">
						<p>当单位被变卖后，将会播放一个变卖音效和相应的EVA语音，现在可以微观定义这些声音。</p>
						<p><code>EVA.Sold</code>定义该单位被变卖的EVA语音，参数为EVA语音注册名，建筑默认是<code>EVA_StructureSold</code>，载具默认是<code>EVA_UnitSold</code>。</p>
						<p><code>SellSound</code>定义该单位被变卖的音效，参数为音效注册名，默认值为<code>[AudioVisual]</code>中的<code>SellSound</code>所定义的音效。注意，在原版中，载具的变卖音效是全局音效，Phobos将其修复为局部音效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[HTNK]</p>
							<p>EVA.Sold=EVA_TankSold</p>
							<p>SellSound=GrinderGrinding</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">单位出厂语音<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">单位升级动画<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 type="button" class="collapsible">改变阵营时变形<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>敬请期待……</p>
					</div>
					<h3 id="new-logic-terrains">地形</h3>
					<h3 type="button" class="collapsible">摧毁动画和音效</h4>
					<div class="col-content">
						<p>现在可以设定地形对象的摧毁动画和音效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TREE01]</p>
							<p>DestroyAnim=TREEFALL ;地形对象被摧毁时的动画</p>
							<p>DestroySound=TreeFall ;地形对象被摧毁时的音效</p>
						</div>
					</div>
					<h3 id="new-logic-warheads">弹头</h3>
					<h3 type="button" class="collapsible">心控解除</h4>
					<div class="col-content">
						<p>心控解除弹头可以解除单位的心灵控制，但对永久心灵控制无效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MindControlReliever]</p>
							<p>...</p>
							<p>RemoveMindControl=true ;是否可以解除心灵控制</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">暴击</h4>
					<div class="col-content">
						<p>现在弹头可以实现暴击机制，即在一定的概率下使用不同的伤害和弹头进行攻击。</p>
						<p><code>Crit.Chance</code>定义该弹头的暴击概率，参数为0.0-1.0的浮点值。</p>
						<p><code>Crit.ApplyChancePerTarget</code>定义暴击的概率是否随目标刷新，参数为布尔值。</p>
						<p><code>Crit.ExtraDamage</code>定义该弹头在暴击时所打出的额外伤害，参数为整数。</p>
						<p><code>Crit.Warhead</code>定义该弹头在暴击时所使用的弹头，参数为弹头的注册名。</p>
						<p><code>Crit.Affects</code>定义该弹头对哪些对象可以暴击，参数为以下预设值：</p>
						<ul>
							<li><code>none</code>：无论如何都不会暴击。</li>
							<li><code>land</code>：对地面单位攻击可以暴击。</li>
							<li><code>water</code>：对水面单位攻击可以暴击。</li>
							<li><code>empty</code>：对空地攻击可以暴击。</li>
							<li><code>infantry</code>：对步兵攻击可以暴击。</li>
							<li><code>units</code>：对载具攻击可以暴击。</li>
							<li><code>buildings</code>：对建筑攻击可以暴击。</li>
							<li><code>all</code>：对所有对象攻击都可以暴击。</li>
						</ul>
						<p><code>Crit.AffectsBelowPercent</code>定义该弹头对血量在该百分比以下的单位会暴击，参数为0.0-1.0的浮点值。</p>
						<p><code>Crit.AnimList</code>定义该弹头在暴击时所使用的动画以取代<code>AnimList</code>，参数为动画注册名的列表。</p>
						<p><code>Crit.AnimList.PickRandom=</code>定义该弹头是否从暴击动画列表中随机播放一个动画，参数为布尔值。</p>
						<p><code>Crit.AnimOnAffectedTargets</code>定义该弹头暴击的动画是否在每一个造成暴击的单位上播放，参数为布尔值，</p>
						<p><code>Crit.SuppressWhenIntercepted</code>定义弹头的抛射体被拦截时是否去掉暴击效果，参数为布尔值。</p>
						<p><code>ImmuneToCrit</code>定义该单位是否免疫暴击效果，即是否不会受到暴击，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[120mm]</p>
							<p>...</p>
							<p>Crit.Chance=0.5 ;武器的暴击率</p>
							<p>Crit.ApplyChancePerTarget=false ;暴击率是否随不同目标刷新</p>
							<p>Crit.ExtraDamage=25 ;暴击伤害</p>
							<p>Crit.Warhead=RHINAPE ;暴击时所使用的弹头</p>
							<p>Crit.Affects=units ;攻击什么类型的目标会触发暴击</p>
							<p>Crit.AffectBelowPercent=1.0 ;目标血量在多少以下会触发暴击</p>
							<p>Crit.AnimList=VTEXPLOD ;暴击时的弹头动画列表</p>
							<P>Crit.AnimList.PickRandom=false ;暴击时是否随机播放弹头动画</P>
							<p>Crit.AnimOnAffectedTargets=false ;是否在每一个造成暴击的单位上播放弹头动画</p>
							<p>Crit.SuppressWhenIntercepted=false ;暴击效果是否在被拦截时触发</p>
							<br>
							<p>[APOC] ;Apocalypse Tank</p>
							<p>...</p>
							<p>ImmuneToCrit=yes ;是否免疫暴击</p>
						</div>
						<p id="alert">如果你将某个弹头的<code>Crit.Warhead</code>设置为相同的弹头，那将可能会形成一个无限暴击循环，从而卡死游戏。</p>
					</div>
					<h3 type="button" class="collapsible">自定义水花动画</h4>
					<div class="col-content">
						<p>在原版中，带有<code>Conventional</code>标签的弹头在打在水面上会溅起水花，水花的动画只能在全局代码<code>[CombatDamage]</code>中的<code>SplashList</code>中随机选中。Phobos现在提供了可以在每个弹头上微观定义水花的方式。</p>
						<p><code>SplashList</code>定义该弹头打在水上的水花，参数为动画注册名的列表，默认为全局设置的动画。</p>
						<p><code>SplashList.PickRandom</code>定义是否随机选取水花动画，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[120mmx]</p>
							<p>...</p>
							<p>Conventional=yes ;弹头在水面爆炸是否用水花动画替代原有弹头动画</p>
							<p>SplashList=VTEXPLOD ;水花动画列表</p>
							<p>SplashList.PickRandom=false ;水花动画是否随机播放</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">全局引爆</h4>
					<div class="col-content">
						<p>顾名思义，弹头可以在全局内对每一个目标引爆。</p>
						<p><code>DetonateOnAllMapObjects</code>定义该弹头是否全局引爆，参数为布尔值。这个功能只适用于抛射体搭载的弹头，如果是动画的弹头或者Ares中的弹头超级武器，则无法生效，而弹头附带的<code>Crit.Warhead</code>或者动画中的<code>Weapon</code>则会生效。同时，抛射体所携带的空爆武器或者溅射武器也会对全局目标生效，而Ares的<code>PreImpactAnim</code>动画也会在引爆前播放。</p>
						<p><code>DetonateOnAllMapObjects.AffectTargets</code>用于过滤全局引爆适用于哪些目标，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：不过滤全局引爆范围</li>
							<li><code>aircraft</code>：只对飞行器生效</li>
							<li><code>buildings</code>：只对建筑生效</li>
							<li><code>infantry</code>：只对步兵生效</li>
							<li><code>units</code>：只对载具生效</li>
							<li><code>all</code>：对所有对象一律生效</li>
						</ul>
						<p><code>DetonateOnAllMapObjects.AffectHouses</code>用于过滤全局引爆适用于哪些所属方，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：对任何所属方都不生效</li>
							<li><code>owner/self</code>：只对自己生效</li>
							<li><code>allies/ally</code>：只对盟友生效</li>
							<li><code>team</code>：只对自己和盟友生效</li>
							<li><code>enemies/enemy</code>：只对敌人生效</li>
							<li><code>all</code>：对所有所属方一律生效</li>
						</ul>
						<p><code>DetonateOnAllMapObjects.AffectTypes</code>定义该全局弹头只对哪些特定的单位生效，参数为单位注册名列表。注意，上述的目标过滤和所属方过滤被设置后，将优先读取，因此这个功能将被覆盖。</p>
						<p><code>DetonateOnAllMapObjects.IgnoreTypes</code>定义哪些单位无视该全局弹头，参数为单位注册名列表。</p>
						<p><code>DetonateOnAllMapObjects.RequireVerses</code>定义该全局弹头是否只作用于<code>Verses</code>非0的单位，即如果该弹头对付某一装甲的<code>Verses</code>值为0，那么该装甲的单位不会受到该弹头的攻击。这个功能的优先级低于上述所有功能。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[NUKE]</p>
							<p>...</p>
							<p>DetonateOnAllMapObjects=true ;是否全局引爆弹头</p>
							<p>DetonateOnAllMapObjects.AffectTargets=none ;全局引爆弹头可击中的目标类型</p>
							<p>DetonateOnAllMapObjects.AffectHouses=none ;全局引爆弹头可击中的所属方</p>
							<p>DetonateOnAllMapObjects.AffectTypes= ;全局引爆弹头可击中的特定目标</p>
							<p>DetonateOnAllMapObjects.IgnoreTypes=  ;全局引爆弹头不可击中的特定目标</p>
							<p>DetonateOnAllMapObjects.RequireVerses=false ;全局引爆弹头是否需要可用的Verses值</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">爆金币</h4>
					<div class="col-content">
						<p>该弹头可以在引爆后增加或减少所属方的资金。</p>
						<p><code>TransactMoney</code>定义该弹头在引爆后会给弹头发射单位的所属方增加或减少多少资金，参数为整数，正数为增加，负数为减少。</p>
						<p><code>TransactMoney.Display</code>定义该弹头在引爆后增加或减少所属方资金时是否显示资金的值，参数为布尔值。增加为绿色的数字，减少为红色的数字。</p>
						<p><code>TransactMoney.Display.AtFirer</code>定义在显示资金增减值时，该值是否在弹头的发射单位上出现，填入布尔值。如果该弹头没有发射者信息，则会在弹头引爆的地方出现。</p>
						<p><code>TransactMoney.Display.Houses</code>定义哪些所属方可以看到该弹头引爆时资金的增减值，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：所有所属方均无法看见该值</li>
							<li><code>owner/self</code>：只有弹头发射单位的所属方可以看见该值</li>
							<li><code>allies/ally</code>：只有弹头发射单位的盟友可以看见该值</li>
							<li><code>team</code>：弹头发射单位的所属方和其盟友都可以看见该值</li>
							<li><code>enemies/enemy</code>：只有弹头发射单位的敌人可以看见该值</li>
							<li><code>all</code>：所有所属方均可以看见该值</li>
						</ul>
						<p><code>TransactMoney.Display.Offset</code>定义显示资金增减的值出现的位置调整，参数为用逗号隔开的X,Y值，单位为像素，起点为发射单位或引爆地格的中心点。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GimmeSomeMoney]</p>
							<p>...</p>
							<p>TransactMoney=1000</p>
							<p>TransactMoney.Display=true</p>
							<p>TransactMoney.Display.AtFirer=true</p>
							<p>TransactMoney.Display.Houses=self</p>
							<p>TransactMoney.Display.Offset=0,0</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">超级武器引信</h4>
					<div class="col-content">
						<p>现在弹头可以作为超级武器的引信使用，即在弹头引爆的区域释放超级武器。</p>
						<p><code>LaunchSW</code>定义该弹头在引爆时所发射的超级武器，参数为超级武器的注册名的列表。</p>
						<p><code>LaunchSW.RealLaunch</code>定义该弹头引爆时发射的超级武器是否需要满足条件，同时需要有足够的资金（Ares的超级武器<code>Money.Amout</code>功能），参数为布尔值。</p>
						<p><code>LaunchSW.IgnoreInhibitors</code>定义该弹头在引爆时发射的超级武器是否无视抑制器，参数为布尔值。</p>
						<p><code>LaunchSW.IgnoreDesignators</code>定义该弹头在引爆时发射的超级武器是否无视指向器，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[ParticleCannonPointer]</p>
							<p>...</p>
							<p>LaunchSW=ParticleCannonSpecial ;引爆弹头时发射的超级武器</p>
							<p>LaunchSW.RealLaunch=true ;该超级武器是否需要满足条件</p>
							<p>LaunchSW.IgnoreInhibitors=false ;该超级武器是否无视抑制器</p>
							<p>LaunchSW.IgnoreDesignators=true ;该超级武器是否无视指向器</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">移除伪装</h4>
					<div class="col-content">
						<p>被该弹头击中的单位会移除伪装效果，对付拥有<code>PermaDisguise</code>的单位时会相当有效。</p>
						<p><code>RemoveDisguise</code>定义该弹头是否可以移除伪装效果，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TakeOffYourClothes]</p>
							<p>...</p>
							<p>RemoveDisguise=true ;是否可以移除伪装</p>
						</div>
						<p id="comment">笔者注：逻辑上来讲，使用这个弹头的单位要么可以识破伪装，要么是范围伤害，否则很难发挥出效果。</p>
					</div>
					<h3 type="button" class="collapsible">开图</h4>
					<div class="col-content">
						<p>该弹头引爆时将会为弹头发射单位的所属方显示全地图。</p>
						<p><code>SpySat</code>定义该弹头在引爆时是否会为发射单位的所属方显示全地图，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[OpenTheMap]</p>
							<p>...</p>
							<p>SpySat=true ;是否显示全地图</p>
						</div>
						<p id="comment">考虑到平衡性，这个功能实际上比较鸡肋，虽说可以用来模拟NP的开图超级武器，但还是比较鸡肋……</p>
					</div>
					<h3 type="button" class="collapsible">黑幕</h4>
					<div class="col-content">
						<p>该弹头引爆时会将发射单位的敌人的地图覆盖黑幕。</p>
						<p><code>BigGap</code>定义该弹头引爆时是否将敌人的视野覆盖满黑幕，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[DeepDarkFantasy]</p>
							<p>...</p>
							<p>BigGap=true ;是否给敌人的视野覆盖黑幕</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">触发指定的非人死亡动画</h4>
					<div class="col-content">
						<p>该弹头在杀死带有<code>NotHuman=yes</code>的步兵时可以指定该步兵的死亡动画。</p>
						<p><code>NotHuman.DeathSequence</code>定义该弹头摧毁非人步兵时是否播放指定的死亡动画，参数为1-5的整数，代表<code>Die1</code>到<code>Die5</code>的动画序列。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[Melt]</p>
							<p>...</p>
							<p>NotHuman.DeathSequence=5 ;指定哪一个死亡动画序列</p>
						</div>
					</div>
					<h3 id="new-logic-weapons">武器</h3>
					<h3 type="button" class="collapsible">自定义范围攻击目标</h4>
					<div class="col-content">
						<p>在原版中，带有<code>AreaFire</code>的武器在开火时会选择自己脚下的地面作为目标进行攻击，而在Phobos中，这种攻击模式可以自定义攻击目标。</p>
						<p><code>AreaFire.Target</code>定义该单位范围攻击的目标，参数为下列预设值：</p>
						<ul>
							<li><code>base</code>：攻击单位下方的地面单元格</li>
							<li><code>self</code>：攻击单位自身，遵从武器的目标筛选机制</li>
							<li><code>random</code>：攻击range范围内随机单元格，无视武器的目标筛选机制</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[PsiWave]</p>
							<p>...</p>
							<p>Range=3</p>
							<p>AreaFire=yes ;是否为范围攻击</p>
							<p>AreaFire.Target=random ;范围攻击的目标</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">武器爆发开火延迟</h4>
					<div class="col-content">
						<p>在原版中，如果武器拥有多个爆发开火（<code>Burst</code>），并设置了<code>BurstDelayX</code>（X为0-3的值），则可以定义武器的Burst开火延迟。然而，此方法只能定义前4个Burst的开火延迟，也就是说武器的<code>Burst</code>在4以上就不能定义开火延迟了。</p>
						<p>在Phobos中，则可以用<code>Burst.Delays</code>来接管武器爆发开火延迟设置，参数为整数，代表武器爆发开火延迟的帧数，延迟会均匀分配。当设置为0时，则没有延迟。如果设置为-1，则会退回原版的爆发开火延迟逻辑。</p>
						<p><code>Burst.FireWithinSequence</code>是用于步兵的爆发开火延迟逻辑。第一枪总是在步兵开火动画序列（<code>FireUp </code>等）中的射击帧控制确定的序列帧上发射。后续射击以<code>Burst.Delays</code>确定的间隔进行（最小延迟为1帧）或在未定义的情况下使用3到5 帧之间的随机延迟。请注意，如果下一枪将在超出射击序列长度的帧上发射，则爆发射击计数将重置，武器进入<code>ROF</code>的计时器。如果在至少一枪之后在序列中途停止射击，连发射击计数器不会立即重置，但每次连发射击的帧不会受此影响。换句话说，在未重新装弹武器的情况下恢复射击将重新启动射击序列，但在到达下一次连发射击应发射的帧之前不会进行射击。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MIM21] ;IFV Missile</p>
							<p>...</p>
							<p>Burst=6 ;武器爆发开火发射次数</p>
							<p>Burst.Delays=20 ;武器爆发开火的延迟</p>
							<p>Burst.FireWithinSequence=false ;是否在步兵的开火序列后重置爆发开火计数器</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">反馈武器</h4>
					<div class="col-content">
						<p>反馈武器的定义是在发射某种武器时，对同时自己发射的武器。</p>
						<p><code>FeedbackWeapon</code>定义该武器所附带的反馈武器，参数为武器注册名，需要在<code>[WeaponTypes]</code>中注册。如果反馈武器被设置为可从载具内开火（<code>FireInTransport</code>），那么在载具内开火时反馈武器则可以对载具自身发射，同时，反馈武器会无视载具内开火的伤害加成（<code>OpenToppedDamageMultiplier</code>）。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[MagnetDrainer] ;Drains armor</p>
							<p>...</p>
							<p>FeedbackWeapon=GainArmor ;反馈武器</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">自定义飞行器扫射</h4>
					<div class="col-content">
						<p>飞机的开火逻辑和其他单位完全不同，在武器抛射体的<code>ROT</code>小于2时，其开火时会对目标进行5连发的扫射，而现在可以自定义一些扫射的参数。</p>
						<p><code>Strafing.Shots</code>定义该武器在单次扫射时射击次数，参数为1到5的整数，任何定义域[1,5]之外的数字将会被视为1或者5，默认为5。单位的<code>Ammo</code>会在扫射结束后扣除。</p>
						<p><code>Strafing.SimulateBurst</code>定义该武器扫射时是否模拟<code>Burst</code>效果以定义多个开火坐标，参数为布尔值，默认为false。只有在该武器的<code>Burst</code>为1或者未定义的情况下生效。</p>
					</div>
					<h3 type="button" class="collapsible">目标选择筛选</h4>
					<div class="col-content">
						<p>现在可以定义武器可以对何种目标进行攻击。</p>
						<p><code>CanTarget</code>定义该武器可以攻击哪些种类的目标，参数为预设值的列表，预设值解释如下：</p>
						<ul>
							<li><code>none</code>：无，即不能攻击任何目标</li>
							<li><code>land</code>：地面目标</li>
							<li><code>water</code>：水中目标</li>
							<li><code>empty</code>：空目标，即地板</li>
							<li><code>infantry</code>：步兵目标</li>
							<li><code>units</code>：载具目标和飞行器目标</li>
							<li><code>buildings</code>：建筑目标</li>
							<li><code>all</code>：所有目标</li>
						</ul>
						<p>特别提示，如果你设定了可攻击的类型，记得把<code>empty</code>也放进列表，否则单位无法攻击空地板。</p>
						<p><code>CanTargetHouses</code>定义该武器可以将哪些阵营作为目标，参数为预设值的列表，预设值解释如下：</p>
						<ul>
							<li><code>none</code>：无，即不能攻击任何阵营。</li>
							<li><code>owner</code>或者<code>self</code>：仅能攻击单位所在阵营</li>
							<li><code>allies</code>或者<code>ally</code>：仅能攻击盟友</li>
							<li><code>team</code>：可以攻击自己或者盟友</li>
							<li><code>enemies</code>或者<code>enemy</code>：仅能攻击敌人</li>
							<li><code>all</code>：所有阵营均可攻击</li>
						</ul>
					</div>
					<h2 id="fixed-logic">修复或改善的逻辑</h2>
					<h3>BUG修复和杂项</h3>
					<p>此页面列出了火卫一中所有修复或增强的不那么重要的逻辑。</p>
					<div class="index-navigator">
						<a href="#enhanced-logic-aircraft">飞行器</a>
						<a href="#enhanced-logic-animations">动画</a>
						<a href="#enhanced-logic-buildings">建筑</a>
						<a href="#enhanced-logic-particle-sys">粒子系统</a>
						<a href="#enhanced-logic-particle">粒子</a>
						<a href="#enhanced-logic-projectile">抛射体</a>
						<a href="#enhanced-logic-technos">单位</a>
						<a href="#enhanced-logic-terrains">地形对象</a>
						<a href="#enhanced-logic-tiberium">矿石</a>
						<a href="#enhanced-logic-vehicles">载具</a>
						<a href="#enhanced-logic-vein">藤蔓和废料</a>
						<a href="#enhanced-logic-debris">VXL碎片</a>
						<a href="#enhanced-logic-warheads">弹头</a>
						<a href="#enhanced-logic-weapons">武器</a>
						<a href="#enhanced-logic-misc">杂项</a>
					</div>
					<h3 type="button" class="collapsible">点击展开</h4>
					<div class="col-content">
						<ul>
							<li>修复了GameModeOptions无法被正确保存，比如<code>BuildOffAlly</code>在加载游戏后会被关闭。</li>
							<li>修复了利用建筑生成的染色效果永远不会被移除。<span id="version">DEV</span></li>
							<li>修复了读取地图时，将<code>Preview(Pack)</code>放置在<code>Map</code>后面会导致绘制不出预览的问题。</li>
							<li>修复了重绘地图光照触发会使建筑光效失灵的问题。</li>
							<li>心控对于可以部署的载具, 部署后不再会永久改变所属方。</li>
							<li>修复了用工程师占领被心灵控制的建筑后不会移除心灵控制的连接线。</li>
							<li>移除了工程师占领被视为载具的建筑时的EVA语音。</li>
							<li>修复了当单位已经死亡却还在地图上时（例如沉没，坠毁，死亡动画等）还能再次死亡的问题。</li>
							<li>修复了隐形的辐射工兵无法发射部署武器的问题。</li>
							<li>修复了被超时空武器冻结的单位不能被正确抹消的问题，并不会再生成错误。</li>
							<li>修复了<code>DebrisMaximums</code>（产生的碎片不再能超过指定的最大值）。出于稳定性考量，只有当<code>DebrisMaximums</code>设定的值多于1个的时候才会激活此修复。</li>
							<li>修复了Q/W快捷键在失败摆放之后不会再把建造完成的建筑放到鼠标上的问题。</li>
							<li>可反部署的建筑，在反部署时不再会触发<code>EVA_NewRallypointEstablished</code>语音。</li>
							<li>修复了<code>Naval=yes</code>会无视<code>WaterBound=no</code>强制将建筑限制在水面上的问题。</li>
							<li>修复了AI的飞机停机坪在Ares标签<code>[GlobalControls]</code>中<code>AllowParallelAIQueues=no</span></code>时有bug的问题。</li>
							<li>修复了激光绘制的代码以允许所属方颜色绘制模式下更粗的激光。</li>
							<li>修复了<code>DeathWeapon</code>引爆不正确的问题。
							<ul>
							<li>但是仍有部分设置被忽略，如<code>PreImpactAnim</code>（Ares功能），未来可能会改。</li>
							</ul>
							</li>
							<li>修复了驻军建筑的<code>MuzzleFlashX</code>在<code>X</code>超过10之后会画在建筑中心的问题。</li>
							<li>修复了Jumpjet类单位在<code>Crashable=yes</code>时，如果被<code>Locomotor</code>弹头拉起，不会正常坠毁向地面的问题。</li>
							<li>修复了飞行载具类单位无法面朝目标开火的问题。</li>
							<li><p>Fixed jumpjet units being able to continue firing at enemy target when crashing.</p></li>
							<li><p>Fixed turreted jumpjet units always facing bottom-right direction when motion stops.</p></li>
							<li><p>Fixed jumpjet objects being unable to use <code>Sensors</span></code>.</p></li>
							<li><p>修复了<code>UnitAbsorb</code>和<code>InfantryAbsorb</code>与<code>Grinding=yes</code>的建筑的交互问题。现在这两个标签会使建筑仅能接收对应类型的单位。</p></li>
							<li><p>修复了缺少<code>NoEnter</span></code>鼠标动作导致载具无法进入<code>Grinding=yes</span></code>建筑的问题。</p></li>
							<li><p>修复了工程师可以在不应进入（如满血）时进入<code>Grinding=yes</code>的建筑的问题。</p></li>
							<li><p>Allowed usage of <code>AlternateFLH</code> of vehicles in <code>OpenTopped</code> transport.</p></li>
							<li><p>Improved the statistic distribution of the spawned crates over the visible area of the map so that they will no longer have a higher chance to show up near the edges.</p></li>
							<li><p>允许使用TileSet 255及以上,不再会使东北到西南方向的桥梁不可维修。</p></li>
							<li><p>Added a “Load Game” button to the retry dialog on mission failure.</p></li>
						</ul>
					</div>
					<h3>其他平台的问题修复</h3>
					<h3 id="enhanced-logic-aircraft">飞行器</h3>
					<h3 id="enhanced-logic-animations">动画</h3>
					<h3 id="enhanced-logic-buildings">建筑</h3>
					<h3 type="button" class="collapsible">自定义部队回收站</h4>
					<div class="col-content">
						<p>部队回收站现在可以定义更多的细节内容，如可回收的单位和回收音效。</p>
						<p><code>Grinding.AllowAllies</code>定义该部队回收站是否能回收友军单位，参数为布尔值。</p>
						<p><code>Grinding.AllowOwner</code>定义该部队回收站是否能回收己方单位，参数为布尔值。</p>
						<p><code>Grinding.AllowTypes</code>定义该部队回收站只能回收的单位，参数为单位注册名列表。一旦设置，未在列表出现的单位均不可回收。</p>
						<p><code>Grinding.DisallowTypes</code>定义该部队回收站不能回收的单位，参数为单位注册名列表。</p>
						<p><code>Grinding.Sound</code>定义该部队回收站的回收音效，参数为音效注册名，默认为<code>[AudioVisual]</code>中的<code>EnterGrinderSound</code>所定义的音效。</p>
						<p><code>Grinding.Weapon</code>定义该部队回收站回收单位时对本体开火的武器，参数为武器注册名，将会遵循ROF的设定。</p>
						<p><code>Grinding.DisplayRefund</code>定义该部队回收站在回收单位时是否显示资金数字，参数为布尔值。</p>
						<p><code>Grinding.DisplayRefund.Houses</code>定义该部队回收站显示资金数字时哪些所属方可以看见，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：所有所属方均不可看见</li>
							<li><code>owner/self</code>：只有该部队回收站的所属方可见</li>
							<li><code>allies/ally</code>：只有该部队回收站的所属方的盟友生效可见</li>
							<li><code>team</code>：该部队回收站的所属方及其盟友可见</li>
							<li><code>enemies/enemy</code>：只有该部队回收站的所属方的敌人可见</li>
							<li><code>all</code>：所有所属方均可见</li>
						</ul>
						<p><code>Grinding.DisplayRefund.Offset</code>定义该部队回收站显示资金数字的坐标，参数为两个整数代表X,Y值，单位为像素，默认为0,0，即建筑的中心。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[YAGRND]</p>
							<p>...</p>
							<p>Grinding=yes ;该建筑是否是部队回收站</p>
							<p>Grinding.AllowAllies=true ;是否可以回收友军单位</p>
							<p>Grinding.AllowOwner=true ;是否可以回收己方单位</p>
							<p>Grinding.AllowTypes= ;回收的单位限定</p>
							<p>Grinding.DisallowTypes=BFRT ;不可回收的单位限定</p>
							<p>Grinding.Sound= ;回收时的音效</p>
							<p>Grinding.Weapon= ;回收时使用的武器</p>
							<p>Grinding.DisplayRefund=true ;回收单位是否显示资金</p>
							<p>Grinding.DisplayRefund.Houses=team ;显示资金可见所属方</p>
							<p>Grinding.DisplayRefund.Offset=0,15 ;显示资金位置</p>
						</div>
					</div>
					<h3 id="enhanced-logic-particle-sys">粒子系统</h3>
					<h3 id="enhanced-logic-particle">粒子</h3>
					<h3 id="enhanced-logic-projectile">抛射体</h3>
					<h3 type="button" class="collapsible">自定义抛射体重力</h4>
					<div class="col-content">
						<p>对于<code>Arcing</code>类型的抛射体来说，其弹道下坠现象由<code>[AudioVisual]</code>的<code>Gravity</code>参数进行全局控制，而在Phobos中，你可以为每一个抛射体微观定义Gravity值。</p>
						<p><code>Gravity</code>定义抛射体所收到的重力，参数为浮点值，不建议设置为0，因为这将导致抛射体逆向飞行，并无法击中非同高度的目标。如果想要平射弹道，可以用Phobos的<a href="#projectile-trajectory">弹道类抛射体</a>。</p>
					</div>
					<h3 id="enhanced-logic-technos">单位</h3>
					<h3 type="button" class="collapsible">自定义建筑提供的回血效果</h4>
					<div class="col-content">
						<p>现在可以为建筑提供的回血效果增加全局限制，并可以自定义其徽章和种类。</p>
						<p>知识点补充：</p>
						<p id="comment">在原版的市民医院和机械车间（机械商店）上，使用<code>InfantryGainSelfHeal=</code>和<code>UnitsGainSelfHeal=</code>来代表每<code>SelfHealInfantryFrames</code>或<code>SelfHealUnitFrames</code>帧恢复多少次<code>SelfHealInfantryAmount</code>或<code>SelfHealUnitAmount</code>的血量，原版为1，即一次。如果想要做一个恢复能力更高的建筑，便可以将这两句代码的参数改为大于1的值。</p>
						<p>在<code>[General]</code>下用<code>InfantryGainSelfHealCap</code>定义最多可以恢复多少次<code>InfantryGainSelfHeal</code>的血量，参数为整数，必须大于1。</p>
						<p>在<code>[General]</code>下用<code>UnitsGainSelfHealCap</code>定义最多可以恢复多少次<code>UnitsGainSelfHeal</code>的血量，参数为整数，必须大于1。</p>
						<p>在<code>[AudioVisual]</code>下用<code>Pips.SelfHeal.Infantry</code>、<code>Pips.SelfHeal.Units</code>、<code>Pips.SelfHeal.Buildings</code>来分别定义步兵、单位和建筑在获得回血效果后的徽章，即pips.shp，参数为整数，即pips.shp中的第几帧。</p>
						<p>在<code>[AudioVisual]</code>下用<code>Pips.SelfHeal.Infantry.Offset</code>、<code>Pips.SelfHeal.Units.Offset</code>、<code>Pips.SelfHeal.Buildings.Offset</code>来分别定义步兵、单位和建筑在获得回血效果后的徽章位置，参数为两个整数代表X,Y值，单位为像素。</p>
						<p>在单位中使用<code>SelfHealGainType</code>来定义该单位可以接受哪种建筑提供的回血效果，参数为下列预设值：</p>
						<ul>
							<li><code>none</code>：该单位不会接受任何建筑提供的回血效果</li>
							<li><code>infantry</code>：该单位会接受带<code>InfantryGainSelfHeal=</code>的建筑提供的回血效果，原版对应市民医院</li>
							<li><code>units</code>：该单位会接受带<code>UnitsGainSelfHeal=</code>的建筑提供的回血效果，原版对应机械车间</li>
						</ul>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[General]</p>
							<p>InfantryGainSelfHealCap=5 ;</p>
							<p>UnitsGainSelfHealCap=5 ;</p>
							<br>
							<p>[AudioVisual]</p>
							<p>Pips.SelfHeal.Infantry=13,20</p>
							<p>Pips.SelfHeal.Units=13,20</p>
							<p>Pips.SelfHeal.Buildings=13,20</p>
							<p>Pips.SelfHeal.Infantry.Offset=25,-35</p>
							<p>Pips.SelfHeal.Units.Offset=33,-32</p>
							<p>Pips.SelfHeal.Buildings.Offset=15,10</p>
							<br>
							<p>[DRON]</p>
							<p>...</p>
							<p>SelfHealGainType=infantry</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">自定义采矿动画</h4>
					<div class="col-content">
						<p>现在可以为采矿车单位在采集不同类型的矿石时定义不同的采矿动画。</p>
						<p><code>OreGathering.Anims</code>定义该采矿车所使用的采矿动画，参数为动画注册名的列表，代表采集不同矿石的时候所播放的动画。</p>
						<p><code>OreGathering.FramesPerDir</code>定义该采矿车播放采矿动画时，每个方向的帧数，参数为整数的列表，和动画列表对应。</p>
						<p><code>OreGathering.Tiberiums</code>定义该采矿车在采集哪种矿石的时候播放动画，参数为整数的列表，代表矿石的种类，对应<code>[Tiberiums]</code>注册表中的序号。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[HARV]</p>
							<p>...</p>
							<p>OreGathering.Anims=GREEN,GREEN,BLUE,BLUE ;采矿动画</p>
							<p>OreGathering.FramesPerDir=15,15,15,15 ;每个方向的帧数</p>
							<p>OreGathering.Tiberiums=0,1,2,3 ;采集哪种矿石播放上述动画</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">可微观定义的超时空瞬移</h4>
					<div class="col-content">
						<p>现在全局中的超时空瞬移的属性可以在每个单位中微观定义，默认均为对应的全局标签，仅对超时空运动模式有效。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[CLEGX] ;Chrono Legion X</p>
							<p>WarpOut=WARPIN ;传送离开时播放的动画</p>
							<p>WarpIn=WARPOUT ;传送到目的地是播放的动画</p>
							<p>WarpAway=WARPAWAY ;用超时空传送时播放的动画</p>
							<p>ChronoTrigger=true ;是否根据距离决定冷冻时间</p>
							<p>ChronoDistanceFactor=48 ;传送距离和冷冻时间的因数</p>
							<p>ChronoMinimumDelay=16 ;传送冷冻时间的最低值</p>
							<p>ChronoRangeMinimum=8 ;多少距离才不会根据距离决定冷冻时间</p>
							<p>ChronoDelay=60 ;用超时空传送的冷冻时间</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">在art中定义单位图像</h4>
					<div class="col-content">
						<p><code>Image</code>标签在artmd.ini中只对动画和建筑生效，而现在可以对所有单位（建筑、步兵、载具、飞行器）生效了。需要注意的是，该标签只需要填入素材名称即可，不需要文件格式后缀。为了适配原版，该功能默认是关闭的，因此需要通过在<code>[General]</code>中的<code>ArtImageSwap=true</code>来打开这个功能。</p>
						<p>该功能支持SHP格式的步兵（InfantryTypes）、SHP和VXL格式的载具（VehicleTypes）以及VXL格式的飞行器（AircraftTypes）。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[General]</p>
							<p>...</p>
							<p>ArtImageSwap=true ;开启art中定义单位图像功能</p>
						</div>
						<p>在<code>artmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[SSPY] ;Soviet Spy</p>
							<p>...</p>
							<p>Image=SPY</p>
						</div>						
					</div>
					<h3 type="button" class="collapsible">自定义矿石储存槽</h4>
					<div class="col-content">
						<p>现在可以自定义矿石储存槽可以储存哪种类型的矿石了。该功能需要配合Ares的矿石储存槽功能使用。</p>
						<p>在<code>[General]</code>中<code>Storage.TiberiumIndex</code>定义哪些矿石可以被储存，参数为整数的列表，代表矿石注册表的序列号。</p>
					</div>
					<h3 type="button" class="collapsible">自定义单位爆炸是否杀死乘员</h4>
					<div class="col-content">
						<p>在原版中，带有<code>Explodes=true</code>的单位都会在被摧毁时杀死乘员，这个硬编码设定可以被新标签<code>Explodes.KillPassengers=false</code>关闭。</p>
					</div>
					<h3 type="button" class="collapsible">自定义飞行单位层级</h4>
					<div class="col-content">
						<p>飞行单位（指飞艇或直升机类的飞行载具，非飞行器）在<code>air</code>或<code>top</code>层级的判定方式为：该单位当前所在的高度大于或小于<code>JumpjetHeight</code>设定或者在<code>[JumpjetControls]</code>中<code>CruiseHeight</code>所默认的高度。</p>
						<p>未完待续……</p>
					</div>
					<h3 type="button" class="collapsible">飞行单位面向目标开火</h4>
					<div class="col-content">
						<p>飞行单位在原版中武器必须带<code>OmniFire=yes</code>才可以正常开火，然而这样的后果是哪怕飞行单位背对目标也可以开火。而现在可以通过在<code>[JumpjetControls]</code>增加<code>TurnToTarget=yes</code>标签来让所有飞行单位面向单位开火。同时，也可以通过在单位上设置<code>JumpjetTurnToTarget</code>来覆盖某个特定单位是否面向目标开火。</p>
						<p>显然，带有<code>TurretSpins=yes</code>的飞行单位无法使用该逻辑。</p>
					</div>
					<h3 type="button" class="collapsible">停电子机坠毁</h4>
					<div class="col-content">
						<p><code>Powered.KillSpawns</code>定义当使用子机的建筑单位停电时，建筑单位是否会停止瞄准敌军单位，同时子机坠毁，参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">重启全局飞行单位控制</h4>
					<div class="col-content">
						<p>Phobos重启了原版废弃的<code>[JumpjetControls]</code>模块，作为所有飞行单位的默认设定，但需要增加两个额外的标签，即<code>Crash</code>和<code>NoWobbles</code></p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[JumpjetControls]</p>
							<p>...</p>
							<p>Crash=5.0</p>
							<p>NoWobbles=false</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">禁止AI平行生产线</h4>
					<div class="col-content">
						<p>在Ares中，可以在<code>[GlobalControls]</code>中设置<code>AllowParallelAIQueues=no</code>来避免AI在多工厂的环境下平行生产，即在生产某一单位时克隆出其他单位。现在可以将某个特定种类的工厂建筑设置禁止AI的平行生产。如果设置了<code>AllowParallelAIQueues=no</code>，该功能无效。</p>
						<p><code>ForbidParallelAIQueues.Infantry</code>定义是否禁止步兵单位的AI平行生产，参数为布尔值。</p>
						<p><code>ForbidParallelAIQueues.Vehicle</code>定义是否禁止载具单位的AI平行生产，参数为布尔值。</p>
						<p><code>ForbidParallelAIQueues.Navy</code>定义是否禁止舰船单位的AI平行生产，参数为布尔值。</p>
						<p><code>ForbidParallelAIQueues.Aircraft</code>定义是否禁止飞行器单位的AI平行生产，参数为布尔值。</p>
						<p><code>ForbidParallelAIQueues.Building</code>定义是否禁止建筑单位的AI平行生产，参数为布尔值。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[GlobalControls]</p>
							<p>...</p>
							<p>AllowParallelAIQueues=yes ;必须开启，否则无效</p>
							<p>ForbidParallelAIQueues.Infantry=no ;是否禁止步兵平行生产</p>
							<p>ForbidParallelAIQueues.Vehicle=no ;是否禁止载具平行生产</p>
							<p>ForbidParallelAIQueues.Navy=no ;是否禁止舰船平行生产</p>
							<p>ForbidParallelAIQueues.Aircraft=no ;是否禁止飞行器平行生产</p>
							<p>ForbidParallelAIQueues.Building=yes ;是否禁止建筑平行生产</p>
						</div>
					</div>
					<h3 id="enhanced-logic-terrains">地形对象</h3>
					<h3 type="button" class="collapsible">自定义矿钻</h4>
					<div class="col-content">
						<p>现在你可以定义某个地形对象可以生成的矿石种类，同时可以自定义生成矿石的范围。</p>
						<p>代码示例：</p>
						<p>在<code>rulesmd.ini</code>中：</p>
						<div class="code-presentation">
							<p>[TIBTRE04]</p>
							<p>SpawnsTiberium.Type=0 ;矿石生长的类型</p>
							<p>SpawnsTiberium.Range=1 ;矿石生长的范围</p>
							<p>SpawnsTiberium.GrowthStage=3 ;矿石生长的阶段</p>
							<p>SpawnsTiberium.CellsPerAnim=1 ;矿钻播放动画一次矿石生长多少格</p>
						</div>
					</div>
					<h3 type="button" class="collapsible">自定义地形小地图颜色</h4>
					<div class="col-content">
						<p><code>MinimapColor</code>定义地形对象在小地图的颜色，参数为R,G,B值。</p>
					</div>
					<h3 type="button" class="collapsible">地形可通过和建造建筑</h4>
					<div class="col-content">
						<p>现在可以自定义地形对象是否可以通过或建造建筑。</p>
						<p><code>IsPassable</code>定义地形对象是否可以通过，参数为布尔值。设置为true时，鼠标指针会在地形对象上显示可移动到该位置。</p>
						<p><code>CanBeBuiltOn</code>定义地形对象是否可以建造建筑，参数为布尔值。设置为true时，建造建筑将不会在该地形对象上显示不可建造，同时建筑建造时该地形对象自动移除。给树木添加这个标签可以实现建造建筑时自动移除树木。</p>
					</div>
					<h3 id="enhanced-logic-tiberium">矿石</h3>
					<h3 type="button" class="collapsible">自定义矿石小地图颜色</h4>
					<div class="col-content">
						<p><code>MinimapColor</code>定义该矿石种类在小地图上显示的颜色，参数为R,G,B值。</p>
					</div>
					<h3 id="enhanced-logic-vehicles">载具</h3>
					<h3 type="button" class="collapsible">载具的摧毁动画</h4>
					<div class="col-content">
						<p>现在可以为载具单位定义摧毁时播放的动画，和原版的<code>Explosion</code>不同，这个动画会储存单位的所属信息、炮塔角度信息等，适合与<a href="#anim-create-unit">动画生成单位</a>一起用。</p>
						<p><code>DestroyAnim</code>定义该载具在被摧毁时播放的动画，参数为动画的注册名所组成的列表，可以填入多个动画。</p>
						<p><code>DestroyAnim.Random</code>定义该载具在被摧毁时的动画是否随机播放，参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">单位部署的动画和方向</h4>
					<div class="col-content">
						<p>现在可以自定义<code>IsSimpleDeployer</code>单位的部署的动画属性以及方向。</p>
						<p><code>DeployingAnim.AllowAnyDirection</code>定义该单位是否可以在任意朝向部署，参数为布尔值，如果设定成true，将会屏蔽其他定义方向的语句，并屏蔽<code>DeployingAnim</code>所定义的部署动画。同时，该标签只对地面单位有效。</p>
						<p><code>DeployingAnim.KeepUnitVisible</code>定义该单位在部署动画播放时是否显示，参数为布尔值，如果设定成false，那么播放动画时单位会隐藏。</p>
						<p><code>DeployingAnim.ReverseForUndeploy</code>定义该单位在收起部署时播放的部署动画是否为倒放，参数为布尔值。</p>
						<p><code>DeployingAnim.UseUnitDrawer</code>定义该单位的部署动画是否使用单位调色盘（unit***.pal），参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">静态载具</h4>
					<div class="col-content">
						<p>现在可以通过将载具的<code>Speed</code>设置为0使其成为静态载具，效果类似拥有<code>IsSimpleDeployer</code>标签的载具部署后的形态（原版武装直升机）。</p>
						<p id="alert">注意：不要把这个设置赋予可建造的载具，否则会卡在工厂里出不来。</p>
					</div>
					<h3 type="button" class="collapsible">单位部署保留铁幕效果</h4>
					<div class="col-content">
						<p>现在，你可以定义带有<code>DeploysInto</code>或<code>UndeploysInto</code>标签的载具是否在部署后保留铁幕效果，包括宏观定义和微观定义。变形之后<code>IronCurtain.Modifier</code>会重新生效。</p>
						<p><code>IronCurtain.KeptOnDeploy</code>定义该单位是否在部署后仍然保留铁幕效果，参数为布尔值。这个标签可以写在[CombatDamage]中作为全局标签，也可以写在单位中作为微观标签。</p>
					</div>
					<h3 id="enhanced-logic-vein">藤蔓与废料</h3>
					<h3 id="enhanced-logic-debris">VXL碎片</h3>
					<h3 id="enhanced-logic-warheads">弹头</h3>
					<h3 type="button" class="collapsible">允许弹头对发射者生效</h4>
					<div class="col-content">
						<p>现在你可以让弹头对发射者自身造成伤害，并且产生各种衍生效果，如Ares的<code>KillDriver</code>、<code>DisableWeapons</code>、<code>Sonar</code>或<code>Flash.Duration</code>等，即便弹头上没有<code>DamageSelf=true</code>标签。</p>
						<p id="comment">需要注意的是，带有<code>Psychedelic=true</code>标签的弹头仍然无法对发射者产生效果，因其只会影响所属阵营外的单位。</p>
						<p><code>AllowDamageOnSelf</code>定义该弹头是否可以对自身造成伤害和衍生效果，参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">弹头是否解除隐形</h4>
					<div class="col-content">
						<p>在原版中，隐形的单位被任何弹头打中将会解除隐形。现在，你可以设置弹头在击中隐形单位时是否让其解除隐形。</p>
						<p><code>DecloakDamagedTargets</code>定义是否在给隐形单位造成伤害后解除其隐形效果，参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">弹头局部振动效果</h4>
					<div class="col-content">
						<p>在原版中，你可以通过在弹头设置<code>ShakeXlo</code>、<code>ShakeXhi</code>、<code>ShakeYlo</code>、<code>ShakeYhi</code>四个标签来定义屏幕振动，但振动是全局振动。现在你可以定义该弹头的振动是否为局部振动，即弹头在视野内爆炸时才会振动。</p>
						<p><code>ShakeIsLocal</code>定义该弹头的振动是否为局部振动，参数为布尔值。</p>
					</div>
					<h3 id="enhanced-logic-weapons">武器</h3>
					<h3 type="button" class="collapsible">自定义飞碟激光</h4>
					<div class="col-content">
						<p>现在你可以自定义飞碟激光前摇光轮的直径。</p>
						<p><code>DiskLaser.Radius</code>定义飞碟激光的前摇光轮的直径，参数为浮点值，38.2大约为原版飞碟激光前摇光轮的直径。</p>
					</div>
					<h3 type="button" class="collapsible">单色激光</h4>
					<div class="col-content">
						<p>现在可以将激光定义为单色，即只有<code>LaserInnerColor</code>所指定的颜色，效果类似<code>IsHouseColor</code>指定激光为所属色。</p>
						<p><code>IsSingleColor</code>定义该武器是否为单色激光，参数为布尔值。</p>
						<p id="alert">注意：此功能不支持光棱塔援射逻辑。</p>
					</div>
					<h3 type="button" class="collapsible">可关闭电流效果</h4>
					<div class="col-content">
						<p>在原版中，电流效果通常是由三道电弧组成。现在你可以定义关闭三道电弧中的任何一个。</p>
						<p><code>Bolt.Disable1</code>、<code>Bolt.Disable2</code>、<code>Bolt.Disable3</code>分别定义是否关闭某一道电流，参数为布尔值。</p>
					</div>
					<h3 type="button" class="collapsible">自定义电弧<span id="version">DEV</span></h4>
					<div class="col-content">
						<p>在原版中武器，<code>IsElectricBolt=yes</code>的电弧通常是由8段弧线组成，而现在你可以自定义弧线的段数。</p>
						<p><code>Bolt.Arcs</code>定义该电流武器的弧线有多少段，参数为整数，如果为0则绘制一条直线。</p>
					</div>
					<h3 id="enhanced-logic-misc">杂项</h3>
					<h3 type="button" class="collapsible">自定义范围圈可见阵营</h4>
					<div class="col-content">
						<p>在原版中，范围圈默认为只有附带范围圈单位的所属方可见。现在，可以自定义范围圈的可见阵营。</p>
						<p><code>RadialIndicatorVisibility</code>定义范围圈的可见阵营，参数为下列预设值：</p>
						<ul>
							<li><code>owner</code>或<code>self</code>：只有单位的所属方可见。</li>
							<li><code>allies</code>或<code>ally</code>：单位的所属方及其盟友可见。</li>
							<li><code>enemies</code>或<code>enemy</code>：单位的所属方及其敌人可见。</li>
							<li><code>all</code>：所有阵营均可见。</li>
						</ul>
					</div>
				</div>
			</div>
		</div>	
	</main>
	<!--Footer-->
	<footer>
		<div class="footer-container">
			<div class="footer-left">
				<div class="footer-logo">
					<img src="../../src/favicon.svg" alt="Bellum Aeternum" width="64" height="64">
					<p>万世<br>之战</p>
				</div>
				<div class="lang-selector">
					<p>语言切换</p>
					<div class="lang-list">
						<a href="https://ra2be.com/blog/">EN</a>
						<a href="https://ra2be.com/zh/blog/phobos-tutorial">中</a>
					</div>
				</div>
			</div>
			<div class="footer-right">
				<div class="footer-column">
				<p>阵营</p>
				<ul>
					<li><a href="../allied.html">盟军</a></li>
					<li><a href="../soviet.html">苏联</a></li>
				</ul>
				</div>
				<div class="footer-column">
				<p>文章</p>
				<ul>
					<li><a href="../archives.html">资料库</a></li>
					<li><a href="../blog.html">博客</a></li>
				</ul>
				</div>
				<div class="footer-column">
				<p>关于</p>
				<ul>
					<li><a href="#contact">联系作者</a></li>
				</ul>
				</div>
			</div>
		</div>
		<div class="footer-portals">
			<a href="https://space.bilibili.com/3546721533561614"><img src="../../src/bilibili.svg" width="auto" height="auto"></a>
		</div>
	</footer>
	<script>
		var coll = document.getElementsByClassName("collapsible");

		for (var i = 0; i < coll.length; i++) {
			coll[i].addEventListener("click", function () {
				for (var j = 0; j < coll.length; j++) {
					if (coll[j] !== this) {
						coll[j].classList.remove("active");
						var otherContent = coll[j].nextElementSibling;
						if (otherContent && otherContent.style.maxHeight) {
							otherContent.style.maxHeight = null;
						}
					}
				}

				this.classList.toggle("active");
				var content = this.nextElementSibling;
				if (content.style.maxHeight) {
					content.style.maxHeight = null;
				}
				else {
					content.style.maxHeight = content.scrollHeight + "px";
				}
			});
		}
	</script>
	<script>
		document.addEventListener('DOMContentLoaded', function() {
			const blogContent = document.querySelector('.blog-content');
			const h2Tags = blogContent.querySelectorAll('h2');
			const chapsDiv = document.querySelector('.chaps');
			
			h2Tags.forEach(h2 => {
				const id = h2.id;
				const text = h2.textContent;
				const anchor = document.createElement('a');
				anchor.href = `#${id}`;
				anchor.textContent = text;
				chapsDiv.appendChild(anchor);
			});
		});
	</script>
</body>