关于Phobos
简介
火卫一（Phobos，福波斯）是一个还在开发中的基于自定义 YRpp与注射器的社区项目，旨在为尤里的复仇提供一些新功能或修复bug。   这意味着它可以与战神 (Ares，火星，阿瑞斯) 平台共同使用，而非替代，也因此并不会产生不兼容性。 

本说明书参考自官方中文说明书，旨在方便可能无法访问官方说明书的使用者查询功能使用，如果需要了解更多信息请访问官方说明书。

Phobos项目地址：
https://github.com/Phobos-developers/Phobos
Phobos官方中文说明书地址：https://phobos.readthedocs.io/zh_CN/latest/index.html#
PhobosCHM说明书在线版本：
https://docs.qq.com/doc/p/dc3da1ce39a6e787b6e133f7d33d6aebef581cb4
PhobosCHM说明书更新日志：https://docs.qq.com/doc/DWU1wQVNrQXpZRkFx 
PhobosCHM说明书问题反馈收集表：https://docs.qq.com/form/page/DWU9icVNvU0lDckF1
PhobosCHM说明书问题反馈公示：https://docs.qq.com/sheet/DWVRqQWZhTkVWaW9o



b30之前由九千天华、園神凜祢/b30之后溺水的鱼、王科学、BG 参与翻译与整合 
日经级疑难杂症
1.	添加Phobos后我的动画颜色出问题了
关掉[General]►FixTransparencyBlitters，该语句目前默认开启
2.	添加Phobos后我单位超时空移动时的动画出现问题
把全局[General]►WarpIn=WarpIn改成WarpIn=WARPOUT
3.	我使用Phobos的电力/矿车指示器、建造时间功能显示为X而非正确符号
Phobos官方的PhobosSupplementaries中提供了添加了这几个符号的game.fnt文件，这里提供一个转载
在本说明书下载地址/7-Z.PhobosCHM说明书与其他相关/PhobosSupplementaries-develop.zip/(解压)/ImprovedFont/game.fnt
你也可以使用手柄为RA2简中项目专门制作的、补充大量缺失字符的版本一劳永逸地解决字符缺失问题
https://github.com/Translate-with-LOVE/Ra2-zh_hans-main/tree/main/fnt
4.	有多个升级插件的建筑插件图像显示不正确
将升级插件的[BuildingType]►PowersUpToLevel 按顺序填写为正数而不要填写-1，同时检查artmd.ini中母建筑的[BuildingType]►PowerUpNDamagedAnim（N为升级插件序号）是否正确填写（PowerUpNAnimDamaged为无效错误写法）。
5.	使用动画造成伤害的单位没伤害了
将造成伤害的动画[Animation]►Damage.DealtByInvoker设置为true。

Bug修复和杂项
修复了游戏设定不能正确保存的问题。例如，于盟友基地旁建造在存档并读取后不生效。
修复了读取地图时，将Preview(Pack)放置在Map后面会导致绘制不出预览的问题。
修复了重绘地图光照触发会使建筑光效失灵的问题。
心控对于可以部署的载具, 部署后不再会永久改变所属方。 
修复了当单位已经死亡却还在地图上时（例如沉没，坠毁，死亡动画等）还能再次死亡的问题。
修复了隐形的辐射工兵无法发射部署武器的问题。
修复了被超时空武器冻结的单位不能被正确抹消的问题，并不会再生成错误。
修复了DebrisMaximums（产生的碎片不再能超过指定的最大值）。出于稳定性考量，只有当DebrisMaximums设定的值多于1个的时候才会激活此修复。
修复了Q/W快捷键在失败摆放之后不会再把建造完成的建筑放到鼠标上的问题。
可反部署的建筑，在反部署时不再会触发EVA_NewRallypointEstablished语音。
修复了Naval=yes会无视WaterBound=no强制将建筑限制在水面上的问题。
修复了AI的飞机停机坪在Ares标签[GlobalControls]►AllowParallelAIQueues=no时有bug的问题。
修复了激光绘制的代码以允许所属方颜色绘制模式下更粗的激光。
修复了DeathWeapon引爆不正确的问题。但是仍有部分设置被忽略，如PreImpactAnim（Ares功能），未来可能会改。
修复了驻军建筑的MuzzleFlashX在X超过10之后会画在建筑中心的问题。
修复了Jumpjet类单位在Crashable=yes时，如果被Locomotor弹头拉起，不会正常坠毁向地面的问题。
修复了jumpjet单位无法转向目标时，会从其它的方向射击的问题。
修复了jumpjet的炮塔总是在运动停止时面朝右下方的问题。
修复了jumpjet单位无法使用Sensors侦测隐形单位的问题。
修复了UnitAbsorb和InfantryAbsorb与Grinding=yes的建筑的交互问题。现在这两个标签会使建筑仅能接收对应类型的单位。
修复了缺少NoEnter鼠标动作导致载具无法进入Grinding=yes建筑的问题。
修复了工程师可以在不应进入（如满血）时进入Grinding=yes的建筑的问题。
SHP碎片现在可以通过ExtraShadow控制阴影。
允许使用TileSet 255及以上,不再会使东北到西南方向的桥梁不可维修。 
在重新开始游戏的对话框中增加了一个“读取游戏”按钮。
TurretOffset现在可以像FLH(TurretOffset=F,L或TurretOffset=F,L,H)，一样指定，一个数为前后，两个数的第二个数为左右，三个数的第三个数为上下。
Damage=1的InfiniteMindControl现在可以控制多于1个单位。
Fighter=no的飞机或扫射型飞机（即抛射体ROT小于2）现在会在每次攻击时都读取Burst，而非仅第一次。
AnimList.PickRandom取代EMEffect，可以使弹头爆炸时随机播放动画。
修复了DeployFire逻辑，使DeployFireWeapon，FireOnce，及停止指令可以正常运作。
DeployToFire的载具在部署后会保持它们之前的攻击目标。
有DeployFireWeapon=-1的步兵在部署后可以使用全部的武器（由其目标决定）。
对于使用Burst的武器来说，效果如激光不再会绘制在错误的位置上。
现在可以用XDrawOffset为动画设置X轴偏移量了。
IsSimpleDeployer的单位现在只会播放DeploySound和UndeploySound一次。
AI触发现在可以将建筑升级当做可用条件。
EWGates和NSGates现在会分别像xxGateOne和xxGateTwo一样链接围墙。
飞机与Jumpjet单位现在可以正常接受速度加成，如国家中的SpeedAircraft/Infantry/UnitsMult，VeteranSpeed和箱子/附加效果（Ares功能）。
VXL与SHP载具现在都可以以Palette自定义色盘。
电磁脉冲超级武器，在不带EMPulse.TargetSelf=yes（Ares功能）时也可以产生辐射。
为地形对象设置RadarInvisible=true可以使其不在小地图中显示。
心灵控制指示动画现在会在单位解除隐形后恢复。
现在弹头AnimList，SplashList与触发动作41 播放动画在...都会自动绑定所属方。
核弹起飞与落地武器现在都遵循Bright设定（之前只有落地武器在Nuke.SiloLaunch=false（Ares功能）时有效）。
受到InfantryGainSelfHeal和UnitsGainSelfHeal自愈效果的图像现在会伴随PixelSelectionBracketDelta调整了。
通过SelfHealing恢复耐久度的建筑现在能够正确切换为未损坏图像了。
允许地形使用0x0大小而不导致错误。
抛射体现在会记住所属，即使发射者被摧毁。目前不适用于Ares新增的弹头效果，如EMP。
OpenTopped的载具现在会在确定武器范围用于扫描威胁和接近目标时考虑乘客设置的OpenTransportWeapon了。
尾烟现在可以继承其附着者（动画、抛射体或飞行器）的所属了。
建筑现在可以正确的读取副武器设置的激光参数了，而不是从主武器读取。
修复了有所属但没有来源的伤害杀死的载具无法被正确地记录为已死亡的问题。
IsAnimated、AnimationRate和AnimationProbability可以在SpawnsTiberium设置为no的地形上正常工作了。
半透明的RLE SHP现在将使用更精确和性能更高的算法绘制，该算法没有绿色色调和条纹。可以通过在rulesmd.ini中设置[General]►FixTransparencyBlitters来启用或禁用。目前仅适用于Z-aware绘图模式。
修复了如果武器的Airburst=yes或弹头的EMEffect=true，Inviso=true的抛射体存在潜在的不准确问题。
修复了BombClass导致MakeInfantry生成中立方步兵的错误。
修复了轨道炮粒子在攻击 非默认TargetCoordOffset的建筑 或 在桥梁上强制射击 时绘制到错误坐标的问题。 
修复了建筑的TargetCoordOffset不生效的几种情况。
脚本动作移动到单元格现在遵循YR的单元格计算规则，使用1000 * Y + X，而非遗留自RA1的128 * Y + X。 
观察者现在可以看到非盟军所拥有的隐形单位。
在单人任务中，玩家现在可以看到盟军拥有的隐形单位。
伊文炸弹的图像现在显示在建筑物的中心，而不是在最左上角。
路径点的范围由[0,701]扩展到[0, 2147483647]。 
修复了播放建筑长时间建造动画的BibShape绘制问题。
带有Tiled=yes的动画现在也支持CustomPalette了.
尝试避免单位在改变所有权(精神控制，绑架等)后保留之前的命令(攻击，占领，驻军等)。
修复了建筑的NaturalParticleSystem在地图上预置时就被建造的问题
修复了TiltCrashJumpjet=no的jumpjet单位无法倾斜或在地面上翻转的问题。
单位的AlternateFLH词条语句不再仅限于5个。
弹头生成碎片现在使用MaxDebris作为碎片数量的实际上限，而不是MaxDebris - 1。
如果主武器和副武器都可以向空中目标开火(抛射体AA=yes)，现在可以选择主武器，而不总是强制使用副武器。也适用于盖特逻辑(IsGattling=true)，分别使用WeaponX的奇数和偶数个，而不是Primary和Secondary。
盖特逻辑(IsGattling=true)现在可以在主武器(奇数WeaponX)不能对当前目标开火时，跳到二级武器槽(偶数WeaponX)。
修复了LandTargeting=1的单位也可以攻击陆地地形对象的问题。
修复了NavalTargeting=6的单位也可以攻击水域及地形对象的问题。
修复了LandTargeting=2或NavalTargeting=7的单位依然可以使用主武器攻击陆地地形对象的问题。
修复了地面层及层中对象不能正确排序的问题(实际动画和jumpjet分层)。
修复了C4=true的步兵在跳伞空降或超时空转移到水域会被直接杀死的问题，即使他们可以在水中移动。
现在可以通过设置CreateAnimsOnZeroDamage=true，配合弹头的AnimList来创建零伤害的动画。
现在可以通过设定不同于[MultiplayerDialogSettings]►MCVRedeploys的语句来使MCV在战役中可以重新部署。
修复了UndeploysInto的建筑即便Unsellable=no也不能被正常出售，以及出售时EVA_StructureSold不能正常播放的问题。
修复了UndeploysInto的建筑有WaterBound=true时，在建筑收起为载具时不能停在正确位置的问题。
现在带有CanC4 =false的建筑在被低于1的伤害击中时会受到1点伤害。这不再适用于任何条件下的负伤害，可以通过设置CanC4来禁用零伤害(AllowZeroDamage=true)。
现在主武器抛射体AG=yes的建筑在选中时，鼠标会显示攻击光标。
现在武器抛射体AA=yes时，可以设置AAOnly=yes来设定单位只能攻击空中目标，无视其他语句。
现在带有OpenTopped=true的载具，其中载员的武器Burst如果大于1，也不再基于偏移量产生开火偏移。
修复了步兵在伪装时色盘不能被正确设置的问题。
现在可以通过设定[General]►DisguiseBlinkingVisibility来使伪装步兵的原军衔可见。
现在带有超级武器的建筑如果初始位于地图上，不再播放SuperAnimThree。
现在建筑升级逻辑可以正常使用SpySat=yes语句。
现在AI可以像人类玩家一样正常制造Naval=true和Naval=false的载具。
修正了jumpjet在开始移动时会朝向右下方的问题。
地图触发动作125将建筑建造于...现在可选是否播放建造动画（需要自行修改Fadata.ini）。
在单人战役中，AI现在可以通过设置SW(ARES)来修复基地节点/建筑。
由触发动作7,80,107生成的小队可以正常使用IFV和OpenTopped逻辑。目前还不支持Ares中的InitialPayload逻辑。
全局变量（rulesmd.ini中的VariableNames）与局部变量（地图中的VariableNames）均扩展为无上限的了。
执行部署脚本时带有DeploysInto的载具如果在原地无法部署则会自动在周围搜寻可部署的位置而不是卡住。
允许载入全彩非索引色的PCX。对Ares的PCX也支持。
可以通过命令行参数-icon <路径>指定gamemd.exe的图标，路径可以是绝对路径也可以是相对路径。 
修复了由Blowfish.dll导致的错误***FATAL*** String Manager failed to initialize properly。 
修复了非输入法键盘输入以使基础拉丁或拉丁-1以外的语言或键盘布局可以正常工作。
Ares的BallisticScatter.Min、BallisticScatter.Max两句现在同样支持FlakScatter=true的抛射体
围墙类覆盖物现在可以支持在artmd.ini里用Palette语句定义色盘
当单位的NoSecondaryWeaponFallback=false且单位的主武弹头Wall=false，副武弹头Wall=true时，支持单位使用副武攻击围墙
现在可以在弹头中设置ApplyModifiersOnNegativeDamage=true来启用负伤害的Verses和PercentAtMax
现在自定义色盘的单位可以被超武或地图的光照影响，不再限制为[Colors]的前半部分
修复了DeploysInto的建筑有WaterBound=true时，DeployToFire不会正常遵循建筑建造逻辑。
修复了DeployToFire的单位在不可部署的地形开火时开火坐标错误的问题
通过设置Arcing.AllowElevationInaccuracy=false可以让Arcing=true的抛射体在有高低差的情况下也能正常击中目标
EMPulseCannon的建筑武器现在可以正常支持floater和Phobos的Gravity设定
现在TurretOffset可以支持SHP载具了
修复了选择建筑时显示的标签和建造图标的位置错乱
修复了当载具隐形且武器设置为DecloakToFire=true时部署武器失效的问题
修复了IsAnimated的地形无法正常加载的问题
修复了CreateUnit在桥梁上工作不正常的问题（例如生成在桥下）
CanTarget现在可以正常将桥梁视作land地形
AreaFire.Target现在会根据开火者的高度来决定是否将桥梁纳入考虑范围
修复了护盾的血条在水平线上与单位血条可能不一致的问题
修复了可拦截抛射体单位在遇到突然变化成不可拦截的抛射体时不会改变目标的问题
修复了PlacementPreview不会正常从ini里读取的问题
修复了Phobos的动画新增语句只支持CreateUnit.Owner不支持MakeInfantryOwner的问题
修复了Limbo单位的AutoDeath忽略所有条件要求的问题
现在如果单位设置为Immune=true或TypeImmune=true则该单位的护盾也不会受到伤害了
修复了可拦截抛射体单位会导致多人游戏崩掉的问题
修复了一堆关于弹头值覆盖护盾重生/自愈的问题
修复了若读取一个使用了DisguiseBlinkingVisibility的存档可能会崩掉的问题
修复了拥有LimboDelivery的建筑不会被正常保存进存档的问题
修复了建筑的ammo pipoffset显示错误的问题
修复了因为退化导致的Crit.Warhead语句无法找到合适的目标引爆
数值显示现在不会再在顶部的底部栏显示了
增加了AltPalette是否跟随光照影响的功能
现在遭遇战初始建筑可以用<Player @ X>（X为A-H）的格式将该建筑直接提供给1-8号玩家而不再需要14号触发结果
修复了AltPalette的动画错误的使用[Colors]的第一个颜色作为所属色的问题。同时动画的影子也不会直接覆盖黑幕了
光照触发的性能现已进一步优化
现在能正常使用禁止单人游戏生成多人游戏RE的SycnLog的功能了
Air和Top的图层动画的YSortAdjust可以正常运作了。附着在空中单位的动画如果和该单位则动画会在单位之上。
DetonateOnAllMapObjects摧毁带有废墟逻辑的建筑时不再会概率性崩掉游戏了
当读带有辐射场的游戏存档时不会再崩溃了
修复了一个因Air或Top图层排序时导致的RE问题
现在所有的单位转换（包括ARES的）可以正确地更新带有OpenTopped标签载具的乘客信息了
PowerUpN建筑动画现在可以使用Powered & PoweredLight/Effect/Special键值
带有Powered/PoweredSpecial建筑动画的建筑在被占领后正常更新
修复了一个导弹目标错误的有关问题
修复了Linux在加载战役地图时偶尔会因为跳过[Header]而导致崩溃的问题
修复了被EMP单位的炮塔旋转/飞行单位晃动的问题
修复了因高度变化而导致设定AmbientDamage且IsRailgun=yes的武器在使用时被切断的问题
修复了因高度变化而导致轨道炮和火焰粒子被切断的问题
修复了超时空单位在重新加载游戏后移动冷却计时器被重置的问题
修复了超时空单位在斜坡上无法正确倾斜的问题
修复了超时空单位和钻地单位无法在视觉上无法被掀翻的问题
修复了步兵单位和工程师/间谍等可进入建筑物的单位利用路径点同时进入建筑物的问题
修复了飞行单位Jumpjet坠毁到建筑物上坠落速度不正确的问题
修复了治疗/修复武器无法治疗/修复父单位，就无法从被护盾保护的目标移除寄生单位的问题
修复了Inviso=true拦截抛射体对拥有护甲类型的被拦截抛射体会造成两次伤害的问题
地图上的激光尾迹现在会被正确重置
没有预设默认值的INI词条现在可以通过将值设置为<none>或<default>来重置到此状态
进一步优化了地图和超级武器的配色
修复了ApplyModifiersOnNegativeDamage无法正常生效的问题
修复了隧道和护盾的交互动画可能会出错的问题
修复了AAOnly无法正常生效的问题
现在禁止将Trajectory的抛射体与其他类型的抛射体(Arcing, ROT等)混用，并在调试日志中输出警告
修复了数字显示可能出现的对齐问题
修复了因过量选择了DeploysInto载具后显示部署光标的概率性RE问题
现在不会再显现打包机动工厂时出现的集结点了
修复了因AutoDeath导致的寄生单位攻击时导致的概率性崩溃问题
修复了Bouncer和IsMeteor动画的ExtraShadow不正常的问题
现在未开启相关设置的话不会在菜单里显示Debug快捷键了
修复了辐射场导致的RE问题
修复了Phobos的渗透逻辑导致Ares的Saboteur逻辑不正常运作的问题
修复了子机导弹影子不正常生成的问题
完成了一些关于显示动画伤害的小优化
修复了ShrapnelWeapon默认情况下只以友军为目标的错误
铁幕中或力场护盾中的物体会正常被染色了
SHP载具、喷气机和建筑无论处于什么图层都可以正常被染色了
Phobos的弹头效果例如护盾，暴击，解除心控/伪装弹头现在需要Verses来正常起效。你也可以设置EffectRequireVerses=false来略过这一项
护盾护甲现在仅会在护盾存在且弹头不能直接穿透护盾时才会启用
数值显示的Offset和Offset.ShieldDelta的Y轴相较于以前，现在已经反过来了（负数上升，正数下降）以和游戏内其他的offset相对应
超大Range武器和超大Cellspread现已经可以正常影响空军了
修复了辐射场不会正常减少辐射等级的问题
修复了激光尾迹不会正常绘制在隐形单位上
修复了因新AE的ExpireWeapon往其持有者添加或删除AE导致的闪退或死机问题
修复了因转换不可Cumulative的AE到新单位上导致的概率性闪退问题
修复了因AI脚本，动作：10104超时空到敌方基地导致的概率性闪退问题
修复了因AdjustTargetCoordsOnRotation=yes的BehavesLike=Fire粒子导致的概率RE
喷气机飞机现在可以正常使用拦截抛射体相关逻辑了
修复了超武的工具提示概率性显示错误的问题
一些代码层面的优化
DecloakToFire=false的单位或建筑现在不会再瞄准和重装阶段现形了
Sensor=yes的单位现在不会使友军建筑现形了
现在有Cellspread的Phobos新弹头效果只要击中建筑的任一占地格即可生效
现在有Cellspread=0的Phobos新弹头效果不会再因为离目标很远且过早地引爆从而影响到目标了
修复了因新AE Groups目标筛选导致的存读档闪退
修复了DisguiseBlinkingVisibility不会正常显示默认的Team值的问题
Debug日志现在能正确的从枚举值列表中声明它未能解析的不合法项目
Dump日志现在可以正常记载单位的目标，即使目标是地板或者抛射体
修复了RevealOnFire从B39开始的问题
解除了抛射体的IsSonic，IsMagBeam和Wave.Is(Big)Laser的硬编码
修复了因地图触发500号和快速存档指令导致的概率性问题
所有种类的转换（包括Ares的）可以重加载MoveSound了
SelfHealGainType的None值已经被替换成noheal，因为None不会被游戏正常地读取
可作用目标（CanTarget，Crit.Affects等）的相关语句现在会将ConsideredVehicle=true和UndeploysInto和Foundation=1x1的建筑视为单位
如果CreateUnit.AlwaysSpawnOnGround=false，则Jumpjet单位生成后会自动起飞。设置成true则会照常停留在地面上
DrawInsignia.AdjustPos.BuildingsAnchor现在不会再有默认值了
OverlayTypes现在可以正常使用ZAdjust了
现在可以在AudioVisual里设置ColorAddUse8BitRGB来让游戏里的ColorAdd使用8BitRGB而不是RGB565。这一项改动也适用与LaserTargetColor, IronCurtainColor, BerserkColor和ForceShieldColor
现在可以设置AI里的EnablePowerSurplus为true来自定义PowerSurplus的值
当开火者和目标都在桥上且有AA=true的武器时，可以正常对空军开火了
修复了当伪装成一个使用了自定义色盘的单位时，伪装单位显示错误色盘的问题
钻地单位不再会在钻地或钻出的时候使用部署功能，现在他们部署时会立刻钻出
修复了Temporal=true的弹头攻击奴隶单位时概率性崩溃的问题
修复了部分Locomotors（Tunnel，Walk，Mech）移动速度过快时概率卡住的问题
现在带有UseNormalLight=false且使用Unit色盘的MakeInfantry动画现在会正常调整光照了
修复了钻地单位在斜坡上钻地时的阴影错误的问题
修复了Shield.Respawn.Amount不会正常使用默认值的问题
修复了frame by frame的热键说明错误的问题
修复了LimboKill不会正常工作的问题
修复了AircraftTypes错误地从默认值的UnitsGainSelfHeal获取自愈能力的问题
修复了Passengers.SyncOwner不会正常工作的问题
修复了由SeparateAircraft=false导致的概率崩溃问题
修复了部分IsPassable=true的地形会错误地让某些不应该同行的载具通过的问题
修复了主弹头被铁幕或力场护盾抵消时ExtraWarheads不会生效的问题
改善了染色相关的代码，避免了部分极端情况下的崩溃
现在Hover Locomotor的IsSimpleDeployer和DeployToLand单位不会在部署的时候卡住或无限的播放部署音效了
所有种类的单位转换（包括Ares的）现在会正常同步超时空传送的僵直了
所有种类的单位转换（包括Ares的）现在会正常同步他们的MoveSound了
RemoveDisguise现在可以正常移除载具的伪装了
修复了辐射场的伤害和辐射指数等级不一致的问题
现在隐形单位的激光尾迹会正常更新位置了
带有Sensors=true的单位不会让友军建筑显形了
移除了带有InfDeath=9的弹头对Jumpjet步兵造成0伤害的特性
修复了残血的飞机无法在UnitReload=true的dock上回血，除非它们先降落到dock上的问题
修复了部分月球地形无法放置建筑物的问题
部分全局地形索引(ShorePieces, WaterSet, CliffSet, WaterCliffs, WaterBridge, BridgeSet，WoodBridgeSet)现在可以正常被月球气候读取。
修复了读档后辐射场计时器的问题
修复了具有AttackFriendlies=true并且以友军为目标的物体(尤其是AI持有的建筑)会在每帧重置目标的问题
修复了 Drive/Jumpjet/Ship/Teleport 的Locomotor在unpiggyback时不能正常激活的问题
现在由EMP超武射出来的武器没有EMPulse.TargetSelf=true的情况下也可以生成辐射场
EMP炮超武发射的武器现在可以完全遵循开火建筑的FLH设置
EMP炮超武发射的武器现在遵循Floater和Phobos添加的Gravity属性设置
Ares的SW.Shots现在也可以正常显示在Phobos的额外工具栏里
修复了Ares的绑架武器在绑架移动单位时产生空气墙的问题
目前Ares的Cellspread机制已经和Phobos保持一致
现在静止浮动的空中单位会被Moving的DiscardOn条件正常识别为移动中
修复了完全友好弹头打在护盾上会触发警报的问题
修复了LaunchSW.IgnoreInhibitors和SW.Next.IgnoreInhibitors会覆盖IgnoreDesignators的问题
修复了FactoryPlant.Allow/Disallow在虚拟投放里不正常生效的问题
修复了FactoryPlant.Multiplier计算错误的问题
Strafing.Shots现在可以正常运用在SpyPlane上
修复了Crit.Animlist和AnimList.CreateAll不正常交互的问题
修复了步兵在水里错误播放SecondaryFire/SecondaryProne序列而不是WetAttack的问题
一些炮塔阴影的修复
修复了Phobos的弹头效果会影响正在被传送的单位的问题
修复了B44的钻地单位的卡住问题
修复了1帧的Scorch和Flamer动画会概率性卡死游戏的问题
使用单位色盘并带有UseNormalLight=false的MakeInfantry动画现在可以被单元格光照变化影响
修复了核弹与心灵支配的光照变化无法影响AircraftTypes的问题
空爆武器产生的抛射体现在会记录武器类型并且可以正常产生辐射等
现在可以用<Player @ X> 为遭遇战和多人地图上预先放置的物体分配所属
地图上预先放置的载具的跟随索引现在被明确限定在地图文件中的[Units]列表，并且不会再被无法创建的载具或者拥有其他载具作为初始乘员的载具抛弃
单位的Speed属性现在可以使用浮点值，内部解析中最大值限制为100，属性值会x256÷100再转换成整数值
，限制最大值为255后输出0-255范围内的有效内部速度值。例如游戏中每帧行进的lepton数。
钻地移动现在可以接受任何来源的速度加成系数，例如VeteranAbilities中的Speed 或AttachEffect效果
在读取标签和特遣部队时抑制了Ares的重排警告（通常以[Developer fatal]指针00000000开头，声明了对两者的更改）


b45更新说明
免责声明：开发版本本质上是不稳定的，可能包含下个稳定版本将更改和调整的部分。
如果要保证稳定性，请使用稳定版本的Phobos。
最新的稳定版本： Release v0.3.0.1 · Phobos-developers/Phobos (github.com) 
之前版本的说明书出现默认值或词条错误的问题，将以红色加粗字样标出。
 
b45已知的Bug： 
1.	Cellspread判定范围异常增大
20400prosperous.ysepan.com/7-1.与Phobos引擎相关的内容 - I这里提供一个仅修复了这个问题的Build45
（其实就是chm说明书发布地址，只不过之前都是藏简介页的文档里了，这次问题有点大所以直接明写在这）
2.	DeployToFire可能会引起多人游戏不同步
正在制作的release0.4与build#46均已修复
3.	使用空投仓时需要将DropPodWeapon定义为具有弹头动画的武器并且定义DropPodPuff，否则会引起Phobos的动画空类型弹窗 


#b16至今未解决bug：单位执行脚本动作16巡逻至路径点时，若目标路径点为序号大于701的phobos扩展路径点，则该单位巡逻发起攻击后不再执行原有脚本导致原地不动。请mapper需要执行巡逻时尽可能使用序号小于701的路径点。
修正和改进的逻辑
动画
动画伤害
Phobos对动画武器/动画弹头逻辑进行了增强。
[Animation]►Damage.DealtByInvoker= (boolean) 
如果设置为true，则任何动画造成的伤害被认为是来自动画的调用者(例如弹头的 AnimList/SplashList被视为来自武器的发射者，DestroyAnim被视为来自被摧毁的单位等)。这不影响弹头造成的伤害作用于哪个所属。默认为no。
[Animation]►Damage.ApplyOncePerLoop= (boolean)
如果设置为true，则每个动画循环中只造成一次伤害，而不是一帧一次或由Damage.Delay定义的间隔。 
 
附加动画位置
现在可以自定义附加动画的位置是否位于对象的实际中心。
[Animation]►UseCenterCoordsIfAttached= (boolean)
动画是否位于对象的实际中心而不是最左上角的单元格。默认no。
 
 
附加动画的图层
现在可以指定动画是否跟随被附加的单位的图层。
[Animation]►Layer.UseObjectLayer= (boolean)
动画是否使用被附加的单位的图层。如果不设置则使用ground图层。
 
 
水动画
[Animation]►ExplodeOnWater= (boolean) 
动画与水是否产生影响，来播放ExpireAnim以及释放动画弹头，以造成伤害或产生闪光。默认no。
[Animation]►Warhead.Detonate= (boolean) 
动画弹头是否完整释放，而不是简单的造成伤害和播放动画。默认no。
[Animation]►WakeAnim= (Animation) 
如果未设置ExplodeOnWater，设定单位在进入或离开水时播放的动画。默认[General]►Wake=。
[Animation]►SplashAnims= (Animation) 
如果未设置ExplodeOnWater，设定水中爆炸的水花动画。默认[General]►SplashList=。
[Animation]►SplashAnims.PickRandom= (boolean) 
如果设置了上个语句，是否随机播放其中的动画。设置为no则只会播放最后一个动画。默认no。
 
独立播放声音
默认情况下，动画的Report/StartSound是由音频事件处理程序播放的(声音会在对应位置循环播放，即便动画后续发生了变化)
但因为当动画重新播放时音频事件处理程序会重置，故可能会导致通过Next关联的动画出现问题。
[Animation]►DetachedReport= (sound entry) 
令动画独立播放未经音频事件处理程序的声音。
建筑
能否被空袭
默认情况下，建筑物是否可以成为空袭目标取决于 CanC4= 。现在可以独立设定。如果未设置，默认为 CanC4=。 
[BuildingType]►AllowAirstrike= (boolean)
建筑物是否可以成为空袭目标。默认CanC4=。
 
被视为载具
默认情况下，游戏将设定UndeploysInto和Foundation=1x1的建筑都视为载具。现在可以单独设定。 
例如，这些建筑被攻击或被占领时将不会播报EVA。 
[BuildingType]►ConsideredVehicle= (boolean)
这个建筑是否被视为是载具。
 
自定义与扩展部队回收站属性
[BuildingType]►Grinding.AllowAllies= (boolean)
友军单位是否也可以进入此建筑。默认no。
[BuildingType]►Grinding.AllowOwner= (boolean)
己方单位是否可以进入此建筑。默认yes。
[BuildingType]►Grinding.AllowTypes= (List of InfantryTypes / VehicleTypes)
可以用于定义何种单位可以被回收。一旦列出，所有未被列出的单位不可被回收。
[BuildingType]►Grinding.DisallowTypes= (List of InfantryTypes / VehicleTypes)
定义何种单位不可以被回收。
[BuildingType]►Grinding.PlayDieSound= (boolean)
是否在回收单位时，播放单位的死亡音效。默认yes。
[BuildingType]►Grinding.Sound= (boolean)
定义回收音效，默认为[AudioVisual]►EnterGrinderSound。
[BuildingType]►Grinding.Weapon= (Weapon)
当此建筑回收单位时，建筑向自身开火的武器，遵循ROF设定。
[BuildingType]►Grinding.Weapon.RequiredCredits= (integer)
回收单位开火Grinding.Weapon=指定的武器所需的资金，默认0。该资金数目会累计，直至武器开火后重置。
b36移除：
[BuildingType]►Grinding.DisplayRefund= (boolean) 
是否在回收时显示获得的资金。默认no。
[BuildingType]►Grinding.DisplayRefund.Houses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
回收显示的资金可以被哪些对象看到。默认all。
[BuildingType]►Grinding.DisplayRefund.Offset= (X,Y)
调整回收显示资金的绘制偏移。负数左/上，正数右/下。默认0,0。
 
自定义建筑出售的动画序列
默认默认情况下，UndeploysInto的建筑在被出售时，只会依据序列播放23帧的出售动画(从最后一帧开始) 。 现在可以自定义。
[BuildingType]►SellBuildupLength= (integer)
建筑被出售时播放动画序列的帧数。
 
 
 

自定义建筑提供的自愈效果
现在可以自定义单位受到建筑提供的自愈类型和自愈效果了。
[General]►InfantryGainSelfHealCap= (integer)
步兵类型的自愈一次最多可以在多少单位上生效，必须设置1或更大的值。
[General]►UnitsGainSelfHealCap= (integer)
同上，不过用于载具类型的自愈。
 
[General]►GainSelfHealAllowMultiplayPassive= (boolean)
若设置为true，某一所属方设置为MultiplayPassive=true时，则该所属方可以享受所有自愈效果
 
[AudioVisual]►Pips.SelfHeal.Infantry= (integer)
填数字，用pips文件内的哪两帧分别作为步兵受到步兵类自愈和载具类自愈的图像。默认13,20。
[AudioVisual]►Pips.SelfHeal.Units= (integer)
同上，不过用于载具。
[AudioVisual]►Pips.SelfHeal.Buildings= (integer)
同上，不过用于建筑。
[AudioVisual]►Pips.SelfHeal.Infantry.Offset= (X,Y)
步兵自愈图像的位置偏移，负数左/上，正数右/下。默认25,-35。
[AudioVisual]►Pips.SelfHeal.Units.Offset= (X,Y)
同上，不过用于载具。默认33,-32。
[AudioVisual]►Pips.SelfHeal.Buildings.Offset= (integer)
同上，不过用于建筑。默认15,10。

 
[TechnoType]►SelfHealGainType= (enum noheal|infantry|units)
受到的自愈类型。步兵默认infantry，载具默认units，建筑默认noheal。
 
自定义建筑是否提供多工厂加成
现在可以自定义Factory建筑是否提供MultipleFactory的建造速度加成
[BuildingType]►ExcludeFromMultipleFactoryBonus= (boolean)
定义该建筑是否不提供多工厂加成，默认false。
 
自定义建筑是否提供工业工厂效果
现在可以自定义FactoryPlant建筑是否可以单独应用在部分单位上
[BuildingType]►FactoryPlant.AllowTypes= (list of Technotypes)
定义该工业工厂提供这些单位的造价优惠。
[BuildingType]►FactoryPlant.DisallowTypes= (list of Technotypes)
定义该工业工厂不提供这些单位的造价优惠。
子机
建筑断电子机坠毁
[BuildingType]►Powered.KillSpawns= (boolean)
需要供电的建筑类子机发射者是否在断电时停止瞄准敌人，而飞行中的子机将会直接坠毁。默认no。
飞行器
固定距离高度的空袭/侦察机 
现在可以固定空袭机或侦察机的生成距离和生成高度
[AircraftType]►SpawnDistanceFromTarget= (double) 
定义该飞机从距离目标多远的地方生成，而不是地图边界
[AircraftType]►SpawnHeight= (integer)
定义该飞机飞行在什么高度，覆盖[General]里的FlightLevel
 
自定义着陆朝向
现在可以为每个飞机自定义其着陆朝向。
你也可以通过给AirportBound=false的飞机设定负值来使它以当前的方向着陆。
[AircraftTypes]►LandingDir= (integers from 0-255) 
该飞机的着陆朝向，默认 [AudioVisual]->PoseDir=。
[BuildingTypes]►LandingDirN= (integers from 0-255)
该机场第N个停靠位的飞机着陆朝向，N为从0开始的机场停靠位的索引( LandingDir等效于 LandingDir0)，后置停靠位不写则默认为 LandingDir0。默认[AudioVisual]->PoseDir=。
覆盖飞机的 LandingDir= 。
 
吊运声音
在Carryall=yes的飞行器吊运载具时，拾起载具会播放VoiceMove指定的声音，现在可以单独指定。
[AircraftTypes]►VoicePickup= (Sound) 
飞行器拾起要吊运的载具时播放的声音。
铁幕
铁幕对有机单位的影响
 
在原版和尤复中，当对步兵和巨型乌贼等有机单位施加铁幕时，它们会立即被C4Warhead杀死。现在铁幕效果可以自行选择。

[CombatDamage]►IronCurtain.EffectOnOrganics= (kill | invulnerable | ignore)
设定铁幕对有机单位的影响。设定为kill会杀死有机单位，invulnerable会使得有机单位如同载具和建筑那样享受铁幕效果而无敌，ignore会忽略有机单位而不对其造成任何影响。默认kill。
[CombatDamage]►KillOrganicsWarhead= (integer)
指定铁幕在杀死有机单位时使用的弹头。默认[CombatDamage]►C4Warhead
 
[TechnoType]►IronCurtain.Effect= (kill | invulnerable | ignore)
单独设定铁幕对有机单位的影响。默认kill。
[TechnoType]►IronCurtain.KillWarhead= (integer)
单独指定铁幕在杀死有机单位时使用的弹头。默认[CombatDamage]►C4Warhead
 
铁幕和护盾立场的染色强度
 
现在可以单独设置被铁幕和护盾立场罩住的单位时的染色强度了

 
[AudioVisual]►IronCurtain.ExtraTintIntensity= (float)
设定铁幕对单位的染色强度。
[AudioVisual]►ForceShield.ExtraTintIntensity= (float)
设定护盾立场对单位的染色强度。
 
部署和反部署时继承铁幕
现在设定载具在部署成建筑或从建筑反部署时继承受到的铁幕效果了。
[CombatDamage]►IronCurtain.KeptOnDeploy= (boolean)
载具是否在部署为建筑和从建筑反部署时继承铁幕效果。默认yes。
[TechnoType]►IronCurtain.KeptOnDeploy= (boolean)
微观设定载具是否在部署为建筑和从建筑反部署时继承铁幕效果。
超时空
被时空转移动画与实例的延迟
现在可以自定义被时空转移的动画[General]►ChronoSparkle1与实例的延迟。
[General]►ChronoSparkleDisplayDelay= (integer, game frames) 
被时空转移播放的动画与实例的延迟帧数。默认24。
[General]►ChronoSparkleBuildingDisplayPositions= (enum building | occupants | occupantslots | all)) 
建筑被时空转移时播放的动画位置。默认occupantslots。
 
 
自定义超时空属性
现在全局中的超时空属性可以在每个单位中微观定义，默认均为对应的全局标签，仅对拥有Teleport/Chrono运动模式的单位有效。
[TechnoType]►WarpOut= (string, animation ID)
超时空移动走的动画。
[TechnoType]►WarpIn= (string, animation ID)
超时空移动来的动画。
[TechnoType]►WarpAway= (string, animation ID) 
被超时空武器抹除的动画。
[TechnoType]►ChronoTrigger= (boolean)
超时空移动的冷却是否和距离相关。如果为否则冷却时间为一个常量。
[TechnoType]►ChronoDistanceFactor= (integer)
超时空移动冷却的距离因数。
[TechnoType]►ChronoMinimumDelay= (integer) 
超时空移动的最短冷却时间。
[TechnoType]►ChronoRangeMinimum= (integer) 
计算超时空移动冷却时间的最短距离。
[TechnoType]►ChronoDelay= (integer)
被超时空传送后的冷却时间。
 
自定义被时空转移前后的单位硬直
现在可以自定义被时空转移前后的单位硬直。
[General]►ChronoSphereDelay= (integer, game frames) 
全局定义被时空转移后的单位硬直，默认60。
[General]►ChronoSpherePreDelay= (integer, game frames) 
全局定义被时空转移前的单位硬直，默认0。
[Technotype]►ChronoSphereDelay= (integer, game frames) 
单独定义该单位被时空转移后的硬直。
[Technotype]►ChronoSpherePreDelay= (integer, game frames) 
单独定义该单位被时空转移后的硬直。
地形
地形对象的摧毁音效和动画
现在可以指定地形对象被摧毁时的动画和音效了。 
[TerrainType]►DestroyAnim= (string, animation ID)
地形对象被摧毁时播放的动画。
[TerrainType]►DestroySound= (Sound)
地形对象被摧毁时播放的音效。

自定义小地图颜色
地形对象和矿石现在可以在小地图上显示不同的颜色。 
[TerrainType]►MinimapColor= (R,G,B)
地形对象或矿石在小地图上显示的颜色。

可通行的地形对象
现在可以指定地形对象是否可通行了。 
[TerrainType]►IsPassable= (boolean)
地形对象是否可以通行。默认no。
[TerrainType]►CanBeBuiltOn= (boolean)
地形对象上是否可建造建筑。当建筑建造于地形上时地形会自动消失。默认no。
 
可自定义色盘的地形对象
现在可以自定义地形对象的色盘了。 
在artmd.ini
[TerrainType]►Palette= (filename - excluding .pal extension and three-character theater-specific suffix)
地形对象的色盘。
 
损伤帧和的可“倒塌”的地形对象
默认情况下，游戏仅显示仅剩1点生命值时的地形对线的的损伤帧。因为WW也没想到还有这种操作.jpg，现在可以使用新的语句HasDamagedFrames来拓展这一部分。
默认情况下地形对象的损伤帧会取ConditionYellow的值，你可以额外设置ConditionYellow.Terrain。
另外，地形对象也可以播放“倒塌”动画了。就像埃菲尔铁塔那样，生命值归零后，在完全从游戏删除前播放的动画。只要设置HasCrumblingFrames=true。
“倒塌”动画的帧紧跟在常规帧和损伤帧之后。
CrumblingSound会和“倒塌”动画一起播放。
摧毁动画和摧毁音效会在“倒塌”动画之后播放。
 
[AudioVisual]►ConditionYellow.Terrain= (float)
地形对象低于多少血为黄血状态。
[TerrainType]►HasDamagedFrames= (boolean)
地形对象是否拥有损伤帧。
[TerrainType]►HasCrumblingFrames= (boolean)
地形对象是否拥有倒塌帧。
[TerrainType]►CrumblingSound= (sound entry)
地形对象倒塌时播放的音效
矿石
自定义采矿动画
现在可以自定义矿车的在不同矿石上的采矿动画了。
[TechnoType]►OreGathering.Anims= (list of Animation)
矿车采矿的动画。
[TechnoType]►OreGathering.FramesPerDir= (list of integers)
每个采矿动画对应的帧数。默认15。
[TechnoType]►OreGathering.Tiberiums= (list of integers)
填矿石的ID，每个采矿动画对应的矿石。默认0。

自定义矿柱
现在可以指定矿柱的地形对象生成矿石的相关内容了。 
[TerrainType]►SpawnsTiberium.Type= (integer)
填矿石的ID，矿柱生成矿石的种类。默认0。
[TerrainType]►SpawnsTiberium.Range= (integer)
矿石生成的半径。默认1。
[TerrainType]►SpawnsTiberium.GrowthStage= (integer)
生成矿石的生长阶段。如果写多个值则会在其中随机选取生成。默认3。
[TerrainType]►SpawnsTiberium.CellsPerAnim= (integer)
矿石生成动画周期中会填充多少单元格。如果写多个值则会在其中随机选取填充。默认1。

自定义存矿
现在Ares的Storage逻辑可以指定可以存储哪种矿物类型。 
[General]►Storage.TiberiumIndex= (integer)
填矿石的ID，矿井储藏的矿石类型。默认-1。此标签无Ares无法使用。
 
可根据矿石阶段下限的HideIfNoOre
现在可以定义有矿石的单元格在矿石的什么阶段才会播放HideIfNoOre了。
[Animation]►HideIfNoOre.Threshold= (integer) 
播放HideIfNoOre的最小矿石阶段。默认0。
自定义爆炸行为
默认情况下Explodes=yes的单位在被摧毁时会杀死所有乘客。这种行为现在可以通过设置下面的语句来避免
[TechnoType]►Explodes.KillPassengers= (boolean)
单位爆炸时是否会杀死其中的乘客。默认true。
 
默认情况下建筑在播放Buildup动画的过程中(包含建立和售卖)也会被摧毁而发生爆炸。这种行为现在可以通过设置下面的语句来避免
[BuildingType]►Explodes.DuringBuildup= (boolean)
建筑在建造和售卖时是否会发生爆炸。默认true。
改进的脚本
寻找攻击目标
默认情况下，任何非AircraftType单位通过脚本动作0(或Phobos中引入的常规目标类型攻击行为脚本)寻找攻击目标时，会检查目标与单位是否处在同一地图区域，以便能够选择其作为目标。
现在可以自定义，允许对象无约束的从任何地图区域(TargetZoneScanType=any)寻找目标，或只在武器范围内(TargetZoneScanType=inrange)寻找。
[TechnoType]►TargetZoneScanType= (enum same|any|inrange)
自定义单位寻找攻击目标的范围。默认same。
单位在art中引用图像
art中的Image不再限定于动画和建筑使用，全部的科技类型都可以使用。此功能支持步兵使用SHP，飞机使用VXL，载具使用SHP和VXL。
在rulesmd.ini中：
[General]►ArtImageSwap= (boolean)
是否启用这个功能。默认no。
artmd.ini中：
[TechnoType]►Image= (filename, *excluding*the .vxl or .shp extension)
用作模型的文件名。此标签仅指定文件名（不含拓展名）。若有同名节存在，节内内容不会被读取。
扩展AI克隆生产

现在可以单独设置AI可以克隆生产的类型了。为了防止冲突，需要设置Ares标签AllowParallelAIQueues=yes才会生效。

[GlobalControls]►ForbidParallelAIQueues.Infantry= (boolean)
是否允许AI克隆生产步兵。默认no。
[GlobalControls]►ForbidParallelAIQueues.Vehicle= (boolean)
是否允许AI克隆生产载具。默认no。
[GlobalControls]►ForbidParallelAIQueues.Navy= (boolean)
是否允许AI克隆生产海军。默认no。
[GlobalControls]►ForbidParallelAIQueues.Aircraft= (boolean)
是否允许AI克隆生产飞行器。默认no。
[GlobalControls]►ForbidParallelAIQueues.Building= (boolean)
是否允许AI克隆生产建筑。默认no。
 
 
[TechnoType]►ForbidParallelAIQueues= (boolean)
是否允许AI克隆该单位，默认false。
载具部署方向和动画
现在对于单位部署有更多标签可以进行调整了。

[TechnoType]►DeployingAnim.AllowAnyDirection= (boolean)
禁用一切由DeployingAnim导致的方向限制。仅对地面单位有效。
[TechnoType]►DeployingAnim.KeepUnitVisible= (boolean)
部署动画播放期间是否使单位持续可见。默认no。
[TechnoType]►DeployingAnim.ReverseForUndeploy= (boolean)
反部署时是否反向播放部署动画。默认yes。
[TechnoType]►DeployingAnim.UseUnitDrawer= (boolean)
部署动画是否使用单位色盘和所属色。默认yes。
限制箱子只出现陆地
一些关于箱子的新改动
改善了箱子的生成方式，现在会在可见范围内更加均匀分别
 
[CrateRules]►CrateOnlyOnLand= (boolean)
箱子是否限制只出现在陆地上。默认no。
[CrateRules]►UnitCrateVehicleCap= (interger)
自定义开出多少载具后载具箱才会开始开出金钱。负数表示无上限。
[CrateRules]►FreeMCV.CreditsThreshold= (interger)
定义金钱达到多少才可以开出FreeMCV里的载具。默认1500。
[VehicleTypes]►CrateGoodie.RerollChance= (float)
定义CrateGoodie=true的载具每次开出来后是否会再次重新变化。（roll到A载具后有多大概率变成另外的CrateGoodie=true载具）
自定义军衔
现在可以自定义单位军衔的更多效果
 
[General]►EnemyInsignia= (boolean)
全局控制是否对敌军显示军衔，默认true。 
 
[AudioVisual]►DrawInsignia.OnlyOnSelectd= (boolean)
军衔是否只在被选中的时候显示，默认false。 
[AudioVisual]►DrawInsignia.AdjustPos.Infantry= (X, Y)
Infantry单位的军衔显示偏移，默认5，2。 
[AudioVisual]►DrawInsignia.AdjustPos.Units= (X, Y)
Units单位的军衔显示偏移，默认10，6。 
[AudioVisual]►DrawInsignia.AdjustPos.Buildings= (X, Y)
Buildings的军衔显示偏移，默认10，6。 
[AudioVisual]►DrawInsignia.AdjustPos.BuildingsAnchor= (enum top|lefttop|leftbottom|bottom|rightbottom|righttop)
Buildings的军衔对齐位置，默认不对齐。 
 
 
Gunner=yes的单位可以随着炮台的变化来变化军衔。
[TechnoType]►Insignia.WeaponN= (filename - excluding the .shp extension)
使用第N个炮台时单位的军衔图标。 
[TechnoType]►Insignia.WeaponN.Rookie= (filename - excluding the .shp extension)
使用第N个炮台时新兵级单位的军衔图标。 
[TechnoType]►Insignia.WeaponN.Veteran= (filename - excluding the .shp extension)
使用第N个炮台时老兵级单位的军衔图标。 
[TechnoType]►Insignia.WeaponN.Elite= (filename - excluding the .shp extension)
使用第N个炮台时精英级单位的军衔图标。 
   
[TechnoType]►InsigniaFrame.WeaponN= (integer - frame index) 
[TechnoType]►InsigniaFrame.WeaponN.Rookie= (integer - frame index) 
[TechnoType]►InsigniaFrame.WeaponN.Veteran= (integer - frame index) 
[TechnoType]►InsigniaFrame.WeaponN.Elite= (integer - frame index)  
从军衔中使用的帧。设置-1来使用默认帧。默认-1。 

[TechnoType]►InsigniaFrames.WeaponN= (integer - frame index)  
总体设定新兵、老兵和精英级单位从军衔中使用的帧。默认-1,-1,-1。 
 
[TechnoType]►Insignia.ShowEnemy= (boolean)
单独控制该单位的军衔是否对敌军显示，默认EnemyInsignia。 
Jumpjet单位的修复
[JumpjetControls]►NoWobbles= (boolean)
Jumpjet是否会上下摆动。默认no。 
 
稳定方向坠毁
原版中，Jumpjet类单位会在坠毁时随意改变方向，胡乱旋转。
现在可以自定义是否旋转。
[TechnoType]►JumpjetRotateOnCrash= (boolean) 
Jumpjet单位是否会旋转坠毁，默认yes。 
自定义范围指示圆弧的可见性
在原版和尤复中，只有建筑的所属方可以看到建筑的范围指示圆弧(一般为攻击范围)。现可以指定它对其他所属方的可见性。
[AudioVisual]►RadialIndicatorVisibility= (enum owner/self | allies/ally | enemies/enemy | all)
指定哪些所属方可以看到武器范围指示圆弧。默认allies。
碾压倾斜
在原版中，具有Crusher=true和OmniCrusher=true / MovementZone=CrusherAll的车辆在碾压车辆或围墙时会固定倾斜。
现在可以定义。
[VehicleType]►TiltsWhenCrushes.Vehicles= (boolean) 
碾压车辆时是否会倾斜。
[VehicleType]►TiltsWhenCrushes.Overlays= (boolean) 
碾压围墙等覆盖物时是否会倾斜。
[VehicleType]►CrushForwardTiltPerFrame= (float) 
碾压围墙等覆盖物时造成倾斜时，每帧向前倾斜多少。碾压覆盖物时默认为-0.02，其他情况默认-0.050000001。
VXL阴影
炮塔阴影
现在也可以单独为车辆VXL炮塔绘制阴影。
在rulesmd.ini中：
[AudioVisual]►DrawTurretShadow= (boolean) 
是否启用绘制VXL炮塔阴影。 
在artmd.ini中：
[TechnoType]►TurretShadow= (boolean) 
微观定义，该单位是否绘制VXL炮塔阴影。覆盖 [AudioVisual]►DrawTurretShadow=。 
 
多部分阴影
载具和飞行器现在也可以同时显示多个部分的阴影，而不仅仅是由ShadowIndex=指定的一个部分。
在artmd.ini中：
[TechnoType]►ShadowIndices= (list of integers) 
绘制的阴影部分。 填写值为体素的截面索引。
[TechnoType]►ShadowIndex.Frame= (integer) 
定义来自ShadowIndex部分的HVA动画的哪一帧用于显示阴影。默认0。
[TechnoType]►ShadowIndices.Frame= (list of integers) 
定义来自ShadowIndices的部分的HVA动画的哪一帧用于显示阴影 。 默认-1，表示当前显示的帧。 
 
缩放阴影
现在可以调整空中VXL单位的阴影的大小。
在rulesmd.ini中：
宏观设定：
[AudioVisual]►AirShadowBaseScale= (double) 
空中VXL单位阴影的缩放比例 。默认0.5。
[AudioVisual]►HeightShadowScaling= (boolean) 
是否根据高度以不同比例缩放阴影。默认false。
如果设置为true，则以以下公式计算阴影的缩放比例： 
Max(AirShadowBaseScale ^ (当前高度/ 最大飞行高度), HeightShadowScaling.MinScale ) 
最大飞行高度指JumpjetHeight=, FlightLevel= 等。
[AudioVisual]►HeightShadowScaling.MinScale= (double) 
HeightShadowScaling=true时，设定最小的阴影缩放比例 。默认0.0。 
自定义VXL光照方向
现在可以定义空中单位受到光照等级的影响程度。
[AudioVisual]►AircraftLevelLightMultiplier=(float-percents)
定义Aircraft单位的光照等级加成系数，默认0.05。
[AudioVisual]►JumpjetLevelLightMultiplier=(float-percents)
定义Jumpjet单位的光照等级加成系数，默认0.0。
自定义PipScale
[AudioVisual]►Pips.Generic.Size= (X,Y)
单位(一般)格子的大小。默认4,0。 
[AudioVisual]►Pips.Generic.Buildings.Size= (X,Y)
建筑(一般)格子的大小。默认4,2。 
[AudioVisual]►Pips.Ammo.Size= (X,Y) 
单位弹药格子的大小。默认4,0。 
[AudioVisual]►Pips.Ammo.Buildings.Size= (X,Y)
建筑弹药格子的大小。 默认4,2。 
 
现在可以自定义弹药格子和一般格子的样式 
pips文件名为“pips.shp”和“pips2.shp”，可行的值为0到总帧数-1，如果为无效值将会IE。 
[TechnoType]►AmmoPipFrame= (integer)
用pips文件内的哪一帧作为弹药的格子样式。默认13。
 
[TechnoType]►EmptyAmmoPipFrame= (integer)
用pips文件内的哪一帧作为空弹药的格子样式。默认-1。 
[TechnoType]►PipWrapAmmoPipFrame= (integer) 
用pips文件内的哪一帧作为一般格子样式。默认14。 
[TechnoType]►AmmoPipSize= (X,Y)
微观定义单位弹药格子的大小。覆盖[AudioVisual]►Pips.Ammo.Size。
[TechnoType]►AmmoPipOffset= (X,Y) 
定义单位的弹药格子的偏移。
 
现在可以也自定义子机格子
[TechnoType]►ShowSpawnsPips= (boolean)
决定是否展现出单位的子机格，独立于PipScale，默认是。
[TechnoType]►SpawnsPipFrame= (integer)
用pips文件内的哪一帧作为子机的格子样式。默认1。
[TechnoType]►EmptySpawnsPipFrame= (integer)
用pips文件内的哪一帧作为空子机的格子样式。默认0。
[TechnoType]►SpawnsPipSize= (X,Y)
微观定义单位子机格子的大小。覆盖[AudioVisual]►Pips.Generic.(buildings.)Size。
[TechnoType]►SpawnsPipOffset= (X,Y)
定义单位的子机格子的偏移。
 
现在可以也自定义矿石格子
[AudioVisual]►Pips.Tiberiums.Frames= (integer)
用pips文件的哪四帧作为矿石的格子样式
[AudioVisual]►Pips.Tiberiums.DsiplayOrder= (integer)
自定义矿石以何种顺序排列在格子里显现，任何没排列的矿石将会排在排过列的矿石之后
粒子系统
默认情况下，如果创建粒子系统的单位(例如武器开火)在旋转，那么BehavesLike=Fire的粒子系统会改变它们的目标坐标。现在这种行为可以自定义。
[ParticleSystemType]►AdjustTargetCoordsOnRotation= (boolean) 
火焰粒子系统是否会改变它们的目标坐标。
 
现在可以自定义BehavesLike=Gas的粒子系统的漂浮速度。
[ParticleSystemType]►Gas.MaxDriftSpeed= (integer) 
气体粒子系统的漂浮速度。默认2。(TS默认为5)
自定义空降仓
[InfantryTypes]►DropPod.Angle= (double) 
空降仓下降角度，默认[General]►DropPodAngle= 。
[InfantryTypes]►DropPod.AtmosphereEntry= (Animation) 
空降仓动画，默认[AudioVisual]►AtmosphereEntry= 。
[InfantryTypes]►DropPod.GroundAnim= (Animation,Animation) 
空降仓落地时的动画，默认[General]►DropPod= 。
[InfantryTypes]►DropPod.AirImage= (SHP file) 
空降仓在空中时的图像，默认POD。
[InfantryTypes]►DropPod.Height= (integer) 
空降仓高度，默认[General]►DropPodHeight= 。
[InfantryTypes]►DropPod.Puff= (Animation) 
空降仓烟雾，默认[General]►DropPodPuff= 。
[InfantryTypes]►DropPod.Speed= (integer) 
空降仓速度，默认[General]►DropPodSpeed= 。空降仓速度不得小于当前高度/10+2(原因不明)，过小的速度将会导致其指数级减速。 
[InfantryTypes]►DropPod.Trailer= (Animation) 
空降仓尾迹，默认[General]►DropPodTrailer=SMOKEY。默认情况下，空降仓上步兵的激光尾迹LaserTrails将不会再绘制。你可以通过设置此项来重新设置激光尾迹。
[InfantryTypes]►DropPod.Trailer.Attached= (boolean) 
空降仓是否附加尾迹。默认no。
[InfantryTypes]►DropPod.Trailer.SpawnDelay= (integer, game frames) 
空降仓尾烟DropPod.Trailer= 的刷出间隔，默认6。
[InfantryTypes]►DropPod.Weapon= (WeaponType) 
空降仓武器，默认[General]►DropPodWeapon= 。
[InfantryTypes]►DropPod.Weapon.HitLandOnly= (boolean) 
空降仓武器是否仅在硬着陆时发射，默认no。
泰伯利亚藤蔓洞
其核心参数依旧需要在[General]中定义，攻击弹头则在[CombatDamage]中定义，攻击动画在[AudioVisual]中定义。
泰伯利亚藤蔓洞被硬编码为覆盖物(Overlay)类型，泰伯利亚藤蔓洞洞口则是以地形对象(TerrainType)表示。
注意：下面列出的所有功能都与泰伯利亚之日一致。泰伯利亚之日的许多语句现已重新启用。以下值与TS和YR rules中的值相同。
你可以在ModENC上了解更多相关信息。
 
在rulesmd.ini中：
[General]►VeinholeGrowthRate= (integer - seconds) 
泰伯利亚藤蔓洞的生长速率，即每两次生长之间的延迟。以秒为单位。默认300。
[General]►VeinholeShrinkRate= (integer - seconds) 
泰伯利亚藤蔓洞洞口被摧毁后，泰伯利亚藤蔓洞的收缩速率，即两次收缩之间的延迟。默认100。
[General]►MaxVeinholeGrowth= (integer) 
泰伯利亚藤蔓洞的最大生长范围。单位为单元格。默认2000。
[General]►VeinDamage= (integer) 
未设置ImmuneToVeins=yes的单位穿过泰伯利亚矿洞时受到的伤害。伤害弹头需要在[CombatDamage]VeinholeWarhead=中定义。
[General]►VeinholeTypeClass= (TerrainType) 
泰伯利亚藤蔓洞的地形对象类型。默认VEINTREE。
 
[CombatDamage]►VeinholeWarhead= (Warhead) 
泰伯利亚藤蔓造成伤害的弹头。默认VeinholeWH。必须在[Warheads] 中注册。
 
[Warhead]►Veinhole= (boolean) 
该弹头是否为泰伯利亚藤蔓伤害的弹头。[VeinholeWH]默认yes。设置为yes则无法影响ImmuneToVeins=yes的单位。
 
[AudioVisual]►VeinAttack= (Animation) 
泰伯利亚藤蔓洞洞口发动攻击时的攻击动画。默认VEINATAC。必须在[Animations]中注册。
 
[TechnoType]►VeteranAbilities=VEIN_PROOF
设定单位在老兵级后免疫泰伯利亚藤蔓伤害。 
[TechnoType]►EliteAbilities=VEIN_PROOF 
设定单位在精英级后免疫泰伯利亚藤蔓伤害。
[TechnoType]►ImmuneToVeins= (boolean) 
单位是否免疫泰伯利亚藤蔓伤害。默认yes。
 
[TerrainType]►IsVeinhole= (boolean) 
设定该地形对象是否为泰伯利亚藤蔓洞。[VEINTREE] 默认yes。
[TerrainType]►Strength= (integer) 
设定泰伯利亚藤蔓洞的耐久度。[VEINTREE] 默认1000。
 
为保证泰伯利亚藤蔓洞的正常运作，你需要检查覆盖物注册表中是否有以下项目：
在rulesmd.ini中:
[OverlayTypes]
126=VEINS                     ; The veins (weeds)
167=VEINHOLE                  ; The Veinhole itself
178=VEINHOLEDUMMY             ; A technical overlay            
泰伯利亚藤蔓
Weeder=yes的载具可以采集泰伯利亚藤蔓，然后运输并储存到Weeder=yes的建筑中。
泰伯利亚藤蔓采集者可以像矿车采集矿石一样，在采集泰伯利亚藤蔓时播放采集动画。同样也可以像超时空矿车一样使用超时空移动。
[VehicleTypes]►Weeder= (boolean) 
该单位是否可以采集泰伯利亚藤蔓。
[BuildingTypes]►Weeder= (boolean) 
该建筑物是否可以用来存储泰伯利亚藤蔓。
注意：泰伯利亚藤蔓并非储存到单个建筑中，而是储存归所属方所有，所属方的泰伯利亚藤蔓容量由[General]►WeedCapacity=定义。
 
超级武器可以消耗存储的泰伯利亚藤蔓进行充能，类似泰伯利亚中的化学导弹。
[SuperWeaponTypes]►UseWeeds= (boolean) 
该超级武器是否可以利用泰伯利亚藤蔓进行充能。默认no。
[SuperWeaponTypes]►UseWeeds.Amount= (integer) 
消耗多少泰伯利亚藤蔓。默认[General]►WeedCapacity=。
[SuperWeaponTypes]►UseWeeds.StorageTimer= (boolean) 
是否在侧边栏的计时器显示泰伯利亚藤蔓的存储百分比。默认no。
[SuperWeaponTypes]►UseWeeds.ReadinessAnimationPercentage= (double) 
当泰伯利亚藤蔓的储存占比达到多少时，超级武器建筑播放准备就绪的动画。填写0~1之间的小数。默认0.9。
注意：由于化学导弹的代码已经被删除，因此超级武器设置Type=ChemMissile无效。
自定义踢出乘客
现在可以自定义Aircraft单位开火时是否踢出自身载员
[WeaponTypes]►KickOutPassengers= (boolean)
 自定义使用该武器的Aircraft开火时是否踢出自身载员，默认是。
自定义水域动画
现在可以自定义单位在水域里的各种动画
[TechnoType]►Wake= (Animation)
 自定义单位的水上尾迹动画，默认为[General]►Wake。
[TechnoType]►Wake.Grapple= (Animation)
 自定义单位在水域上被寄生的动画，默认为[General]►Wake。
[TechnoType]►Wake.Sinking= (Animation)
 自定义单位在水域上沉没的动画，默认为[General]►Wake。
自定义维修厂
现在可以自定义拥有UnitRepair=true, UnitReload=true或Hospital=true
功能的建筑的单位维修效果。
[BuildingTypes]►Units.RepairRate=(float - ingame minutes)
定义维修单位时的维修速度。
对于UnitReload=true建筑默认为[General]>ReloadRate。
对于UnitRepair=true建筑默认为[General]>URepairRate。
Ares允许AircraftType单独定义ReloadRate，定义Units.RepairRate会覆盖该设置。
在UnitReload=true建筑上定义负值会禁用该建筑的单位维修效果。
[BuildingTypes]►Units.RepairStep=(integer)
定义每次维修恢复多少血量，默认[General]>RepairStep。
[BuildingTypes]►Units.RepairPercent=(float-percents)
定义维修成本的加成系数，维修成本=(单位价格/(血量上限/维修回血量))
默认为[General]>RepairPercent。如果最终成本小于1则会当做1计入。
[BuildingTypes]►Units.UseRepairCost=(boolean)
定义是否应用维修成本，步兵默认没有维修成本，其他单位默认有。
自定义钻地单位的钻地高度与速度
现在可以全局或微观定义具有subterranean(Tunnel)的Locomotor
的单位钻地时的高度和速度。
单位的垂直钻地移动速度不受影响，该速度由单位Speed与[General]►TunnelSpeed决定


[General]►SubterraneanHeight= (integer,leptons)
全局定义钻地单位的钻地高度，默认-256。
[General]►SubterraneanSpeed=(float)
全局定义单位钻地移动的水平速度，默认7.5。
[TechnoType]►SubterraneanHeight= (integer,leptons)
自定义钻地单位的钻地高度，默认取全局值。
[Techno]►SubterraneanSpeed=(float)
自定义单位钻地移动的水平速度，若为负数值则取全局值。默认-1。



注意：钻地高度应取负数值，若大于-50则可能会出现问题。
遭遇战AI硬编码解码
默认情况下，遭遇战里的AI行为有一些硬编码。当AI没有任何生产线同时一段时间内没有受到伤害，则AI会卖掉所有建筑并发起万岁冲锋，现在可以针对这一项自定义了
[General]►AIFireSale= (boolean) 
AI是否会卖家。默认true。
[General]►AIFireSaleDelay= (interger) 
AI达到卖家条件后隔这么多帧才会开始卖家。
[General]►AIAllToHunt= (boolean) 
AI是否会万岁冲锋。
[General]►GatherWhenMCVDeploy= (interger) 
AI重部署MCV时是否会集结部队。
烧焦和火焰喷射器动画增强
在TS中凝固汽油弹等火焰效果可以由[AudioVisual]►SmallFire和
[AudioVisual]►LargeFire定义Scorch=true和Flamer=true的火焰动画，
这一逻辑已进行重制并且支持自定义。


在 artmd.ini 中：

[Animation]►ConstrainFireAnimsToCellSpots=(boolean)
定义生成的动画是否限定到单元格点(就像步兵也被限定在特定的单元格点)，默认true。

[Animation]►FireAnimDisallowedLandTypes=(List of LandTypes  none|clear|road|water|rock|wall|tiberium|beach|rough|ice|railroad|tunnel|weeds)
定义在哪些地形类型上禁止生成火焰动画，
对于Scorch=true动画默认在water,rock,beach,ice地形上禁止生成，其他允许。
对于Flamer=true默认所有地形可生成。

[Animation]►AttachFireAnimsToParent=(boolean)
定义生成的子动画所属是否继承到母动画的所属(如果子动画也附加)，
Scorch=true的动画默认true，其他默认false

[Animation]►SmallFireCount=(integer)
定义生成的SmallFire动画数量，Flamer=true默认2，其他默认1。

[Animation]►SmallFireAnims=(list of animations)
微观定义SmallFire的动画列表，默认为[AudioVisual]►SmallFire(单个动画)。

[Animation]►SmallFireChances=(float-percents)
SmallFire动画生成的概率列表，与上一条一一对应，最多可读取SmallFireCount数量的项目。
如果数量超过列出的概率数，则使用列出的最后一项。Flamer=true时默认为1.0,0.5，否则为1.0。

[Animation]►SmallFireDistances=(float,distance in cells)
单元格中SmallFire动画从母动画坐标生成的距离列表，最多可读取SmallFireCount数量的项目。
如果数量超过列出的概率数，则使用列出的最后一项。Flamer=true时默认为0.25、0.625，否则为0.0。

[Animation]►LargeFireCount=(integer)
定义生成的LargeFire动画数量，仅用于Flamer=true动画。默认1。

[Animation]►LargeFireAnims=(list of animations)
微观定义LargeFire的动画列表，默认为[AudioVisual]►LargeFire(单个动画)。

[Animation]►LargeFireChances=0.5(float-percents)
LargeFire动画生成的概率列表，与上一条一一对应，最多可读取SmallFireCount数量的项目。
如果数量超过列出的概率数，则使用列出的最后一项。默认为0.5。

[Animation]►LargeFireDistances=(float,distance in cells)
单元格中LargeFire动画从母动画坐标生成的距离列表，最多可读取SmallFireCount数量的项目。
如果数量超过列出的概率数，则使用列出的最后一项。默认0.4375。

注意：如果Flamer母动画在空中则不会生成子动画。
默认设置与ares中的类似功能的作用相同。
武器
ROF随机延迟

[CombatDamage]►ROF.RandomDelay= (integer - single or comma-sep.range) 
全局定义，武器 ROF的延迟帧数，填写一个数值(确定值) 或 以逗号隔开的两个数值(范围)。默认0,2。
[Weapon]►ROF.RandomDelay= (integer - single or comma-sep.range)
武器微观定义， ROF的延迟帧数。
自定义飞碟激光半径
现在可以通过一个新标签来设置飞碟激光半径。
[Weapon]►DiskLaser.Radius= (float) 
飞碟激光发射前环绕的半径。默认38.2。 
单色激光
现在可以设定激光仅绘制LaserInnerColor，与IsHouseColor的激光表现相同。这样的激光也可以设定激光宽度。
[Weapon]►IsSingleColor= (boolean) 
激光是否为单色激光。默认no。
自定义特斯拉特效
可开关的特斯拉特效 
现在可以关闭特斯拉武器的特定电流。注意这只是视觉变化。 
[Weapon]►Bolt.Disable1= (boolean) 
[Weapon]►Bolt.Disable2= (boolean)
[Weapon]►Bolt.Disable3= (boolean)
是否不显示对应的电流。默认no。
 
自定义特斯拉电弧 
原版特斯拉(IsElectricBolt=true)会固定产生8个弧，现在可以自定义。
[Weapon]►Bolt.Arcs= (integer) 
特斯拉电弧的弧数。默认8。
自定义穿透伤害
现在可以给穿透伤害[Weapon]►AmbientDamage=设定单独的弹头，也可以令其不会影响到武器的主目标。
[Weapon]►AmbientDamage.Warhead= (WarheadType) 
穿透伤害的弹头。 
[Weapon]►AmbientDamage.IgnoreTarget= (boolean) 
穿透伤害是否会影响到武器的主目标。 默认false。 
自定义重置步兵序列
现在可以给FireOnce的步兵武器单独设置是否在开火后重置步兵开火序列了，不重置则会持续播放后续开火序列
[Weapon]►FireOnce.ResetSequence= (boolean) 
是否在开火后重置开火序列，默认是
自定义充能炮塔间隔
现在可以自定义IsChargeTurret=true的单位每个武器每次Burst发射造成的炮塔动画播放间隔，
而不是默认的武器装填计时器(ROF, BurstDelays等)。
现在使用对应武器Burst数的Delay值列表来决定充能炮塔间隔
如果数量少于列出的概率数，则使用列出的最后一项。
0或负数值则计为前摇，在武器发射前播放充能炮塔动画，若适用则不会重新开始。

[Weapon]►ChargeTurret.Delays=(list of integer,frames)
定义武器每次Burst发射时充能炮塔动画的播放间隔。

注意：和默认的ROF武器装填计时器不同，设定后的delay值无法被加成系数影响。

弹头
允许伤害开火者
现在可以设置弹头的伤害和其他效果都可以作用于其发射者，即发射者没有设置DamageSelf=true。

[Warhead]►AllowDamageOnSelf= (boolean) 
是否允许弹头伤害发射者。默认no。 
解除隐形
[Warhead]►DecloakDamagedTargets= (boolean) 
被此弹头伤害的单位是否会解除隐形状态。默认yes。
屏幕抖动限制在当前视野内
[Warhead]►ShakeIsLocal= (boolean)
弹头是否仅在当前视野内爆炸时才震动屏幕（ShakeX/Ylo/hi）。默认no。
自定义碎片
[Warhead]►DebrisAnims= (List of animations) 
弹头击中处产生的碎片动画列表。
[Warhead]►Debris.Conventional= (List of animations) 
是否在弹头击中非水面时才会产生碎片。默认no。
完全友好弹头
现在可以设置弹头是否完全友好，效果如下：
击中单位时不会产生任何EVA播报，哪怕是矿车，基地
0伤情况下不会产生攻击事件，非0伤依旧会产生
不会引发AI的防御行为，哪怕有ToProtect=true或Whiner=true
不会引发反击行为

[Warhead]►Nonprovocative= (boolean) 
是否定义弹头完全友好。默认no。 
抛射体
抛射体散布
多次爆炸散布
[Projectile]►ClusterScatter.Min= (float - cell range)
设置了Cluster的抛射体最小的散布范围。默认1.0。
[Projectile]►ClusterScatter.Max= (float - cell range)
设置了Cluster的抛射体最大的散布范围。默认2.0。

散射散布
[Projectile]►BallisticScatter.Min= (float - cell range)
设置了FlakScatter=yes的Inviso抛射体最小的散布范围。默认0。
[Projectile]►BallisticScatter.Max= (float - cell range)
设置了FlakScatter=yes的Inviso抛射体最大的散布范围。默认[CombatDamage]►BallisticScatter。
自定义抛射体重力
[Projectile]►Gravity= (double) 
抛射体的重力。默认6.0。不推荐设置 Gravity=0。会导致抛射体无法命中不在同一高度的单位。推荐使用 Straight弹道代替之。 
空爆/分裂增强
空爆与分裂
空爆逻辑已经被重制，添加了一些功能并进行了一些改动。



分裂逻辑：

[Projectile]>Splits=(boolean)
是否启用分裂逻辑，产生的分裂抛射体数量由Cluster定义。默认no。

[Projectile]>RetargetAccuracy=(float - percentage)
产生的分裂抛射体和原始抛射体朝向同一目标的概率。默认0.0。

[Projectile]>RetargetSelf=(boolean)
产生的分裂抛射体是否可以将原始抛射体的发射者作为目标。默认true。

[Projectile]>RetargetSelf.Probability=(float - percentage)
如果原始发射者被选为目标时，被保留为目标而不是重新抽选其他目标的概率。
需要启用RetargetSelf来生效。默认0.5。

[Projectile]>Splits.TargetingDistance=(float - cell range)
产生的分裂抛射体寻找目标的距离，只有在范围内的目标才能被分裂瞄准。默认5.0。

[Projectile]>Splits.TargetCellRange=(integer - cell offset)
产生的分裂抛射体重新寻找目标的以整格为单位的距离，当原始目标格没有足够的科技类型作为目标时，
分裂抛射体可以从定义的格范围中寻找新的目标。默认3。

[Projectile]>Splits.UseWeaponTargeting=(boolean)
是否在分裂上应用武器瞄准筛选，若启用则会在分裂抛射体寻找目标时应用武器瞄准筛选，
目标的护甲以及LegalTarget设置，弹头比例，空爆瞄准筛选以及AttachEffect瞄准筛选会被检查。
默认false。

注意：启用后会覆盖弹头的AffectsAllies/Owner/Enemies设置，
但可以在空爆武器上设置CanTargetHouses来达到相同的效果。


空爆增强：

需要设置Airburst=true来使以下逻辑生效

[Projectile]>AirburstSpread=(float - cell range)
空爆效果作用的单元格距离，默认情况下范围内的每一个单元格都是空爆效果作用的目标。
默认1.5.

[Projectile]>Airburst.UseCluster=(boolean)
是否只影响在空爆影响区域内的Cluster指定的单元格数而不是全部格，默认false。

[Projectile]>Airburst.RandomClusters=(boolean)
是否随机选取受影响的单元格而不是均匀分布选取（从被影响区域的中心到边缘计算）。
需要通过启用上一条语句来生效，默认false。

[Projectile]>AroundTarget=(boolean)    
决定空爆或分裂的散布原点，yes以原始抛射体的目标作为原点，no以原始抛射体爆炸处作为原点。
默认为Splits的设置值。

[Projectile]>AirburstWeapon.ApplyFirepowerMult=(boolean)
是否使得空爆武器能应用原始抛射体上的Firepower加成系数。默认false。


额外说明：除其他新增功能外，Splits、AirburstSpread、RetargetAccuracy、RetargetSelf
和AroundTarget应和Ares的类似功能等效,并且在Phobos与Ares一起使用时
Phobos的本功能会覆盖Ares的相关功能。








新增逻辑
护盾

所有建筑与单位现在都可以拥有护盾作为独立的第二血条。负伤害将恢复护盾，除非护盾已经被击碎。如果护盾不满，全部的负伤害都会被护盾吸收。
当通过DeploysInto，UndeploysInto模式转换时，护盾会按剩余百分比进行传递。如果目标单位不具备护盾，那么原始单位的护盾数据将会保存，直到变回来再恢复。 
[TechnoType]►ShieldType= (ShieldType)
注意：护盾需要新增一个注册表[ShieldTypes]并在里面注册。

以下是有关护盾血条的语句：
[AudioVisual]►Pips.Shield= (integer)
填数字，用pips文件内的哪一帧作为护盾的血条，如果指定了1个数，那么就一直显示这一帧；如果指定了3个数，那么将遵循ConditionYellow和ConditionRed的值让血条在绿血、黄血、红血时有不同显示。默认第16帧。
[AudioVisual]►Pips.Shield.Building= (integer)
同上，不过用于建筑。默认第5帧。
[AudioVisual]►Pips.Shield.Background= (filename, *including* the .pcx or .shp extension)
非建筑类护盾条使用的背景。默认pipbrd.shp。第4帧为步兵护盾条背景，第3帧为载具护盾条背景，如果帧数不够则分别使用第1帧和第2帧。
[AudioVisual]►Pips.Shield.Building.Empty= (integer)
填数字，用pips文件内的哪一帧在建筑护盾条为空时显示。默认第1帧。

如果pipbrd.shp中有额外的两帧，那么第4帧将用于步兵护盾血条框，第3帧用于其他单位。

以下是护盾类型可用语句：
[ShieldType]►Strength= (integer)
护盾的耐久度
[ShieldType]►InitialStrength= (integer)
护盾的初始耐久度
[ShieldType]►Armor= (ArmorType)
护盾的护甲类型。默认none。
[ShieldType]►InheritArmorFromTechno= (boolean)
护盾的护甲类型是否继承自单位。默认no
[ShieldType]►Powered= (boolean)
护盾是否在单位无电力支持或被EMP时失效。注意，如果单位本身Powered=false，那么护盾也不会因断电而失效。默认no。
[ShieldType]►AbsorbOverDamage= (boolean)
护盾被击碎时是否会吸收最后一次攻击的超量伤害。默认no。
 
[ShieldType]►SelfHealing= (double - percentage)
护盾恢复的血量，0.0将关闭功能，1%到100%为以百分比恢复，其他数字为以固定值直接恢复，负数为扣除护盾血量。默认0.0。
注意：如果你想让护盾每次只恢复1HP，目前需要将该标签的值设置在1到2之间的数，如1.1。
[ShieldType]►SelfHealing.Rate= (double - minutes)
护盾恢复的间隔，0.0立即恢复护盾，其他值以游戏内分钟为单位恢复。默认0.0。
[ShieldType]►SelfHealing.RestartInCombat=（boolean）
护盾是否在战斗中恢复血量。默认是
[ShieldType]►SelfHealing.RestartInCombatDelay=（integer） 
定义若SelfHealing.RestartInCombat=false的情况下，护盾未受击多久再次开始恢复
[ShieldType]►Respawn= (double - percentage)
护盾重生时的血量，同SelfHealing。默认0.0。
[ShieldType]►Respawn.Rate= (double - minutes)
护盾重生的间隔，同SelfHealing.Rate。默认0.0。
 
[ShieldType]►BracketDelta= (integer)
护盾血条的高度，相当于作用于护盾血条的PixelSelectionBracketDelta。默认0。
[ShieldType]►Pips= (integer)
微观设置使用哪一帧作为护盾的血条。
[ShieldType]►Pips.Building= (integer)
微观设置使用哪一帧作为建筑护盾的血条。
[ShieldType]►Pips.Background= (filename, *including* the .pcx or .shp extension)
微观设定护盾血条框使用的文件。
[ShieldType]►Pips.Building.Empty= (integer)
微观设置使用哪一帧作为建筑类护盾的血条框。
 
[ShieldType]►IdleAnim= (string, animation ID)
护盾空闲时播放的动画，暂不支持Bouncer=yes的动画。
[ShieldType]►IdleAnim.ConditionYellow= (string, animation ID)
护盾黄血空闲时播放的动画。
[ShieldType]►IdleAnim.ConditionRed= (string, animation ID)
护盾红血空闲时播放的动画。
[ShieldType]►IdleAnimDamaged= (string, animation ID)
护盾在单位本身低于黄血空闲时播放的动画。
[ShieldType]►IdleAnimDamaged.ConditionYellow= (string, animation ID)
护盾黄血且在单位本身低于黄血空闲时播放的动画。
[ShieldType]►IdleAnimDamaged.ConditionRed= (string, animation ID)
护盾红血且在单位本身低于黄血空闲时播放的动画。
[ShieldType]►IdleAnim.OfflineAction= (enum None|Hides|Temporal|Paused|PausedTemporal)
护盾空闲动画在断电时的动作。默认Hides。
[ShieldType]►IdleAnim.TemporalAction= (enum None|Hides|Temporal|Paused|PausedTemporal)
护盾空闲动画在被超时空时的动作。默认Hides。
 
[ShieldType]►BreakAnim= (string, animation ID)
护盾被击碎时播放的动画。
[ShieldType]►HitAnim= (string, animation ID)
护盾被攻击时播放的动画。
 
[ShieldType]►HitFlash= (boolean)
护盾被攻击时是否会闪烁，默认false。
[ShieldType]►HitFlash.FixedSize= (Integer)
护盾被攻击时的闪烁大小，有效值是81-252。默认由被攻击的伤害量决定。
[ShieldType]►HitFlash.Red= (boolean)
护盾被攻击时闪烁的颜色，默认true。 
[ShieldType]►HitFlash.Green= (boolean)
同上。
[ShieldType]►HitFlash.Blue= (boolean)
同上。
[ShieldType]►HitFlash.Black= (boolean)
同上，且该项若为True则会覆盖上面三种颜色。
 
[ShieldType]►BreakWeapon= (Weapon)
护盾被击碎时引爆的武器。
[ShieldType]►AbsorbPercent= (double - percentage)
护盾吸收伤害的比例。默认1.0，即吸收全部伤害。
[ShieldType]►PassPercent= (double - percentage)
护盾的穿透比例，即不会被吸收的伤害，穿透伤害将直接作用在单位身上。默认0.0，即不穿透。
[ShieldType]►ReceivedDamage.Minimum/Maximum=（Integer）
护盾在单次受击里收到的最小/最大值，该伤害计算在护甲和AbsorbPercent之后，若AbsorbOverDamage=false，则破盾后单位受到的伤害仍然根据原始伤害计算。
[ShieldType]►AllowTransfer= (boolean)
单位通过部署、变形等方式变换后护盾是否继承。通过Shield.AttachTypes附加的护盾默认yes，其他情况下默认no。
[ShieldType]►ImmuneToBerserk= (boolean)
护盾是否免疫狂暴，即神经突击车的攻击效果。
[ShieldType]►ImmuneToCrit= (boolean)
护盾是否免疫暴击
 
[ShieldType]►Tint.Color= (integer - R，G，B)
护盾给宿主染什么色。
[ShieldType]►Tint.Intensity= (float)
护盾染色强度。
[ShieldType]►Tint.VisibleToHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
哪些所属可以看见护盾的染色。

弹头相关
[Warhead]►Shield.Penetrate= (boolean)
弹头是否无视护盾直接造成伤害。默认no。
[Warhead]►Shield.Break= (boolean)
弹头是否在伤害结算前一击击碎护盾。默认no。
[Warhead]►Shield.BreakAnim= (string, animation ID)
代替被此弹头击碎的护盾本身的BreakAnim播放。
[Warhead]►Shield.HitAnim= (string, animation ID)
代替被此弹头击中的护盾本身的HitAnim播放。
[Warhead]►Shield.BreakWeapon= (Weapon)
代替被此弹头击碎的护盾本身的BreakWeapon引爆。
[Warhead]►Shield.AbsorbPercent= (double - percentage)
代替被此弹头击中的护盾的AbsorbPercent。
[Warhead]►Shield.PassPercent= (double - percentage)
代替被此弹头击中的护盾的PassPercent。
[Warhead]►Shield.ReceivedDamage.Minimum/Maximum= （Integer）
覆盖被此弹头击中的护盾的ReceivedDamage.Minimum/Maximum的相关值。
 
[Warhead]►Shield.Respawn.Duration= (integer - frames)
Shield.Respawn.Rate与Shield.Respawn.Amount覆盖被此弹头击中的护盾重生效果的持续时间。默认0。
[Warhead]►Shield.Respawn.Amount= (double - percentage)
代替被此弹头击中的护盾的Respawn，负数或0则默认为护盾本身的值。默认0.0。
[Warhead]►Shield.Respawn.Rate= (double - minutes)
代替被此弹头击中的护盾的Respawn.Rate，负数或0则默认为护盾本身的值。默认-1.0。
[Warhead]►Shield.Respawn.ResetTimer= (boolean)
当前护盾的重生时间是否会被重置。设置为no则按照新的时间进行比例缩放。如果覆盖效果在重生完成前结束了，剩余时间会按照护盾本身的Respawn.Rate进行缩放。默认no。
 
[Warhead]►Shield.SelfHealing.Duration= (integer - frames)
Shield.SelfHealing.Rate和Shield.SelfHealing.Amount覆盖被此弹头击中的护盾自愈效果的持续时间。默认0。
[Warhead]►Shield.SelfHealing.Amount= (double - percentage)
代替被此弹头击中的护盾的SelfHealing，负数或0则默认为护盾本身的值。默认0.0。
[Warhead]►Shield.SelfHealing.Rate= (double - minutes)
代替被此弹头击中的护盾的SelfHealing.Rate，负数或0则默认为护盾本身的值。默认-1.0。
[Warhead]►Shield.SelfHealing.ResetTimer= (boolean)
当前护盾的自愈时间是否会被重置。设置为no则按照新的时间进行比例缩放。如果覆盖效果在一次自愈完成前结束了，剩余时间会按照护盾本身的SelfHealing.Rate进行缩放。默认no。
 
[Warhead]►Shield.AffectTypes= (list of ShieldTypes)
哪些护盾会被上述效果影响。如果不设置，所有的护盾都会被影响。
[Warhead]►Shield.Penetrate.Types=(list of ShieldTypes)
弹头会无视哪些护盾直接造成伤害。 
[Warhead]►Shield.Break.Types=(list of ShieldTypes)
弹头在伤害结算前一击击碎哪些护盾。 
[Warhead]►Shield.Respawn.Types=(list of ShieldTypes)
哪些护盾的Respawn被此弹头击中时会被代替。 
[Warhead]►Shield.SelfHealing.Types=(list of ShieldTypes)
哪些护盾的SelfHealing被此弹头击中时会被代替。
 
[Warhead]►Shield.AttachTypes= (list of ShieldTypes)
被此弹头影响的单位附加的护盾列表。通常只有第一个被应用。
[Warhead]►Shield.RemoveTypes= (list of ShieldTypes)
被此弹头影响的单位移除的护盾列表。
[Warhead]►Shield.RemoveAll= (boolean)
若设置为yes，则命中后会无视Shield.RemoveTypes，直接清除所有护盾。
[Warhead]►Shield.ReplaceOnly= (boolean)
Shield.AttachTypes中的护盾是否会按位置替换Shield.RemoveTypes中的护盾。如果前者少于后者，那么多余的被移除的护盾被前者的最后一个护盾替换。默认no。
[Warhead]►Shield.ReplaceNonRespawning= (boolean)
Shield.AttachTypes中的护盾是否会替换已被击碎且不可再生的护盾。默认no。
[Warhead]►Shield.MinimumReplaceDelay= (integer - frames)
控制护盾在被击破后多久才能被替换。如果已过帧数不足，就不会被替换。默认0。
[Warhead]►Shield.InheritStateOnReplace= (boolean)
替换护盾后诸如血量，是否被击破等属性是否会继承。自我恢复和重生时间不会继承，总是重设。默认no。
自毁

现在单位可以在特定情况下自毁。
旧版Phobos中的Death.NoAmmo，Death.Countdown，Death.Peaceful已弃用

自毁方式
[TechnoType]►AutoDeath.Behavior= (enum kill|vanish|sell)
触发自毁时单位的死亡方式。不设置为不启用功能；kill为正常死亡；vanish为静默死亡，即不会触发死亡武器和EVA事件(即直接抹除)，取代了旧版中的Death.Peaceful；sell为变卖，只能用于建筑且建筑需要能够正常变卖。默认不设置。
 
注意：若自毁的单位带乘客，则乘客无法逃出
[TechnoType]►AutoDeath.VanishAnimation= (Animation) 
当AutoDeath.Behavior=vanish时，单位被直接抹除的动画。
 
自毁条件
[TechnoType]►AutoDeath.OnAmmoDepletion= (boolean)
是否当弹药数为0后自动死亡，取代了旧版中的Death.NoAmmo。默认no。
[TechnoType]►AutoDeath.AfterDelay= (integer)
在经过多少帧后死亡，取代了旧版中的Death.Countdown。
 
[TechnoType]►AutoDeath.TechnosDontExist= (list of TechnoTypes)
当指定科技类型不存在时自毁。
[TechnoType]►AutoDeath.TechnosDontExist.Any= (boolean)
是否当上一个词条指定的科技类型有一个不存在时就自毁。默认no，即全部不存在时才自毁。
[TechnoType]►AutoDeath.TechnosDontExist.AllowLimboed= (boolean)
在判断科技类型不存在时，是否包括地图外(可见范围外)或虚拟的单位/建筑。默认no。
[TechnoType]►AutoDeath.TechnosDontExist.Houses= (none|owner/self|allies/ally|team|enemies/enemy|all)
指定判断科技不存在的依据阵营。默认owner。
 
[TechnoType]►AutoDeath.TechnosExist= (list of TechnoTypes)
当指定科技类型存在时自毁。
[TechnoType]►AutoDeath.TechnosExist.Any= (boolean)
是否当上一条语句指定的科技类型有一个存在时就自毁。默认yes，即有一个存在就自毁。
[TechnoType]►AutoDeath.TechnosExist.AllowLimboed= (boolean)
在判断科技类型存在时，是否包括地图外(可见范围外)或虚拟的单位/建筑。默认no。
[TechnoType]►AutoDeath.TechnosExist.Houses= (none|owner/self|allies/ally|team|enemies/enemy|all)
指定判断科技存在的依据阵营。默认owner。
新AttachEffect
在rulesmd.ini中
 
[AttachEffectTypes]
0=SomeAttachEffect
 
以下是有关新AE的语句：
[AttachEffectTypes]►Duration= (integer)
定义AE的持续时间。可以被单位上的DurationOverrides覆盖。默认0，负数表示持续时间无限。
[AttachEffectTypes]►Cumulative= (boolean)
定义同种AE是否可以叠加。默认false。
[AttachEffectTypes]►Cumulative.MaxCount= (integer)
定义可以叠加的AE的叠加次数上限。默认-1表示无限次数
[AttachEffectTypes]►Powered= (boolean)
定义AE附着在失效的PoweredUnit、被EMP或者低电量时AE是否会失效。默认false。
[AttachEffectTypes]►DiscardOn= (enum entry|move|stationary|drain|inrange|outofrange|firing|none)
定义AE的附着条件。若值有效，则单位处于对应的情况时AE效果会消失。默认none。
注意，Spawner或DrainWeapon之类的特殊武器也会被视为firing。
[AttachEffectTypes]►DiscardOn.RangeOverride= (float - distance)
定义AE的DiscardOn的inrange和outofrange条件是否会被该距离覆盖取值。
[AttachEffectTypes]►PenetratesIronCurtain= (boolean)
定义AE是否可以附着在处于铁幕或力场护盾中的物体。默认false
[AttachEffectTypes]►Animation= (list of Animation)
定义AE生效时播放的动画。
[AttachEffectTypes]►Animation.ResetOnReapply= (boolean)
当Cumulative=false时，每次附着的时候是否重新播放动画。
[AttachEffectTypes]►Animation.OfflineAction= (enum None|Hides|Temporal|Paused|PausedTemporal)
当Powered=true时，附着的单位离线时AE动画的播放情况。
[AttachEffectTypes]►Animation.TemporalAction= (enum None|Hides|Temporal|Paused|PausedTemporal)
定义附着的单位被超时空武器攻击时AE动画的播放情况。
[AttachEffectTypes]►CumulativeAnimations.RestartOnChange=(boolean)
定义动画类型发生更改时是否重新从头播放,如果设置为false,
则在相对动画长度的相同位置的帧处恢复播放。默认true。
[AttachEffectTypes]►Animation.UseInvokerAsOwner= (boolean)
定义AE动画的所属由发射者决定而不是附着的物体决定。默认false
[AttachEffectTypes]►Animation.HideIfAttachedWith= (List of AttachEffectTypes)
定义这些AE若重复附着在同一单位上时影响动画
[AttachEffectTypes]►CumulativeAnimations= (list of Animation)
定义AE每次叠加时播放的动画。可以写很多但需要和可叠加次数相对应。若可叠加次数大于动画数量则只会播放最后一个动画。每次叠加时每一个动画都会重新播放。
[AttachEffectTypes]►ExpireWeapon= (WeaponType)
定义AE处于某些情况下会发射的武器。
[AttachEffectTypes]►ExpireWeapon.TriggerOn= (enum none|expire|remove|death|all)
定义AE会在这些情况下发射武器。默认expire。
[AttachEffectTypes]►ExpireWeapon.CumulativeOnlyOnce= (boolean)
若设置为true，则当Cumulative=true时每个AE期间只会发射一次武器。若TriggerOn设置为none或expire时只会在最后一个AE失效或移除时发射武器。
[AttachEffectTypes]►Tint.Color= (interger)
定义被AE附着的单位被染的颜色。
[AttachEffectTypes]►Tint.Intensity= (float)
定义被AE附着的单位被染的颜色强度。
[AttachEffectTypes]►Tint.VisibleToHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
定义该AE染色可以被哪些所属看见。
[AttachEffectTypes]►FirepowerMultiplier= (float)
定义AE附着时物体的火力加成。默认1.0。
[AttachEffectTypes]►ArmorMultiplier= (float)
定义AE附着时物体的护甲加成。默认1.0。
[AttachEffectTypes]►ArmorMultiplier.AllowWarheads=(list of WarheadTypes)
定义AE的护甲加成只能用于这些弹头。
[AttachEffectTypes]►ArmorMultiplier.DisallowWarheads=(list of WarheadTypes)
定义AE的护甲加成不能用于这些弹头。
[AttachEffectTypes]►SpeedMultiplier= (float)
定义AE附着时物体的速度加成。默认1.0。
[AttachEffectTypes]►ROFMultiplier= (float)
定义AE附着时物体的攻速加成。默认1.0。
[AttachEffectTypes]►ROFMultiplier.ApplyOnCurrentTimer= (boolean)
定义AE的攻速加成是否会直接作用在攻速上，哪怕当前正在冷却也会缩短或增加。
[AttachEffectTypes]►Cloakable= (boolean)
定义AE生效期间物体是否隐形。
[AttachEffectTypes]►ForceDecloak= (boolean)
定义AE生效期间物体是否强制显形。
[AttachEffectTypes]►WeaponRange.Multiplier= (float)
定义AE生效期间物体的武器射程加成倍数。
[AttachEffectTypes]►WeaponRange.ExtraRange= (float)
定义AE生效期间物体的武器射程加成固定数。
注意：Multiplier和ExtraRange在于前者乘算，后者加算。且ExtraRange计算在Multiplier后。二者单位都是cells。
[AttachEffectTypes]►WeaponRange.AllowWeapons= (list of WeaponTypes)
定义AE的武器射程加成只能用于这些武器。
[AttachEffectTypes]►WeaponRange.DisallowWeapons= (list of WeaponTypes)
定义AE的武器射程加成不能用于这些武器。覆盖AllowWeapons。
[AttachEffectTypes]►Crit.Multiplier= (float)
定义AE生效期间物体的暴击加成倍数。
[AttachEffectTypes]►Crit.ExtraChance= (float)
定义AE生效期间物体的暴击加成固定数。
[AttachEffectTypes]►Crit.AllowWarheads= (list of WarheadTypes)
定义AE的暴击加成只能用于这些弹头。
[AttachEffectTypes]►Crit.DisallowWarheads= (list of WarheadTypes)
定义AE的暴击加成不能用于这些弹头。覆盖AllowWarheads。
[AttachEffectTypes]►RevengeWeapon= (WeaponType)
定义AE生效期间物体获得的复仇武器。
[AttachEffectTypes]►RevengeWeapon.AffectsHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
定义该复仇武器能复仇的所属。
[AttachEffectTypes]►ReflectDamage= (boolean)
定义AE生效期间物体可以反弹任意正数伤害给伤害来源。
[AttachEffectTypes]►ReflectDamage.Warhead= (WarheadType)
定义该反弹伤害的弹头，默认为[General]►C4Warhead设定的弹头。
[AttachEffectTypes]►ReflectDamage.Warhead.Detonate=(boolean)

定义反弹伤害弹头是否像完整武器中的弹头那样引爆而不是只造成伤害，默认false。
[AttachEffectTypes]►ReflectDamage.Multiplier= (float)
定义AE生效期间物体反弹伤害的倍率。
[AttachEffectTypes]►ReflectDamage.AffectsHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
定义AE生效期间物体能反弹伤害的所属。
[AttachEffectTypes]►DisableWeapons= (boolean)
定义AE生效期间附着的单位是否无法发射任何武器。
[AttachEffectTypes]►Groups= (string)
定义该AE归类为该选择组里。可以用选择组来代替具体的AE名称。移除AE，武器过滤之类的都能正常运作。
 
 
在单位上附着AE
[TechnoType]►AttachEffect.AttachTypes= (List of AttachEffectTypes)
定义该单位附着哪些AE。
[TechnoType]►AttachEffect.DurationOverrides= (List of AttachEffectTypes)
定义是否用该Duration覆盖单位附着的AE。若写多个值则需要和单位附着的一一对应。否则使用最后一个Duration。
[TechnoType]►AttachEffect.Delays= (interger)
定义该AE在单位上每次生效的间隔。默认0，负数表示不生效。若写多个值则需要和单位附着的一一对应。否则使用最后一个Delay。
[TechnoType]►AttachEffect.InitialDelays= (interger)
定义该AE在单位上初次生效的间隔。默认0，负数表示不生效。若写多个值则需要和单位附着的一一对应。否则使用最后一个InitialDelays。
[TechnoType]►AttachEffect.RecreationDelays= (interger)
定义该AE在单位上被移除后再次生成的延迟。默认0，负数表示不生效。若写多个值则需要和单位附着的一一对应。否则使用最后一个RecreationDelays。
[UnitType]►OpenTopped.UseTransportRangeModifiers= (boolean)
定义OpenTopped=true载具在接受射程加成AE时是否可以将加成传递给乘客。默认false。
[UnitType]►OpenTopped.CheckTransportDisableWeapons= (boolean)
定义OpenTopped=true载具持有DisableWeapons类AE时是否会禁止乘客的开火，默认false。
 
 
在武器上附着AE
[WeaponType]►AttachEffect.RequiredTypes= (List of AttachEffectTypes)
定义该武器只能对持有这些AE的单位开火。若写多个则这些AE必须全部存在才能开火。
[WeaponType]►AttachEffect.DisallowedTypes= (List of AttachEffectTypes)
定义该武器不能对持有这些AE的单位开火。若写多个则这些AE存在任意一个就不能开火。
[WeaponType]►AttachEffect.RequiredGroups= (string)
定义该武器只能对该AE类别组开火。若类别组里有多个AE则这些AE存在任意一个就可以开火。
[WeaponType]►AttachEffect.DisallowedGroups= (interger)
定义该武器不能对该AE类别组开火。若类别组里有多个AE则这些AE存在任意一个就不能开火。
[WeaponType]►AttachEffect.RequiredMinCounts= (interger)
当Cumulative=true时，定义该武器可以对持有这些AE的单位开火的需要的AE叠加最小次数。
[WeaponType]►AttachEffect.RequiredMaxCounts= (interger)
当Cumulative=true时，定义该武器可以对持有这些AE的单位开火的需要的AE叠加最大次数。
[WeaponType]►AttachEffect.DisallowedMinCounts= (interger)
当Cumulative=true时，定义该武器不可以对持有这些AE的单位开火的需要的AE叠加最小次数。
[WeaponType]►AttachEffect.DisallowedMaxCounts= (interger)
当Cumulative=true时，定义该武器不可以对持有这些AE的单位开火的需要的AE叠加最大次数。
[WeaponType]►AttachEffect.IgnoreFromSameSource= (boolean)
当AE来源是自己时无视上述条件。默认false。
 
 
在弹头上附着AE
[WarheadType]►AttachEffect.AttachTypes= (List of AttachEffectTypes)
定义该弹头引爆时给目标附着的AE。
[WarheadType]►AttachEffect.RemoveTypes= (List of AttachEffectTypes)
定义该弹头引爆时令目标移除的AE。
[WarheadType]►AttachEffect.RemoveGroups= (string)
定义该弹头引爆时令目标移除的AE类别组。
[WarheadType]►AttachEffect.CumulativeRemoveMinCounts= (interger)
当Cumulative=true时，弹头引爆时可以移除AE或AE类别组的最小次数。
[WarheadType]►AttachEffect.CumulativeRemoveMaxCounts= (interger)
当Cumulative=true时，弹头引爆时可以移除AE或AE类别组的最大次数。
[WarheadType]►AttachEffect.DurationOverrides= (interger)
定义是否用该Duration覆盖单位附着的AE。若写多个值则需要和单位附着的一一对应。否则使用最后一个Duration。
 
[WarheadType]►Suppress.ReflectDamage= (boolean)
定义该弹头是否免疫被反弹伤害，默认false。
[WarheadType]►Suppress.ReflectDamage.Type= (string)
定义该弹头是否能免疫被反弹伤害的AE类型，若不写则所有都可以被免疫反弹。
[WarheadType]►AttachEffect.CumulativeRefreshAll=(boolean)
定义是否在向已经达到Cumulative.MaxCount定义的叠加次数的目标再次施加Cumulative=true
效果时，刷新所有同类AE效果的持续时间而不是只刷新剩余持续时间最短的AE效果的持续时间。默认false。
[WarheadType]►AttachEffect.CumulativeRefreshAll.OnAttach=(boolean)
定义是否在目标并未达到Cumulative.MaxCount定义的叠加次数时再次施加Cumulative=true
效果也生效刷新持续时间效果。默认false。
[WarheadType]►AttachEffect.CumulativeRefreshSameSourceOnly=(boolean)
定义是否只有来自同一开火者的相同弹头施加的同类AE的Cumulative=true效果
才能生效刷新持续时间效果。默认true。

乘客与弹药

自动删除乘客
有该标签的载具将随着时间移除其中乘客。大型单位将需要更多时间。该逻辑也可以像部队回收站一样工作。
[TechnoType]►PassengerDeletion.Rate= (integer, game frames)
删除乘客的间隔。
[TechnoType]►PassengerDeletion.Rate.SizeMultiply= (boolean)
删除乘客的间隔是否受乘客大小影响，乘客大小越大删除间隔越长。默认yes。
 
[TechnoType]►PassengerDeletion.UseCostAsRate= (boolean) 
删除乘客的间隔是否由乘客的Cost决定，Cost值越大删除间隔越长。默认no。
[TechnoType]►PassengerDeletion.CostMultiplier= (integer) 
基于Cost的时间间隔倍数。默认1.0。
[TechnoType]►PassengerDeletion.CostRateCap= (integer, game frames) 
基于Cost的时间间隔上限。不设定则无上限。默认无上限。 
 
[TechnoType]►PassengerDeletion.AllowedHouses=  (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
哪个阵营的单位会受自动删除乘客的影响。默认all。
[TechnoType]►PassengerDeletion.DontScore= (boolean) 
被删除的乘客是否不被认为是被杀死的。设置为yes则被删除的乘客将不计入分数和被击杀数。默认no。
 
[TechnoType]►PassengerDeletion.Soylent= (boolean) 
删除乘客时是否获得相当于乘客的回收价格的资金。默认no。
[TechnoType]►PassengerDeletion.SoylentMultiplier= (boolean) 
删除乘客得到回收资金的倍数。默认1.0。
b36移除： 
[TechnoType]►PassengerDeletion.SoylentFriendlies= (boolean)
同上，不过是对于友方。
[TechnoType]►PassengerDeletion.SoylentAllowedHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
哪个阵营的乘客在被删除时才会获得资金。默认enemies。
[TechnoType]►PassengerDeletion.DisplaySoylent= (boolean)
是否在删除乘客获得资金时在目标位置显示资金变化数。
[TechnoType]►PassengerDeletion.DisplaySoylentToHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
哪个阵营可以看到删除乘客显示的资金变化数。默认all。
[TechnoType]►PassengerDeletion.DisplaySoylentOffset= (X,Y, pixels relative to default)
调整显示的资金变化数的绘制偏移。负数左/上，正数右/下。默认0,0。
 
[TechnoType]►PassengerDeletion.ReportSound= (Sound)
删除乘客时的音效。
[TechnoType]►PassengerDeletion.Anim= (list of Animation)
删除乘客时的动画。

自定义可对外射击载具的属性
现在可以微观定义每种可对外射击载具各自的增益参数。
[TechnoType]►OpenTopped.RangeBonus= (integer)
乘客对外攻击范围的加成。
[TechnoType]►OpenTopped.DamageMultiplier= (float - multiplier)
乘客对外攻击伤害倍数的加成。
[TechnoType]►OpenTopped.WarpDistance= (integer)
超时空武器乘客对外攻击的最大范围。
[TechnoType]►OpenTopped.IgnoreRangefinding= (boolean)
载具索敌时是否根据自身武器的范围确定距离而不是乘客的。默认no。
[TechnoType]►OpenTopped.AllowFiringIfDeactivated= (boolean)
载具因EMP等原因失效时，乘客是否仍然可以对外开火。默认yes。
[TechnoType]►OpenTopped.ShareTransportTarget= (boolean) 
乘客是否和载具攻击同一个目标。默认yes。


 
共享弹药
现在有OpenTopped=yes的运输载具将会将其弹药分享给乘客了。载具必须拥有弹药且可以恢复弹药。
[TechnoType]►Ammo.Shared= (boolean)
是否共享弹药，载员和载具同时设置才会共享，设置为no的载员不会共享。默认no。
[TechnoType]►Ammo.Shared.Group= (integer)
共享弹药的编号，只有相同编号的载具和载员才会共享，载具设置为-1时会共享给所有可共享的乘客，无视组别设置。默认-1。

自动更改乘客所属
有该标签的载具中的乘客的所属将会随着该载具一同改变。可以用于改变OpenTopped=yes的载具中的乘客在被心灵控制的情况下的目标选择。不适用于Abductor=yes的载具。
[TechnoType]►Passengers.SyncOwner= (boolean)
乘客的所属是否跟随载具变化。默认no。
[TechnoType]►Passengers.SyncOwner.RevertOnExit= (boolean)
乘客的所属是否在乘客离开载具时变会原本的所属。默认yes。
 
自动更改乘客所属
现在可以设置有弹药的乘客是否可以在载具内回复弹药了。
[TechnoType]►ReloadInTransport= (boolean)
定义该单位是否可以在载具内回复弹药，使用单位自己的Reload和EmptyReload，默认false。
动画生成单位

动画现在可以在结束时生成或“转换成”单位(包括步兵，载具和飞机)。相比于使用MakeInfantry生成步兵，这个可以提供更多自定义设置。
因为多数情况下动画并没有所属方，单位将以中立方出生，除非使用可以存储被摧毁单位的所属方和方向信息的DestroyAnim，或弹头AnimList或触发事件41。
 
在rulesmd.ini中：
[UnitType]►DestroyAnim= (list of Animation)
单位的爆炸动画，不同于Explosion，这个可以保留单位的所属方和方向。
[UnitType]►DestroyAnim.Random= (boolean)
单位的爆炸动画是否从DestroyAnim的列表中随机选取。默认yes。
 
在artmd.ini中：
[Animation]►CreateUnit= (TechnoType)
动画生成的单位。
[Animation]►CreateUnit.Owner= (enum invoker|killer|victim|civilian|special|neutral|random) 
动画生成单位的所属。默认Victim。
[Animation]►CreateUnit.RemapAnim= (boolean) 
动画是否有所属色。默认no。
[Animation]►CreateUnit.Mission= (mission) 
动画生成单位的动作。默认Guard。
[Animation]►CreateUnit.AIMission= (mission) 
动画生成单位的动作。但是AI专用，会覆盖CreateUnit.Mission。默认Guard。
[Animation]►CreateUnit.Facing= (integer) 
动画生成单位的方向，范围0-255。默认0。
[Animation]►CreateUnit.RandomFacing= (boolean)
动画生成单位的方向是否随机。默认yes。
[Animation]►CreateUnit.InheritFacings= (boolean) 
动画生成单位的方向是否继承自被摧毁单位的方向。默认no。
[Animation]►CreateUnit.InheritTurretFacings= (boolean)
动画生成单位的方向是否继承自被摧毁单位炮塔的方向。默认no。
[Animation]►CreateUnit.AlwaysSpawnOnGround= (boolean) 
如果动画在空中播放，也会在地面刷出单位。为yes时会覆盖CreateUnit.SpawnHeight的设置。默认no。
[Animation]►CreateUnit.ConsiderPathfinding= (boolean) 
如果动画所在格子不能刷出单位，则会在附近寻找合适的格子中刷出。默认no。
[Animation]►CreateUnit.SpawnAnim=  (list of Animation)
在动画生成单位的位置处播放另一个动画，在CreateUnit播放后播放。此动画具有与CreateUnit相同的owner和invoker。
[Animation]►CreateUnit.SpawnHeight=  (integer)
若指定为正数值，则可以覆盖生成动画的高度，指定在某一高度生成单位。默认-1。

间谍渗透功能增强

增强了ARES的SpyEffect.Custom逻辑

[BuildingType]►SpyEffect.Custom= (boolean)
该建筑能否渗透。
[BuildingType]►SpyEffect.VictimSuperWeapon= (SuperWeaponType)
建筑物被渗透后，被渗透方立刻在被渗透的建筑处发射的超级武器。
[BuildingType]►SpyEffect.InfiltratorSuperWeapon= (SuperWeaponType)
建筑物被渗透后，渗透方立刻在被渗透的建筑处发射的超级武器。
激光尾迹
单位和抛射体现在可以拥有多条不同透明度、厚度和颜色的彩色尾迹，这些尾迹是由引擎绘制的。单位的尾迹可以设置其每一条尾迹的类型，以及相对车体或炮塔的FHL偏移。
注意：所有激光尾迹相关的语句全部写在artmd.ini中，包括注册表[LaserTrailTypes]，每一种激光尾迹也需要在注册表里注册。

以下是激光尾迹类型可用语句：
[LaserTrailType]►IsHouseColor= (boolean)
激光尾迹是否为所属色。
[LaserTrailType]►Color= (R,G,B)
激光尾迹的颜色。
[LaserTrailType]►FadeDuration= (integer)
激光尾迹的持续时间。
[LaserTrailType]►Thickness= (integer)
激光尾迹的宽度。
[LaserTrailType]►SegmentLength= (integer)
每一段激光尾迹的最小长度。
[LaserTrailType]►IgnoreVertical= (boolean)
是否在垂直移动时不绘制激光尾迹。默认no。
[LaserTrailType]►IsIntense= (boolean)
激光是否可以被支持（类似光棱塔的递光）。默认no。
[LaserTrailType]►CloakVisible= (boolean)
当单位隐身时，激光尾迹是否可见。默认no。
[LaserTrailType]►CloakVisible.DetectdOnly= (boolean)
当单位隐身时，激光尾迹只可被探测到的一方可视，默认false。

 
在抛射体上附加激光尾迹
[Projectile]►LaserTrail.Types= (LaserTrailType)

在单位上附加激光尾迹
[TechnoType]►LaserTrailN.Type= (LaserTrailType)
第N个激光尾迹的种类。
[TechnoType]►LaserTrailN.FLH= (F,L,H)
第N个激光尾迹的坐标。默认0，0，0。
[TechnoType]►LaserTrailN.IsOnTurret=no (boolean)
第N个激光尾迹是否绘制在炮塔上。默认no。

以上几条语句中的N从0开始，根据要附加的激光尾迹的个数依次向上递增。

在VXL碎片上附加激光尾迹
在rulesmd.ini中：
[VoxelAnim]►LaserTrail.Types= (LaserTrailType)

警告：激光尾迹非常消耗资源！由于游戏不使用GPU，因此如果设置了大量激光尾迹，即使在很好的电脑上也会迅速降低FPS。你可以通过以下方式减少这种影响：
不要在单位和抛射体上放置太多激光尾迹。
在尾迹不过于参差不齐的情况下设置尽可能高的SegmentLength值。
尽量使尾迹长度最小（可以通过设置较小的FadeDuration值实现）。
扩展建筑升级逻辑
建筑升级现在可以放置在自己，盟友和/或敌人的建筑上。通过一个逗号分隔的新标签控制。当升级放在建筑上后，它将自动转换为建筑的所属方。建筑升级也可以被放置在多种建筑上，Ares引入的建造限制检查对此逻辑兼容。

[BuildingType]►PowersUp.Owner= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
建筑升级可以放置的对象。默认Self。
[BuildingType]►PowersUp.Buildings= (list of BuildingTypes)
建筑升级可以放置在哪些建筑上。
电厂增幅逻辑
增幅建筑存在的时候会增幅电厂产生的电力，被变卖或摧毁后，增幅电量就会消失。

[BuildingType]►PowerPlantEnhancer.PowerPlants= (list of BuildingTypes)
增幅哪些建筑。
[BuildingType]►PowerPlantEnhancer.Amount= (integer)
增幅的值，即令增幅的建筑的电力增加这个值。默认0。
[BuildingType]►PowerPlantEnhancer.Factor= (float - multiplier)
增幅的倍数，即令增幅的建筑的电力乘这个值。默认1.0。
对特定目标强制使用特定武器

[TechnoType]►ForceWeapon.Naval.Decloaked= (integer)
对未隐形时的海军单位强制使用的武器，0为主武器，1为副武器。
[TechnoType]►ForceWeapon.Cloaked= (integer)
对隐形单位强制使用的武器，0为主武器，1为副武器。
[TechnoType]►ForceWeapon.Disguised= (integer)
对伪装单位强制使用的武器，0为主武器，1为副武器。
伪装功能增强
步兵类型拥有独立的默认伪装
每种步兵单位现在都可以有它自己的DefaultDisguise，此标签的优先级高于Ares中为Side设定的DefaultDisguise。
[InfantryType]►DefaultDisguise= (InfantryType)
可伪装步兵的默认伪装对象。
 
伪装效果
[General]►DisguiseBlinkingVisibility=  (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
哪些阵营可以看到单位闪烁的伪装效果。
此功能不会影响其他效果，但闪烁伪装意味着原单位的军衔总是可见的。
 
[InfantryType]►UseDisguiseMovementSpeed=  (boolean) 
单位伪装后，速度是否改为伪装目标的速度。
即便伪装被识破，效果也依旧存在。此效果只会在伪装效果被移除时失效。
禁止手动移动
[TechnoType]►NoManualMove= (boolean)
是否不能手动移动，单位将无视移动指令。默认no。
自动开火武器
现在可以使单位自动开火，而不需要搜索目标。

[TechnoType]►AutoFire= (boolean)
单位是否使用强制攻击的武器向脚下自动发射武器。默认no。
[TechnoType]►AutoFire.TargetSelf= (boolean)
单位自动发射武器时是否根据武器选择规则选择对单位自身有效的武器。默认no。
复仇武器
类似于死亡武器但不同的是复仇武器会向击杀自己的来源发射。若找不到来源复仇武器不会发射。

[TechnoType]►RevengeWeapon= (WeaponType) 
定义单位的复仇武器。
[TechnoType]►RevengeWeapon.AffectsHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
定义单位的复仇武器能向哪些所属发射。
Burst开火坐标
[TechnoType]►ElitePrimaryFireFLH.BurstN= (F,L,H)
同上，用于精英级主武器。
[TechnoType]►SecondaryFireFLH.BurstN= (F,L,H)
同上，用于副武器。
[TechnoType]►EliteSecondaryFireFLH.BurstN= (F,L,H)
同上，用于精英级副武器。
[TechnoType]►WeaponXFLH.BurstN= (F,L,H)
第X个武器Burst第N发的开火坐标，用于盖特，IFV，充能炮塔等逻辑。
[TechnoType]►EliteWeaponXFLH.BurstN= (F,L,H)
同上，用于精英级武器。
关闭副武器自动推算
现在可以设定如果一个单位的主武器不能攻击一个目标，那其副武器也可以不再对此目标有效。同时有若干情况，这些情况下副武器总会被调用：
1.设置了OpenTransportWeapon=1的单位在OpenTopped=true的载具内开火。
2.设置了NoAmmoWeapon=1的单位，Ammo大于0且当前弹药数小于等于NoAmmoAmount。
3.部署的IsSimpleDeployer=true的DeployFireWeapon=1的单位。
4.DrainWeapon=true的武器对Drainable=yes的建筑。
5.主武器的弹头有IsLocomotor=true时对建筑。
6.弹头ElectricAssault=true对友军的Overpowerable=true的建筑。
7.Overpowerable=true的建筑被过载。
WeaponX系统整个排除在外，即Gunner=true或IsGattling=true。

[TechnoType]►NoSecondaryWeaponFallback= (boolean)
是否关闭副武器自动推算。默认no。
[TechnoType]►NoSecondaryWeaponFallback.AllowAA= (boolean) 
当抛射体AA=yes且目标在空中时，是否关闭副武器自动推算。默认no。
初始生命值
[TechnoType]►InitialStrength= (integer)
单位的初始生命值。

克隆单位初始生命值
[BuildingType]►InitialStrength.Cloning= (double - percentage)
该建筑克隆出的单位初始生命值的百分比，可以设置1或2个值。如果设置2个值则初始生命值的百分比会在两个值之间随机选择。
心灵控制增强
单位相关
[TechnoType]►MindControlRangeLimit= (double)
心灵控制的最大控制距离，大于0将激活此逻辑。默认-1.0。
[TechnoType]►MultiMindControl.ReleaseVictim= (boolean)
多重心控单位是否可以在过载前释放被控制的单位。默认no。

弹头相关
[Warhead]►MindControl.Anim= (string, animation ID)
心灵控制的单位头上的动画。默认[General]►ControlledAnimationType。
建筑延伸增强
[BuildingTypes]►Adjacent.Allowed=(List of BuildingTypes)    
定义哪些建筑类型可以在该建筑的Adjacent提供的建造范围内建造。
如果该列表为空，则所有不在该建筑Adjacent.Disallowed列表内的建筑
都可以在该建筑提供的建造范围内建造。
[BuildingTypes]►Adjacent.Disallowed=(List of BuildingTypes)     
定义哪些建筑类型不可以在该建筑的Adjacent提供的建造范围内建造。
若该列表为空则所有在该建筑Adjacent.Allowed列表上的建筑都可以
在该建筑提供的建造范围内建造。两个列表均为空即允许所有建筑。
[BuildingTypes]►NoBuildAreaOnBuildup=(boolean)
定义该建筑是否在播放建造动画时不提供建造范围。默认false。
子机逻辑拓展
子机最大航程
[TechnoType]►Spawner.LimitRange= (boolean)
子机现在是否停止追击超出攻击距离的敌人。默认no。
[TechnoType]►Spawner.ExtraLimitRange= (integer)
子机的额外追击距离。默认0。
[TechnoType]►Spawner.DelayFrames= (integer, game frames) 
设置子机每次发射之间的最小帧数。默认情况下，导弹9帧，其他20帧。
[TechnoType]►Spawner.AttackImmediately= (boolean) 
设置子机不会再等待所有子机生成后再执行任务，而是立刻执行攻击任务，

升级子机
[TechnoType]►Promote.IncludeSpawns= (boolean)
子机是否以发射者的等级出现。默认no。
武器在传送时开火
现在可以让武器在单位传送后开火，会在传送动画（WarpIn / WarpOut）播放的同时开火。

[TechnoType]►WarpInWeapon= (Weapon)
传送到达时开火的武器。
[TechnoType]►WarpInMinRangeWeapon= (Weapon)
在传送距离小于ChronoRangeMinimum代替WarpInWeapon开火的武器。默认与WarpInWeapon相同。
[TechnoType]►WarpInWeapon.UseDistanceAsDamage= (boolean)
是否用传送穿过的单元数替代传送到达时开火的武器的伤害。默认no。
[TechnoType]►WarpOutWeapon= (Weapon)
传送离开时开火的武器。
地图与AI相关的增强
如果你不想自己写新的FAData.ini那么你可以直接使用FinalAlert2Super
https://github.com/secsome/FA2sp
新增的触发条件与行为
新的触发条件

变量比较（500-511）
ID=EventCount,<Event1>,<EventID>,2,<VariableIndex>,<Param>,<EventX>将变量值和给定的值进行比较，对应EventID的具体内容见下表：
事件ID	描述	全局
500	当前值>数字	否
501	当前值<数字	否
502	当前值=数字	否
503	当前值>=数字	否
504	当前值<=数字	否
505	当前值&数字	否
506	当前值>数字	是
507	当前值<数字	是
508	当前值=数字	是
509	当前值>=数字	是
510	当前值<=数字	是
511	当前值&数字	是
 
 
变量与局部变量比较（512-523）
ID=EventCount,<Event1>,<EventID>,2,<VariableIndex>,<LocalVariableIndex>,<EventX>将变量值和局部变量进行比较，对应EventID的具体内容见下表：
事件ID	描述	全局
512	当前值>局部变量值	否
513	当前值<局部变量值	否
514	当前值=局部变量值	否
515	当前值>=局部变量值	否
516	当前值<=局部变量值	否
517	当前值&局部变量值	否
518	当前值>局部变量值	是
519	当前值<局部变量值	是
520	当前值=局部变量值	是
521	当前值>=局部变量值	是
522	当前值<=局部变量值	是
523	当前值&局部变量值	是
 
 
变量与全局变量比较（524-535）
ID=EventCount,<Event1>,<EventID>,2,<VariableIndex>,<GlobalVariableIndex>,<EventX>将变量值和全局变量进行比较，对应EventID的具体内容见下表：
事件ID	描述	全局
524	当前值>全局变量值	否
525	当前值<全局变量值	否
526	当前值=全局变量值	否
527	当前值>=全局变量值	否
528	当前值<=全局变量值	否
529	当前值&全局变量值	否
530	当前值>全局变量值	是
531	当前值<全局变量值	是
532	当前值=全局变量值	是
533	当前值>=全局变量值	是
534	当前值<=全局变量值	是
535	当前值&全局变量值	是
 
 
关联对象的护盾被击碎（600）
ID=EventCount,...,600,2,0,0,...当关联对象的护盾被击碎时触发此事件
新的触发行为

保存游戏（500）
立刻存档（仅单人游戏）。原版CSF中的TXT_SAVING_GAME，TXT_GAME_WAS_SAVED 和TXT_ERROR_SAVING_GAME将会被使用。存档名将会是地图名 - CSF。 
ID=ActionCount,<Action1>,500,4,<CSFKey>,0,0,0,0,A,<ActionX>
 
 
编辑变量（501）
计算一个变量的值。变量类型为int32，即值域范围为-2147483648到2147483647。超过此范围可能会引起预期外的效果。
ID=ActionCount,<Action1>,501,0,<VariableIndex>,<Operation>,<Number>,<IsGlobalVariable>,0,A,<ActionX>
对应操作数的具体内容见下表：
操作数	描述
0	当前值=数字
1	当前值=当前值+数字
2	当前值=当前值-数字
3	当前值=当前值*数字
4	当前值=当前值/数字
5	当前值=当前值%数字
6	当前值=当前值<<数字
7	当前值=当前值>>数字
8	当前值=~当前值
9	当前值=当前值⊕数字
10	当前值=当前值|数字
11	当前值=当前值&数字

 
 
生成随机数（502）
在Min到Max之间生成一个随机数，存储在给定的变量中。
ID=ActionCount,<Action1>,502,0,<VariableIndex>,<Min>,<Max>,<IsGlobalVariable>,0,A,<ActionX>
 
 
打印变量值（503）
在消息列表中输出变量值。
ID=ActionCount,<Action1>,503,<VariableIndex>,0,<IsGlobalVariable>,0,0,0,A,<ActionX>
 
 
变量间计算（504）
将两个变量的值进行计算。类似行为501，但计算数由另一个变量中读取。
ID=ActionCount,<Action1>,504,0,<VariableIndex>,<Operation>,<VariableForOperationIndex>,<IsGlobalVariable>,<IsOperationGlobalVariable>,A,<ActionX>
对应操作数的具体内容可以参考行为501的表格。
 
 
在指定位置发射超级武器（505）
向指定位置发射一个超级武器。
ID=ActionCount,<Action1>,505,0,0,<SuperWeaponTypesIndex>,<HouseIndex>,<CoordinateX>,<CoordinateY>,A,<ActionX>
HouseIndex 可以设定的内容见下表：
HouseIndex	描述
>=0	地图里的所属序号
4475-4482	类似所属序号中的0-7
-1	随机挑选一个非中立所属
-2	第一个中立所属
-3	随机挑选一个人类玩家
CoordinateX和CoordinateY可以设定正值或-1，设定为-1时为在地图可见范围内随机取值。
 
 
在指定路径点发射超级武器（506）
向指定的路径点发射一个超级武器。
ID=ActionCount,<Action1>,506,0,0,<SuperWeaponTypesIndex>,<HouseIndex>,<WaypointIndex>,0,A,<ActionX>
HouseIndex 对应数的具体内容可以参考行为505的表格。
 
 
设定MCV是否可重新部署（510）
通过设置<MCVRedeploy>强制设定MCV是否可以重新部署。
ID=ActionCount,<Action1>,510,0,0,<MCVRedeploy>,0,0,0,A,<ActionX>
 
 
 
该所属拥有/未持有某TechnoType（601-602）
601：触发该触发当某所属拥有至少一个某TechnoType
602：触发该触发当某所属未拥有至少一个某TechnoType
ID=EventCount,...,[EVENTID],2,[HouseIndex],[Technotype],....
新增的脚本
脚本序号在b28发生了更改，更改前的序号使用银灰色标出
 
常规目标类型攻击行为（10000-10001,10005-10006,10010-10011,10014-10015）（74-81）
这些行为指示TeamType如何使用小队成员接近并攻击由第二个参数给定的目标，该参数是一个预先定义好的通用组别。基于威胁度的攻击行为会参考rulesmd.ini的TargetSpecialThreatCoefficientDefault和EnemyHouseThreatBonus标签。所有Aircrafts在攻击其他空中单位时将结束该脚本。这一行为是有意的，如果缺少这一行为则Aircrafts将在开发该功能的当下存在某些无法修复的bug。
i,n
可以使用的行为i与参数n的值具体对应的内容见下表：
行为	重复	目标优先级	描述
10000 76 	是	更近	 
10001 80 	否	更近	当一个小队成员摧毁给定目标时结束
10005 77 	是	更远	 
10006 81 	否	更远	当一个小队成员摧毁给定目标时结束
10010 74 	是	更近时更高威胁	 
10011 78 	否	更近时更高威胁	当一个小队成员摧毁给定目标时结束
10014 75 	是	更远时更高威胁	 
10015 79 	否	更远时更高威胁	当一个小队成员摧毁给定目标时结束
值	目标类型	描述
1	任意目标	任意敌方VehicleTypes，AircraftTypes，InfantryTypes和BuildingTypes
2	建筑	任何不含Artillary=yes，TickTank=yes，ICBMLauncher=yes或SensorArray=yes的敌方BuildingTypes
3	矿车	任何含有Harvester=yes或ResourceGatherer=yes的敌方VehicleTypes，以及含有ResourceGatherer=yes的敌方BuildingTypes
4	步兵	任意敌方InfantryTypes
5	载具	任何含有Artillary=yes，TickTank=yes，ICBMLauncher=yes和SensorArray=yes的敌方VehicleTypes，AircraftTypes，BuildingTypes
6	工厂	任何含有Factory设定的敌方BuildingTypes
7	防御建筑	任何含有IsBaseDefense=yes的敌方BuildingTypes
8	所属方威胁	任何将小队所属方的任何单位作为目标的敌方对象，或者任何接近小队队长的敌人
9	发电厂	任何含有正数值Power的敌方BuildingTypes
10	驻扎建筑	任何被步兵驻扎的BuildingTypes
11	科技建筑	任何含有Unsellable=yes，Capturable=yes，负数值TechLevel或出现在[AI]►NeutralTechBuildings列表上的BuildingTypes
12	矿石精炼厂	任何含有Refinery=yes或ResourceGatherer=yes的敌方BuildingTypes及含有ResourceGatherer=yes和Harvester=no的敌方VehicleTypes
13	心灵控制者	任何拥有带MindControl=yes弹头的武器的VehicleTypes，AircraftTypes，InfantryTypes及BuildingTypes
14	空中单位	任意敌方的AircraftTypes及飞行的VehicleTypes和InfantryTypes
15	海上目标	任何含有Naval=yes的敌方BuildingTypes和VehicleTypes，以及在水面单元格上的敌方VehicleTypes，AircraftTypes，InfantryTypes
16	干扰者	任何含有正数值InhibitorRange，RadarJamRadius及 CloakGenerator=yes或GapGenerator=yes的敌方对象
17	地面载具	任何不含Naval=yes的敌方VehicleTypes，着陆的AircraftTypes及由载具部署而来的BuildingTypes
18	经济单位	任何含有Harvester=yes或ResourceGatherer=yes的敌方VehicleTypes，及含有Refinery=yes，ResourceGatherer=yes或OrePurifier=yes的敌方BuildingTypes
19	兵营	任何含有Factory=InfantryType的敌方BuildingTypes
20	战车工厂	任何含有Naval=no和Factory=UnitType的敌方BuildingTypes
21	机场	任何含有Factory=AircraftType 的敌方BuildingTypes
22	雷达	任何含有Radar=yes或SpySat=yes的敌方BuildingTypes
23	科技实验室	任何在[AI]►BuildTech列表上的敌方BuildingTypes
24	船坞	任何含有Naval=yes和Factory=UnitType 的敌方BuildingTypes
25	超级武器	任何含有SuperWeapon，SuperWeapon2或SuperWeapons的敌方BuildingTypes
26	建造厂	任何含有ConstructionYard=yes和Factory=BuildingType的敌方BuildingTypes
27	中立	任意中立对象 (Civilian) 
28	发生器	任何含有CloakGenerator=yes或GapGenerator=yes的敌方BuildingTypes
29	雷达干扰器	任何含有正数值RadarJamRadius的敌方BuildingTypes
30	屏蔽器	任何含有正数值InhibitorRange的敌方BuildingTypes
31	海军	任何含有Naval=yes的敌方VehicleTypes，或在水面单元格上的敌方VehicleTypes，AircraftTypes，InfantryTypes
32	机动单位	任意VehicleTypes，AircraftTypes和InfantryTypes
33	可占领目标	任何含有Capturable=yes或同时有BridgeRepairHut=yes和Repairable=yes的BuildingTypes
34	区域威胁	任何处于小队队长的警戒范围内的敌方对象
35	战争工厂和船坞	任何含有Factory=UnitType的敌方BuildingTypes
36	非防御建筑	任何含有IsBaseDefense=no的敌方BuildingTypes
 

 
AITargetTypes攻击行为（10002-10004,10007-10009,10012-10013,10016-10017）（84-91,104-105）
这些行为指示TeamType如何使用小队成员接近并攻击由第二个参数给定的目标，第二个参数是基于0的[AITargetTypes]中的索引。基于威胁度的攻击行为会参考rulesmd.ini的TargetSpecialThreatCoefficientDefault和EnemyHouseThreatBonus标签。所有Aircrafts在攻击其他空中单位时将结束该脚本。这一行为是有意的，如果缺少这一行为则Aircrafts将在开发该功能的当下存在某些无法修复的bug。
i,n
可以使用的行为i的值具体对应的内容见下表：
行为	重复	目标优先级	描述
10002 86	是	更近	 
10003 90	否	更近	当一个小队成员摧毁给定目标时结束
10004 104 	是	更近	从列表中随机选择一个目标
10007 87 	是	更远	 
10008 91 	否	更远	当一个小队成员摧毁给定目标时结束
10009 105 	是	更远	从列表中随机选择一个目标
10012 84 	是	更近时更高威胁	 
10013 88 	否	更近时更高威胁	当一个小队成员摧毁给定目标时结束
10016 85 	是	更远时更高威胁	 
10017 89 	否	更远时更高威胁	当一个小队成员摧毁给定目标时结束
参数n为注册表[AITargetTypes]中的索引，指定了可用的VehicleTypes，AircraftTypes，InfantryTypes和BuildingTypes列表。要使本脚本正常工作，需要在rulesmd.ini中声明[AITargetTypes]，然后将可能被选择的目标列举在里面同一项里注册，作为一个分组。例如：
在rulesmd.ini中
[AITargetTypes]
0=E1,MTNK,ORCA
1=HTNK,NACNST
 
 
移动小队至单位地点（10050-10061）（95-102,106-109）
这些行为指示TeamType如何使用小队成员接近并攻击由第二个参数给定的目标。
i,n
可以使用的行为i和参数n的值具体对应的内容见下表：
行为	参数	目标方	目标优先级	描述
10050 95	脚本74-81中的目标类型参数	敌方	更近时更高威胁	 
10051 99	rulesmd.ini中AITargetTypes注册表中对应的索引	敌方	更近时更高威胁	 
10052 106	rulesmd.ini中AITargetTypes注册表中对应的索引	敌方	更近	从被选中的列表中随机选择一个目标
10053 97	脚本74-81中的目标类型参数	友方	更近	 
10054 101	rulesmd.ini中AITargetTypes注册表中对应的索引	友方	更近	 
10055 108	rulesmd.ini中AITargetTypes注册表中对应的索引	友方	更近	从被选中的列表中随机选择一个目标
10056 96	脚本74-81中的目标类型参数	敌方	更远时更高威胁	 
10057 100	rulesmd.ini中AITargetTypes注册表中对应的索引	敌方	更远时更高威胁	 
10058 107	rulesmd.ini中AITargetTypes注册表中对应的索引	敌方	更远	从被选中的列表中随机选择一个目标
10059 98	脚本74-81中的目标类型参数	友方	更远	 
10060 102	rulesmd.ini中AITargetTypes注册表中对应的索引	友方	更远	 
10061 109	rulesmd.ini中AITargetTypes注册表中对应的索引	友方	更远	从被选中的列表中随机选择一个目标
 
 
时效性区域警戒（10100）（71）
可以使单位进入一段时间的区域警戒模式。类似脚本5，但是使用的是更具攻击性的区域境界动作。
10100,<seconds> 71,<seconds>

 
等待直到装满弹药（10101）（73）
当小队内所有成员弹药满时继续执行下一个动作。
10101,0  73,0
 
 
于小队队长周围暂时集结（10102）（112）
将使小队成员在小队队长附近进入给定时长的区域警戒状态(该单位将在行为结束前几乎无法移动)。对队长周围的默认半径定义来自于[General]►CloseEnough，其余单位将不会离开这一范围。
10102,<seconds>  112,<seconds>
 
 
向载具中装载（10103）（72）
使该小队内的所有非载具单位进入载具。在战役中，下一条脚本必须为脚本43，否则脚本将不会继续。
10103,0  72,0
 
 
超时空至敌方基地附近（10104）
使用第一个可用的Type=Chronosphere超级武器，将TeamType的成员转移到敌人基地附近指定范围内的位置（指定范围：[General]►AISafeDistance指定的值加上<value>定义的额外距离，value可以是负值）。该超级武器必须充能到[General]►AIMinorSuperReadyPercent指定的百分比。
10104,<value>
 
 
如果未发现目标则等待（12000）（92）
在执行10000-100017之前（在执行74-81和84-91之前）执行，第二个参数代表这些脚本未找到目标时的重试次数，0代表无限次重试。
12000,<value>  92,<value>
 
 
自定义目标距离（12001）（103）
在脚本10050-10061执行前（在脚本95-102,106-109执行前）设定在其小队队长抵达目标周围多少距离视为完成。默认[General]►CloseEnough。此动作首次生效后就失效，即下次移动动作会恢复使用默认值。
12001,<range>  103,<range>
 
 
设置移动动作结束模式（12002）（110）
由第二个参数决定在脚本95-102,106-109执行前设定其完成方式。默认小队队长抵达最小距离时完成。此动作首次生效后就失效，即下次移动动作会恢复使用默认值。
12002,n  110,n
可以使用的参数n的值具体对应的内容见下表：
参数	描述
0	小队队长抵达最小距离
1	一个单位抵达最小距离
2	所有成员抵达最小距离
 
 
小队的触发权重奖励（14000）（93）
在执行74-81和84-91之前执行，代表这些脚本每击杀一个目标单位时增加的触发权重。第二个参数必须是正数。
14000,<value>  93,<value>
 
 
增加AI触发当前权重（14001）（83）
当该脚本行为被执行时，它将增加AI触发当前的权重。当前权重将不会逾越AI触发的权重上下限。要注意的是同个AI触发下的所有TeamTypes或早或晚都会更新当前权重。第二个参数是一个正值。要注意游戏本体在计算触发周期的当前权重时只采用两个小队中的第一个,而该行为将无视该小队是其中哪个，当前权重都将在行为被执行时进行计算。
14001,<value>  83,<value>
 
 
降低AI触发当前权重（14002）（82）
当该脚本行为被执行时，它将降低AI触发当前的权重。当前权重将不会逾越AI触发的权重上下限。要注意的是同个AI触发下的所有TeamTypes或早或晚都会更新当前权重。第二个参数是一个正值。要注意游戏本体在计算触发周期的当前权重时只采用两个小队中的第一个,而该行为将无视该小队是其中哪个，当前权重都将在行为被执行时进行计算。
14002,<value>  82,<value>
 
 
取消任务执行成功（14003）（111）
相当于脚本49的反向执行效果，即脚本49的失败效果。
14003,0  111,0
 
 
启动定时跳转到下一行（16000）（126）
当计时器结束时，再次执行相同脚本，计时器重复运作，直到被脚本16002（脚本124）停止或小队被摧毁。
16000,<frame>  126,<frame>
 
 
启动定时跳转到下一行（16001）（125）
当计时器结束时，停止这条脚本并执行下一条。
16001,<frame>  125,<frame>
 
 
停止定时跳转（16002）（124）
如果定时跳转被激活，此操作将停止定时跳转。
16002,<0>  124,<0>
 
 
随机跳过下一动作（16003）（113）
执行时挑选一个1-100之间的随机数，如果此数值小于等于第二个参数，则跳过下一个动作。第二个参数为0时，下一个脚本一定会执行；为100时，下一个脚本一定不会执行。
16003,<value>  113,<value>
 
 
抽选一个随机脚本（16004）（94）
执行此动作将会随机挑选一个脚本，并替换当前脚本。第二个参数是基于0的[AIScriptsList]中的索引。
16004,n  94,n
参数n为注册表[AIScriptsList]中的索引，指定了可用的ScriptTypes列表。要使本脚本正常工作，需要在rulesmd.ini中声明[AIScriptsList]，然后将可能被选择的脚本类型列举在里面同一项里注册，作为一个分组。例如：
在rulesmd.ini中
[AIScriptsList]
0=0C9C878C-G,0CE4CC8C-G
1=0D09293C-G,0CADDDBC-G,0CE3381C-G
 
 
编辑变量（18000-18023）（500-523）
计算一个变量的值。由于某些原因，变量的类型是int16而不是像触发动作中那样是int32，意味着值域范围为-32768到32767。超过此范围可能会引起预期外的效果。
i,<value>
 
 
通过局部变量编辑变量（18024-18047）（524-547）
通过局部变量的值计算变量的值。类似脚本18000-18023（类似脚本500-523），但是数字的值由局部变量中读取。
i,<value>
 
 
通过全局变量编辑变量（18048-18071）（548-571）
通过全部变量的值计算变量的值。类似脚本18000-18023（类似脚本500-523），但是数字的值由全局变量中读取。
i,<value>
AI对基地节点和建筑的修复
在单人战役中，AI现在可以通过设置SW(ARES)来修复基地节点/建筑。
[Country House]►RepairBaseNodes= (boolean)
填写三个值，表示AI在简单/普通/困难游戏难度中是否会修复建筑节点。默认no,no,no。
载入图默认值
 
在missionmd.ini中：
[Defaults]►DefaultLS640BriefLocX= (integer) 
载入图(640x480)简报位置默认左边距。默认0。
[Defaults]►DefaultLS640BriefLocY= (integer) 
载入图(640x480)简报位置默认上边距。默认0。
[Defaults]►DefaultLS800BriefLocX= (integer) 
载入图(800x600)简报位置默认左边距。默认0。
[Defaults]►DefaultLS800BriefLocY= (integer) 
载入图(800x600)简报位置默认上边距。默认0。
[Defaults]►DefaultLS640BkgdName= (filename - excluding the .shp extension) 
载入图(640x480)默认背景图。
[Defaults]►DefaultLS800BkgdName= (filename - excluding the .shp extension)
载入图(800x600)默认背景图。
[Defaults]►DefaultLS800BkgdPal= (filename - excluding the .pal extension) 
载入图的背景图使用的默认色盘。应用于640x480和800x600。
MCV重新部署
在地图文件中：
[Basic]►MCVRedeploys= (boolean) 
MCV是否可以重新部署，覆盖[MultiplayerDialogSettings]►MCVRedeploys= 。默认false。
通关简报
原本需要在地图文件中的[Ranking]项设置的通关简报和最佳时间，现在也可以在missionmd.ini中设置。 
优先级高于地图文件，未设置则读取地图文件的对应项。  
在missionmd.ini中：
[SOMEMISSION]►Ranking.ParTimeEasy= (time string [hh:mm:ss])
简单难度的最佳时间。
[SOMEMISSION]►Ranking.ParTimeMedium= (time string [hh:mm:ss])
中等难度的最佳时间。
[SOMEMISSION]►Ranking.ParTimeHard= (time string [hh:mm:ss]) 
困难难度的最佳时间。
[SOMEMISSION]►Ranking.UnderParTitle= (CSF entry key) 
用时未超过最佳时间时的简报标题。
[SOMEMISSION]►Ranking.UnderParMessage= (CSF entry key) 
用时未超过最佳时间时的简报内容。
[SOMEMISSION]►Ranking.OverParTitle= (CSF entry key)
用时超过最佳时间时的简报标题。
[SOMEMISSION]►Ranking.OverParMessage= (CSF entry key) 
用时超过最佳时间时的简报内容。
载入后显示简报
[SOMEMISSION]►BriefingTheme= (Theme name) 
简报指定的背景音乐，未设置则播放载入音乐。该音乐会循环播放直至继续游戏。
注意：背景音乐优先级：missionmd.ini > 地图文件 > rulesmd.ini
 
在地图文件中： 
[Basic]►ShowBriefing= (boolean) 
是否在载入后显示简报。
[Basic]►BriefingTheme= (Theme name) 
简报指定的背景音乐。
 
在uimd.ini中： 
[UISettings]►ShowBriefingResumeButtonLabel= (CSF entry key) 
该简报界面的 继续游戏 按钮标签文本。默认与简报界面相同。
[UISettings]►ShowBriefingResumeButtonStatusLabel= (CSF entry key) 
该简报界面的 继续游戏 按钮标签状态栏文本。默认与简报界面相同。
 
在RA2MD.ini中：
[Phobos]►ShowBriefiing=(boolean) 
全局调整是否在单人任务开始时显示简报。
动画粒子系统
附加粒子系统
现在可以将粒子系统附加到动画中。只支持带有BehavesLike=Smoke的粒子系统。类比VoxelAnims。
[Animation]►AttachedSystem= (ParticleSystem)
动画附加的粒子系统。
注意：在指定的下一个动画(Next=)中，如果定义了不同的粒子系统，则在其开始播放时，会删除掉原粒子系统，并创建一个新的粒子系统。
NotHuman步兵随机死亡动画
有NotHuman=yes的步兵现在可以播放在Die1到Die5中随机播放死亡动画序列，而非只有硬编码的Die1。

[InfantryType]►NotHuman.RandomDeathSequence= (boolean)
是否能够随机播放死亡动画序列。默认yes。
自定义辐射类型
现在允许为武器自定义辐射的类型。
[Weapon]►RadType= (RadiationType)
武器的辐射类型，默认Radiation。
注意：自定义辐射需要新增一个注册表[RadiationTypes]并在里面注册。
 
默认情况下会使用[Radiation]中的RadApplicationDelay 而不是自定义辐射中的。 
[Radiation]►UseGlobalRadApplicationDelay= (boolean)
是否使用全局定义的RadApplicationDelay。默认yes。
 
以下是自定义辐射类型的可用语句：
[RadiationType]►RadDurationMultiple= (integer)
辐射系数（RedLevel*RadDurationMultiple为辐射的持续时间）。
[RadiationType]►RadApplicationDelay= (integer)
辐射伤害间隔。
[RadiationType]►RadApplicationDelay.Building= (integer)
同上，不过是对于建筑。
[RadiationType]►RadBuildingDamageMaxCount= (integer)
一帧里最多伤害建筑的次数，默认0，表示无限制。
[RadiationType]►RadLevelMax= (integer)
RadLevel的最大值。
[RadiationType]►RadLevelDelay= (integer)
辐射衰减的间隔。
[RadiationType]►RadLightDelay= (integer)
辐射光照衰减的间隔。
[RadiationType]►RadLevelFactor= (double)
每个RadLevel造成的伤害。
[RadiationType]►RadLightFactor= (double)
辐射的光照强度系数。
[RadiationType]►RadTintFactor= (double)
辐射的颜色系数。
[RadiationType]►RadColor= (R,G,B)
辐射的颜色。
[RadiationType]►RadSiteWarhead= (Warhead)
辐射伤害的弹头。
[RadiationType]►RadSiteWarhead.Detonate= (boolean)
是否在受到辐射伤害的单位上引爆辐射所用弹头而不是仅用弹头造成伤害，以此可以实现大部分弹头效果。默认no。
[RadiationType]►RadHasOwner= (boolean)
辐射伤害是否视为发射者所属造成的，如果设定为yes则会读取辐射弹头上的AffectsAllies等标签，辐射的击杀数也会正常计算。默认no。
[RadiationType]►RadHasInvoker= (boolean)
辐射伤害是否视为发射者造成的，如果设定为yes则除了RadHasOwner的效果之外，发射者还可以正常获取被辐射杀死的单位的经验。默认no。
自定义奴隶解放效果

现在可以自定义在奴隶矿场死亡时奴隶解放的效果了。

[InfantryType]►Slaved.OwnerWhenMasterKilled= (enum suicide|master|killer|neutral)
奴隶被解放时的效果。suicide为直接死亡；master为归为原本所属；killer为归为击杀者所属；neutral为变为中立所属。默认killer。
[InfantryType]►SlavesFreeSound= (sound)
现在可以单独给每个奴隶自定义奴隶的解放声音。
自定义步兵匍匐和部署的开火动画位置
现在可以为步兵设置匍匐和部署时开火动画的位置了。支持和Burst开火坐标混用，只需在对应标签后加上.BurstN即可。
artmd.ini中：
[TechnoType]►PronePrimaryFireFLH= (F,L,H)
匍匐时主武器的开火位置。
[TechnoType]►ProneSecondaryFireFLH= (F,L,H)
匍匐时副武器的开火位置。
[TechnoType]►DeployedPrimaryFireFLH= (F,L,H)
部署时主武器的开火位置。
[TechnoType]►DeployedSecondaryFireFLH= (F,L,H)
部署时副武器的开火位置。
自定义变卖音效和EVA
[TechnoType]►SellSound= (sound)
微观定义单位变卖时的音效。
自定义单位染色
类似于被铁幕或力场护盾覆盖，现在可以完全自定义单位出厂就染成什么颜色
[TechnoType]►Tint.Color= (interger)
定义该单位染的颜色。
[TechnoType]►Tint.Intensity= (float)
定义该单位被染的颜色强度。
[TechnoType]►Tint.VisibleToHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
定义该染色可以被哪些所属看见。
自定义动画可见性
注意：这是一个纯视觉功能，任何附加在动画上的逻辑,例如伤害,仍然会在所有所属方同步处理。
在artmd.ini中：
[Animation]►VisibleTo= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
定义哪些所属方可以看到动画。默认all。
[Animation]►VisibleTo.ConsiderInvokerAsOwner=(boolean)
使动画的发射者所属方被视为VisibleTo的动画所有者，而不是动画所附着的科技类型的所属方或动画的当前所属方。
在大多数动画中，它们是相同的，但对于某些动画来说可能会有所不同。默认false。
[Animation]►RestrictVisibilityIfCloaked=(boolean)
定义隐形状态下物体的附着动画或飞机Trailer=的动画（由于技术原因，目前不包括子机导弹的Trailer动画）
是否仅对观察者或侦测到隐形物体的所属方可见。默认false。
[Animation]►DetachOnCloak=(boolean)
定义物体隐形时是否移除所附着的动画,默认true。
Jumpjet单位的增强

自定义Jumpjet浮动图层
原版中，Jumpjet的高度在JumpjetHeight以下时使用Air图层，否则使用Top图层。此逻辑允许将Jumpjet锁定在Air图层。

[JumpjetControls]►AllowLayerDeviation= (boolean)
Jumpjet是否会根据当前高度和JumpjetHeight或[JumpjetControls]►CruiseHeight的关系在air图层和top图层之间切换。如果设置为no则锁定在air图层。默认yes。
[TechnoType]►JumpjetAllowLayerDeviation= (boolean)
同上，用于微观单位设定。默认[JumpjetControls]►AllowLayerDeviation。
 
 
B36被移除，现整合进武器的OmniFire里：
Jumpjet开火时面向目标
修复Jumpjet在攻击范围内目标时不能转向其他方向的问题。

[JumpjetControls]►TurnToTarget= (boolean)
Jumpjet在开火时是否会面向目标。默认no。
[TechnoType]►JumpjetFacingTarget= (boolean)
同上，用于微观单位设定。默认[JumpjetControls]►TurnToTarget。 
IsSimpleDeployer自动部署
[TechnoType]►Ammo.AutoDeployMinimumAmount= (integer)
定义载具自动部署所需要的最小弹药数，默认-1
[TechnoType]►Ammo.AutoDeployMaximumAmount= (integer)
定义载具若想自动部署则不能超过这个范围，默认-1
[TechnoType]►Ammo.DeployUnlockMinimumAmount= (integer)
定义载具自动解除部署所需要的最小弹药数，默认-1
[TechnoType]►Ammo.DeployUnlockMaximumAmount= (integer)
定义载具若想自动解除部署则不能超过这个范围，默认-1
以上参数设定为负值意为禁用该项检测。
 
[TechnoType]►Ammo.AddOnDeploy= (integer)
定义单位在部署时获得或失去的弹药数
仅己方可听的出场音效
现在可以设置单位出场的音效是否全场播放
[AudioVisual]►IsVoiceCreatedGlobal=（boolean）
定义单位出厂的VoiceCreate是否全场播放，默认false
[TechnoType]►VoiceCreated=（Sound）
定义单位出厂时播放的声音，定义后不会播放EVA_UnitReady
建造上限组
现在可以设置多种单位共享同一份BuildLimit了
[TechnoType]►BuildLimitGroup.Types=（list of TechnoType Names）
定义由哪些单位共享该建造上限组。注意，该语句不提供任何限制，你必须手动添加建造上限，即BuildLimitGroup.Nums。
[TechnoType]►BuildLimitGroup.Nums=（Integer）
定义该上限组的上限数量。可以写多个数字与BuildLimitGroup.Types里的单位数量相对应。默认情况下，当BuildLimitGroup.Types里的所有单位达到BuildLimitGroup.Nums的值时则禁止建造这些单位。
[TechnoType]►BuildLimitGroup.Factor=（Integer）
定义单位占上限时实际会占用的值。
（人话：枪兵1人口，狂热者2人口）
[TechnoType]►BuildLimitGroup.ContentIfAnyMatch=（boolean）
定义是否建造上限组内的任一单位达到了BuildLimitGroup.Nums的上限后全体单位皆达到上限，默认false。
[TechnoType]►BuildLimitGroup.NotBuildableIfQueueMatch=（boolean）
若设置为true，则实际存活单位和订单里的单位数量相加后，达到了上限后，生产会立刻停止。false则只会考虑实际存活单位。默认false
 
[TechnoType]►BuildLimitGroup.ExtraLimit.Types=（list of TechnoType Names）
当拥有该列表里的任一单位时，用BuildLimitGroup.ExtraLimit.Nums的数值拓展BuildLimitGroup.Nums的值。
（人话：你需要建造更多的补给站）
[TechnoType]►BuildLimitGroup.ExtraLimit.Nums=（integer）
如上，定义一次拓展多少建造上限。也可写多个数字与列表里一一对应。
[TechnoType]►BuildLimitGroup.ExtraLimit.MaxCount=（integer）
定义最多可读取多少BuildLimitGroup.ExtraLimit.Types里的单位。
[TechnoType]►BuildLimitGroup.ExtraLimit.MaxNum=（integer）
定义最多可以提升多少建造上限。
晋升动画
现在可以设置单位或建筑晋升时播放的动画
[AudioVisual]►Promote.VeteranAnimation=（string, animation ID）
定义晋升为老兵时播放的动画。
[AudioVisual]►Promote.EliteAnimation=（string, animation ID）
定义晋升为精英时播放的动画，若不指定则会播放老兵动画。
移交控制权时变形
现在可以设置单位从玩家手里移交给AI或AI移交给玩家时变形的单位
[TechnoType]►Convert.HumanToComputer=（TechnoType）
定义该单位控制权从玩家变为AI时变成的单位。
[TechnoType]►Convert.ComputerToHuman=（TechnoType）
定义该单位控制权从AI变为玩家时变成的单位。
Destroyer寻路摧毁障碍物考虑建筑
原版InfantryDestroyer和AmphibiousDestroyer两种MovementZone的单位会摧毁寻路路径上的障碍，现在将障碍物拓展到了常规建筑对象
这样做的目的是使建筑物可以像围墙类型覆盖物和地形对象那样成为对于每个非飞行单位或不拥有适当MovementZone的单位而言无法直接通过和无法摧毁的寻路障碍物
[BuildingTypes]►IsDestroyableObstacle=(boolean)
定义该建筑是否为可摧毁的寻路障碍物。默认false。
注意：如果单位具有合适的MovementZone却没有摧毁障碍物的能力
（比如缺少能开火并对障碍物造成伤害的武器），该单位在尝试穿越障碍物时会被卡住
而不是绕开障碍物。
水中步兵使用陆地动作序列
在 artmd.ini 中：

[Infantry]►OnlyUseLandSequences=(boolean)
是否仅显示陆地上的常规动作序列，即使步兵在水中。默认false。
武器
自定义AreaFire目标
现在可以指定区域开火的目标了。

[Weapon]►AreaFire.Target= (enum base|self|random)
设置了AreaFire的武器的目标。如果设置为self则会遵循一般瞄准规则对开火者自身开火。如果设置为random则会攻击武器攻击范围内的随机某格，会遵循武器的CanTarget和CanTargetHouses忽略不合格或包含不合格对象的单元格。默认base，即开火者所在单元格。
武器定义BurstDelay
现在支持为武器设定BurstDelay取代原本的BurstDelayX系统。对步兵，载具，建筑类型生效（飞机类型因开火系统完全不同无法支持）。并且允许为每一击都设定间隔，而非仅前四个。

[Weapon]►Burst.Delays= (integer)
设定Burst的武器的开火间隔，如果没有设置对应的间隔，那么就会使用最后设置的间隔。使用-1来取消此逻辑，应用原始的BurstDelay0-3。默认-1。
[Weapon]►Burst.FireWithinSequence= (boolean) 
是否允许步兵在使用含有Burst的武器时，采用同一个的射击序列。
反馈武器
现在可以设定当开火者开火时发射向开火者自身的额外武器，如果开火者作为载员则反馈武器会在载具位置发射。

[Weapon]►FeedbackWeapon= (Weapon)
开火者发射武器的同时在自身位置发射的武器。
自定义飞机扫射
扫射（武器抛射体ROT小于2）现在可以被自定义了。
[Weapon]►Strafing=(boolean)
飞机开火时是否使用扫射，对于抛射体ROT小于2并且Inviso=false的武器默认true，其他默认false。
[Weapon]►Strafing.Shots= (integer)
单轮扫射中武器发射的次数。Ammo仅在一轮扫射结束后扣除，无论一轮开火几次。默认5。Buiild#45开始可以超过5
[Weapon]►Strafing.SimulateBurst= (boolean)
扫射中武器是否模拟Burst的表现，允许偏移开火坐标。仅当Burst=1或未指定时生效。默认no。
[Weapon]►Strafing.UseAmmoPerShot= (boolean)
扫射中武器是否每一发都会消耗弹药，覆盖默认的Ammo仅在一轮扫射结束后扣除的特性，默认no。
武器瞄准筛选
现在可以指定武器可以攻击什么目标或所属方。这也会影响武器选择，除了某些固定情况。

[Weapon]►CanTarget= (enum none|land|water|empty|infantry|units|buildings|all)
武器能够瞄准的对象。需要all或empty以使武器能向没有单位的格子开火。默认all。
[Weapon]►CanTargetHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
武器能够瞄准的所属。默认all。
面向攻击目标

让单位在使用OmniFire=yes的武器攻击目标时，也会尝试转向目标。
此功能主要推荐用于JumpJet=yes的单位。
 
[Weapon]►OmniFire.TurnToTarget= (boolean) 
单位在使用该武器(OmniFire=yes)攻击目标时是否尝试转向目标。
额外弹头

现在可以为武器设定额外的弹头，这些弹头会和原弹头在同一目标单元引爆(在原弹头之后，按列表顺序依次引爆)。

[Weapon]►ExtraWarheads= (list of WarheadTypes) 
武器的额外弹头，可以设置一个或多个，多个弹头直接用逗号隔开。
[Weapon]►ExtraWarheads.DamageOverrides= (list of integers)
额外弹头的伤害值，和上一条语句中的弹头一一对应。如果不设置则按照原武器的伤害值。
[Weapon]►ExtraWarheads.DetonationChances= (list of floating-point or absolute)
定义额外弹头的触发概率，可和上条语句一一对应。
[Weapon]►ExtraWarheads.FullDetonation= (boolean)
用于决定每个独立的弹头是否像完整武器中的弹头那样引爆，或只是造成范围伤害和Phobos弹头效果。
弹头
通用特殊效果

金币弹
[Warhead]►TransactMoney= (integer)
弹头爆炸时所属方获得的资金值，负数为扣除资金。默认0。
[Warhead]►TransactMoney.Display= (boolean)
是否在目标位置显示资金变化数，增加资金为绿色，扣除资金为红色，如果找不到开火者则在目标位置显示。默认no。
[Warhead]►TransactMoney.Display.AtFirer= (boolean)
是否在开火者位置显示资金变化数而不是目标位置。默认no。
[Warhead]►TransactMoney.Display.Houses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
显示的资金变化数可以被哪些阵营看到。默认all。
[Warhead]►TransactMoney.Display.Offset= (X,Y, pixels relative to default) 
调整显示的资金变化数的绘制偏移。负数左/上，正数右/下。默认0,0。

揭示弹与迷雾弹
[Warhead]►SpySat= (boolean)
弹头爆炸时是否为所属方揭露全地图视野。默认no。
[Warhead]►BigGap= (boolean)
弹头爆炸时是否覆盖所属方的敌对方的视野。默认no。

识破伪装与解除心控
[Warhead]►RemoveDisguise= (boolean)
弹头命中目标时是否移除目标的伪装，此逻辑也会生效在通过PermaDisguise获得的默认伪装上。默认no。
[Warhead]►RemoveMindControl= (boolean)
弹头命中目标时是否切断目标的心灵控制，对永久控制无效。默认no。
暴击
暴击逻辑
 
暴击，即基于几率的额外伤害/弹头。现在可以设定某弹头是否会在爆炸时造成暴击伤害。

[Warhead]►Crit.Chance= (float - percentage)
弹头暴击的概率，有效值为0.0到1.0之间。默认0.0。
[Warhead]►Crit.ApplyChancePerTarget= (boolean)
是否对每个命中的目标单独决定是否暴击。默认no。
[Warhead]►Crit.ExtraDamage= (integer)
弹头暴击后造成的额外伤害。默认0。
[Warhead]►Crit.Warhead= (Warhead)
弹头暴击时使用的弹头，如果不设定则使用此弹头。
[Warhead]►Crit.Affects= (enum none|land|water|infantry|units|buildings|all)
何种目标可以被暴击。默认all。
[Warhead]►Crit.AffectsHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
哪个所属方的单位可以被暴击。默认all。
[Warhead]►Crit.AffectBelowPercent= (float - percentage)
低于多少百分比血量的目标会被暴击。默认1.0。
[Warhead]►Crit.AnimList= (list of Animation)
弹头暴击时替代弹头动画播放的的动画。
[Warhead]►Crit.AnimList.PickRandom= (boolean)
暴击时是否随机播放Crit.AnimList中的动画。默认与AnimList.PickRandom相同。
[Warhead]►Crit.AnimList.CreateAll= (boolean)
暴击时是否播放所有Crit.AnimList中的动画，默认与AnimList.CreateAll相同。

[Warhead]►Crit.AnimOnAffectedTargets= (boolean)
暴击动画是否不替代原本的动画而是给每一个被暴击目标播放。默认no。
注意：在b45中，Crit.AnimOnAffectedTargets=true 的弹头在Crit.AnimList.PickRandom未设置时
不会再使用AnimList.PickRandom的设定值作为默认值，如需使用需要定义Crit.AnimList.PickRandom。
并且Crit.AnimOnAffectedTargets=true 的弹头在Crit.AnimList.CreateAll未设置时
不会再使用AnimList.CreateAll的设定值作为默认值，如需使用需要定义Crit.AnimList.CreateAll。
[Warhead]►Crit.SuppressWhenIntercepted= (boolean)
当弹头是从被拦截的武器上引爆时，暴击不会触发。默认no。
 

 
[TechnoType]►ImmuneToCrit= (boolean)
单位是否免疫暴击。默认no。

注意：如果暴击弹头与原弹头为同一个弹头，或创建了一个链式循环暴击，那么游戏有可能卡死或崩溃。
微观定义弹头动画特性
现在允许弹头自定义一些动画特性。
 
[Warhead]►AnimList.PickRandom= (boolean)
是否会从AnimList里随机选择动画播放，和EMEffect相似但不会有对应的副作用。默认false。
[Warhead]►AnimList.CreateAll= (boolean)
是否会生成所有的AnimList动画，默认false。
[Warhead]►AnimList.CreationInterval= (Integer)
若大于0，则AnimList里的动画会在弹头爆炸过对应的次数后才会播放。
[Warhead]►AnimList.ScatterMin= (floating)
弹头的动画的最小散布范围。
[Warhead]►AnimList.ScatterMax= (floating)
弹头的动画的最大散布范围。
[Warhead]►SplashList= (list of Animation)
弹头的水花动画。
[Warhead]►SplashList.PickRandom= (boolean)
弹头的水花动画是否从SplashList的列表中随机选取。默认no。
[Warhead]►SplashList.CreateAll= (list of Animation)
是否会生成所有的弹头的水花动画。默认false
[Warhead]►SplashList.CreationInterval= (list of Animation)
同AnimList。
[Warhead]►SplashList.ScatterMin= (boolean)
同AnimList。
[Warhead]►SplashList.ScatterMax= (boolean)
同AnimList。
触发特定的NotHuman步兵死亡动画序列
现在弹头可以触发指定的NotHuman=yes的步兵的死亡动画序列。

[Warhead]►NotHuman.DeathSequence= (integer)
弹头触发NotHuman=yes的步兵的哪一个死亡序列。范围1-5，代表Die1到Die5。
发射超武

现在可以设置在不同情况下在目标位置发射超级武器了。若要在动画伤害上使用该逻辑则必须设置Damage.DealtByInvoker=yes, 
否则超武不会发射。

[Warhead]►LaunchSW= (list of SuperWeaponTypes)
在对应常规弹头所引爆的格子上发射的超级武器列表。目前Ares中的动画弹头和动画武器都无法生效。
[Warhead]►LaunchSW.RealLaunch= (boolean)
发射的超级武器是否必须为所属方目前现有的超武，否则无法发射。默认yes。
[Warhead]►LaunchSW.IgnoreInhibitors= (boolean)
发射的超级武器是否忽略抑制者。默认no。
[Warhead]►LaunchSW.IgnoreDesignators= (boolean)
发射的超级武器是否忽略指示者。默认yes。
在地图上所有目标上引爆弹头

现在可以设定武器的弹头是否作用于全地图的目标了。
该弹头包括 武器弹头 动画武器弹头 和 暴击弹头。不包括 动画弹头 和 ARES的通用弹头超武GenericWarhead。 
 
注意：该效果发生在PreImpactAnim(ARES的弹头缓冲动画)之后。

[Warhead]►DetonateOnAllMapObjects= (boolean)
弹头是否作用于地图上的每个目标，空爆和溅射等效果会在每个目标上触发。默认no。
[Warhead]►DetonateOnAllMapObjects.AffectTargets= (enum aircraft|buildings|infantry|units|all)
弹头能够作用的目标类型。默认all。
[Warhead]►DetonateOnAllMapObjects.AffectHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
弹头能够作用的目标所属。默认all。
[Warhead]►DetonateOnAllMapObjects.AffectTypes= (list of TechnoTypes)
弹头能够作用的对象，如果不设置则可以作用于所有对象。
[Warhead]►DetonateOnAllMapObjects.IgnoreTypes= (list of TechnoTypes)
弹头不能作用的对象。
[Warhead]►DetonateOnAllMapObjects.RequireVerses= (boolean)
弹头作用目标时是否读取弹头比，只有非0弹头比的目标才能被作用。默认no。

警告：虽然此功能可以提供比设置极大的CellSpread更好的效果，但它仍然有可能减慢游戏速度，尤其是当与动画、alpha灯光等同时使用时。建议限制作用对象来减小影响。
单位转换弹头
现在可以将受弹头影响的单位转换为同一类别的其他单位
注意：只能转换同一类型，步兵对步兵，载具对载具，飞行器对飞行器。
 
可以指定多种同一类型的单位转换为相同的单位，转换结果只能指定一个。
以下语句中的N可以不写，或者填写整数0,1,2…。
[Warhead]►ConvertN.From= (list of TechnoTypes)
指定哪些单位会被转换。如果不填，则转换所有有效目标。
[Warhead]►ConvertN.To=(TechnoType)
被影响的单位会被转换成什么。
[Warhead]►ConvertN.AffectedHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
哪些所属方会被转换弹头影响，默认team。
 
警告：目前此功能与ARES的类型转换具有相同的限制，不支持建筑类型[BuildingTypes]，也可能会出现同于ARES的BUG。
此功能需要ARES 3.0或更高版本才能运行！否则单位的部分属性将无法更新。
穿透铁幕弹头

现在可以设置弹头是否可以穿透铁幕或立场护盾了。PenetratesForceShield默认同PenetratesIronCurtain
注意：穿透铁幕并不会产生其他的弹头特殊效果，仅有和伤害相关的效果才会生效（例如Psychedelic）。碎片和空爆如果没有正确明中目标则也不会生效

 
[Warhead]►PenetratesIronCurtain= (boolean)
该弹头是否无视铁幕造成伤害
[Warhead]►PenetratesForceShield= (boolean)
该弹头是否无视力场护盾造成伤害
弹头生成箱子
现在允许弹头引爆的格子上生成工具箱。若生成地点无效会在附近的有效地点生成。

[Warhead]►SpawnsCrateN.Type= (enum money|unit|healbase|cloak|explosion|napalm|squad|reveal|armor|speed|firepower|icbm|invulnerability|veteran|ionstorm|gas|tiberium|pod)
定义弹头生成的工具箱种类，N可以不写，或者写整数1，2，3......
[Warhead]►SpawnsCrateN.Weight= (interger)
定义弹头生成的工具箱的权重列表。数字越大权重越高，生成概率越高。默认1。
注意：若未定义N，则SpawnsCrate.Type/Weight和SpawnsCrate0.Type/Weight是一样的效果。
自定义移除寄生
默认情况下，如果单位受到弹头的负数伤害（在计算Verses之前），
该单位内的寄生单位都会被清除和删除。这种行为现在可以自定义，
以禁用负数伤害的移除寄生特性，或使任意弹头获得移除寄生特性。

[Warhead]►RemoveParasite=(boolean)
定义该弹头是否能移除寄生单位。

抛射体
拦截抛射体
[TechnoType]►Interceptor.Weapon= (integer)
拦截抛射体时使用的武器，0为主武器，1为副武器。默认0。
[TechnoType]►Interceptor.CanTargetHouses= (enum owner/self|allies/ally|team|enemies/enemy|all)
拦截抛射体时能够拦截哪个所属的抛射体。默认enemies。
[TechnoType]►Interceptor.GuardRange= (float - cell range)
单位拦截抛射体的范围。默认0.0。
[TechnoType]►Interceptor.VeteranGuardRange= (float - cell range)
同上，用于老兵级时。
[TechnoType]►Interceptor.EliteGuardRange= (float - cell range)
同上，用于精英级时。
[TechnoType]►Interceptor.MinimumGuardRange= (float - cell range)
单位拦截抛射体的最小范围。默认0.0。
[TechnoType]►Interceptor.VeteranMinimumGuardRange= (float - cell range)
同上，用于老兵级时。
[TechnoType]►Interceptor.EliteMinimumGuardRange= (float - cell range)
同上，用于精英级时。
[TechnoType]►Interceptor.DeleteOnIntercept= (boolean)
拦截抛射体时被拦截的抛射体是否直接消失而不是爆炸，覆盖抛射体的Interceptable.DeleteOnIntercept。默认no。
[TechnoType]►Interceptor.WeaponOverride= (Weapon)
拦截抛射体时用该武器的弹头和伤害替换被拦截抛射体原本的伤害和弹头，覆盖抛射体的Interceptable.WeaponOverride。
[TechnoType]►Interceptor.WeaponReplaceProjectile= (boolean)
上一条生效时是否同时替换被拦截抛射体的抛射体属性和速度。不能替换附加的粒子系统。默认no。
[TechnoType]►Interceptor.WeaponCumulativeDamage= (boolean)
在Interceptor.WeaponOverride生效时是否将伤害叠加在原来的抛射体上而不是替换。默认no。
[TechnoType]►Interceptor.KeepIntact= (boolean)
拦截抛射体时被拦截的抛射体是否会像没有被拦截时一样继续移动，但Interceptor.WeaponOverride的效果依然生效。默认no。

 
[Projectile]►Interceptable= (boolean)
抛射体是否可被拦截。默认no。
[Projectile]►Interceptable.DeleteOnIntercept= (boolean)
抛射体被拦截时是否直接消失而不是爆炸。默认no。
[Projectile]►Interceptable.WeaponOverride= (Weapon)
抛射体被拦截时用该武器的弹头和伤害替换原本的伤害和弹头。
[Projectile]►Strength= (integer)
抛射体的耐久度。默认0。
[Projectile]►Armor= (ArmorType)
抛射体的护甲类型。
抛射体轨迹

抛射体现在可以用几种自定义轨迹。不允许与原版的抛射体轨迹（Arcing，ROT或Inviso）混合使用。

[Projectile]►Trajectory= (enum Straight|Bombard)
抛射体的轨迹类型。Straight为直线射击的轨迹；Bombard为轰击弹道，类似直线弹道，但是攻击目标上方的坐标点。当抛射体接近坐标点后会自由落体，并在接触到地面或目标后爆炸。
[Projectile]►Trajectory.Bombard.Height= (double)
Trajectory设定为Bombard时，抛射体发射至目标上方开始落下的高度。
[Projectile]►Trajectory.Speed= (double) 
设定了Trajectory的抛射体的初始速度。
注意：Trajectory.Speed在Phobos b29及之前应该写在[Weapon] 中。 
 
[Projectile]►Trajectory.Straight.DetonationDistance= (double)
定义该抛射体距离预定目标多少距离时会直接引爆的最大距离，默认为0.4（若设置为0则可能导致抛射体“飞越”目标）。
[Projectile]►Trajectory.Straight.TargetSnapDistance= (double)
定义该抛射体爆炸时会“瞬移”到原定目标上的最大距离，默认为0.5。
[Projectile]►Trajectory.Straight.PassThrough= (boolean)
定义该抛射体是否在爆炸后继续飞行一段距离，抛射体飞行的距离由Trajectory.Straight.DetonationDistance定义。
溅射增强
溅射行为现在可以被地面或建筑触发。

[Projectile]►Shrapnel.AffectsGround= (boolean)
溅射是否被地面上触发。默认no。
[Projectile]►Shrapnel.AffectsBuildings= (boolean)
溅射是否被建筑上触发。默认no。
[Projectile]►Shrapnel.UseWeaponTargeting= (boolean)
溅射子武器是否遵循LegalTarget，Verses或者主武器的索敌设置，默认no。
阻拦抛射体
现在抛射体可以将陆地和水域视为障碍物，发动攻击的单位会认为被陆地/水域阻拦的目标在射程之外，从而重新寻找不会被阻拦的位置。
  
[Projectile]►SubjectToLand= (boolean) 
抛射体是否会被陆地阻拦。
[Projectile]►SubjectToLand.Detonate= (boolean) 
抛射体被陆地阻拦时是否会直接爆炸。默认yes。
[Projectile]►SubjectToWater= (boolean) 
抛射体是否会被水域阻拦。
[Projectile]►SubjectToWater.Detonate= (boolean) 
抛射体被水域阻拦时是否会直接爆炸。默认yes。
抛射体反馈
在某种程度上类似于空爆AirburstWeapon或溅射ShrapnelWeapon。
  
[Projectile]►ReturnWeapon= (WeaponType) 
抛射体反馈给开火者的武器。
超级武器
虚拟投放
超级武器现在可以投放不在地图上的建筑，好似他们在地图上一样。

[SuperWeapon]►LimboDelivery.Types= (list of BuildingTypes)
超武生效后创建的建筑列表。超武类型和发射位置并不重要。
[SuperWeapon]►LimboDelivery.IDs= (list of integers)
虚拟投放建筑绑定的ID列表，和第一条一一对应。要使虚拟击杀生效就必须设置。
[SuperWeapon]►LimboDelivery.RollChances= (list of float - percent)
指定虚拟投放的概率列表，和第一条一一对应。默认1.0。
[SuperWeapon]►LimboDelivery.RandomWeightsN= (list of integers)
指定虚拟投放的权重列表，和第一条一一对应。RandomWeights相当于RandomWeights0。每次虚拟投放时都会给对应的建筑增加这些权重，若对应次投放没有指定权重，则使用指定的最后一次权重。N从0开始。
 
[SuperWeapon]►LimboKill.Affected= (enum none|owner/self|allies/ally|team|enemies/enemy|all)
哪些所属方会被移除(虚拟击杀)功能影响，默认Self。
注意：官中目前的LimboKill.Affects=为错误标签。
[SuperWeapon]►LimboKill.IDs= (list of integers)
超武生效后会被移除(虚拟击杀)的虚拟投放建筑的ID列表。

注意：被虚拟投放的建筑不一定会使所有标签生效，以下标签是确定生效的：
工业工厂
矿石精炼器
间谍卫星
续命，即KeepAlive
建造前提
SuperWeapon，SuperWeapon2，SuperWeapons，SW.AuxBuildings，SW.NegBuildings

为了使此逻辑与[AITriggerTypes]条件共同运作，LegalTarget必须为yes

警告：虚拟投放的建筑并不实际存在，一切与其实际交互的机制比如工厂，克隆，维修厂，直升机平台等都不能正常生效。同时也不会被任何地图内威胁影响到。所以此建筑必须要么设置KeepAlive=no，要么可以被虚拟击杀，否则游戏将无法结束。
连续释放
现在可以向超级武器的同一目标发射其他超级武器。 
 
[SuperWeapon]►SW.Next= (list of SuperWeaponTypes)
超武释放时，对超武的目标点发射此处列出的超武。
[SuperWeapon]►SW.Next.RealLaunch= (boolean)
连续释放的超武是否使否必须为 所属方拥有的超武 且 拥有足够的资金，否则无法发射。默认yes 。 
[SuperWeapon]►SW.Next.IgnoreInhibitors= (boolean)
连续释放的超武是否无视超武的抑制者。默认no。
[SuperWeapon]►SW.Next.IgnoreDesignators= (boolean)
连续释放的超武是否无视超武的指示者。默认yes。
[SuperWeapon]►SW.Next.RollChances= (float - percentage)
指定连续释放的概率列表，和被释放的次数一一对应。默认100%即单次释放,必定成功。
该列表作用是决定每次释放成功的概率，第一次释放成功概率值是列表第一项，以此类推，需要要发动几次释放就写几项。
有效值为0%(必定失败)到100%(必定成功)。SW.NegBuilding会在连续释放完成后结算。
[SuperWeapon]►SW.Next.RandomWeightsN= (boolean)
同时指定连续释放的权重列表，每次的权重表和SW.Next一一对应。RandomWeights相当于RandomWeights0。
每次成功释放都会根据该次权重列表向对应的超武赋予这些权重进入抽选，权重越高被选中的概率越大，0则为不会被选中。
根据权重进行抽选而选出的超级武器将进行发射。
若对应次释放没有指定权重，则使用指定的最后一次权重。N从0开始,次数N和RolChance中的项数一一对应，即N-1=对应项数。
在目标单元释放武器或弹头
 
[SuperWeapon]►Detonate.Weapon= (Weapon)
在超武的目标单元释放的武器
[SuperWeapon]►Detonate.Warhead= (Warhead)
在超武的目标单元释放的弹头，如果与Detonate.Weapon同时设定，则本条语句不生效
[SuperWeapon]►Detonate.Damage= (integer)
对超武的目标单元造成的伤害。如果设定了Detonate.Weapon不设定本条语句，则默认为指定武器的伤害；如果设定了Detonate.Warhead不设定本条语句，则默认0。
[SuperWeapon]►Detonate.AtFirer= (boolean)
是否在超武发射者所在的位置释放武器/弹头，而不是在超级武器的目标单元。如果没有发射者，则不会释放武器/弹头。默认no。
单位转换超武
现在可以将受超武影响的单位转换为同一类别的其他单位
注意：只能转换同一类型，步兵对步兵，载具对载具，飞行器对飞行器。单位转换超武还会计入载具内的载员，建筑内的驻军等。
 
可以指定多种同一类型的单位转换为相同的单位，转换结果只能指定一个。
以下语句中的N可以不写，或者填写整数0,1,2…。
[SuperWeapon]►ConvertN.From= (list of TechnoTypes)
指定哪些单位会被转换。如果不填，则转换所有有效目标。
[SuperWeapon]►ConvertN.To=(TechnoType)
被影响的单位会被转换成什么。
[SuperWeapon]►ConvertN.AffectedHouses= (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
哪些所属方会被转换超武影响，默认team。
 
警告：目前此功能与ARES的类型转换具有相同的限制，不支持建筑类型[BuildingTypes]，也可能会出现同于ARES的BUG。
此功能需要ARES 3.0或更高版本才能运行！否则单位的部分属性将无法更新。
自定义AI超武延迟
默认情况下，AI释放超武会有106到112帧的随机延迟。现在可以自定义这一项的值，设置为0或0以下会使AI每帧检查一次是否可以发射超武
 
[General]►AISuperWeaponDelay= (integer)
定义AI释放超武的延迟
自定义超武位置栏
你现在可以将某超武划分到任意四栏目里，0为建筑栏，1为防御栏，2为步兵栏，3为载具栏
 
[Superweapon]►TabIndex= (integer)
定义超武栏的位置，默认1
EMP炮设置
现在可以自定义EMPulseCannon=true建筑在发射关联的EMPulse超武时使用哪个武器发射。
（需要EMPulse.TargetSelf为false或未定义）
[Superweapon]►EMPulse.WeaponIndex=(integer,weapon slot index)
该EMP炮超武使用的武器序号，0为主武器，1为副武器。默认0。
[Superweapon]►EMPulse.SuspendOthers= (boolean)
是否在EMP炮超武发射时暂时禁用其他所有可以和所发射的超武一样从同类建筑发出的EMP炮超武，
直到发射的超武发射完成。默认false。
注意：如果在发射一个EMP炮超武并且该超武的武器还没有开火时发射另一个同一建筑的
具有不同EMPulse.WeaponIndex的可开火EMP炮超武，那么靠后发射的EMP炮超武的相关设置优先生效。
另外，如果超武的SW.RangeMinimum/SW.RangeMaximum未定义，
则超武的瞄准范围默认为建筑主武器的Range/MinimumRange定义的范围。
杂项方面的功能增强
开发者工具
额外同步日志记录
当发生不同步时，Phobos会将额外信息写入SYNC#.txt(#为位置序号)日志文件，例如随机数生成器函数的调用记录、单位朝向/目标/目的地等的更改。

输出目标信息
用以输出选择/悬浮目标信息的快捷键。
该功能需要启用[GlobalControls]>DebugKeysEnabled才能使用。
逐帧模式
新的快捷键键用于逐帧执行游戏，以供开发使用。
在逐帧模式中可以使用不同的前进帧指令来一次前进1/5/10/15/30/60帧。

运动模式别称
现在可以用指定的文字代替原本的CLSID，可以更加一目了然的编辑Locomotor。具体对应关系见下表：
别称	CLSID
Drive	{4A582741-9839-11d1-B709-00A024DDAFD1}
Jumpjet	{92612C46-F71F-11d1-AC9F-006008055BB5}
Hover	{4A582742-9839-11d1-B709-00A024DDAFD1}
Rocket	{B7B49766-E576-11d3-9BD9-00104B972FE8}
Tunnel	{4A582743-9839-11d1-B709-00A024DDAFD1}
Walk	{4A582744-9839-11d1-B709-00A024DDAFD1}
DropPod	{4A582745-9839-11d1-B709-00A024DDAFD1}
Fly	{4A582746-9839-11d1-B709-00A024DDAFD1}
Teleport	{4A582747-9839-11d1-B709-00A024DDAFD1}
Mech	{55D141B8-DB94-11d1-AC98-006008055BB5}
Ship	{2BEA74E1-7CCA-11d3-BE14-00104B62A16C}

显示伤害数值
用以显示造成伤害数值快捷键。
该功能需要启用[GlobalControls]>DebugKeysEnabled才能使用。
遭遇战颜色
在尤复中遭遇战的所属方颜色被限定为8个，ARES 中限定为16个。现在可以设定无限多个遭遇战颜色。 
在rulesmd.ini中：
[General]►SkirmishUnlimitedColors= (boolean)
是否开启该功能。
启用后，游戏将会把传递的颜色索引作为[Colors]部分条目的索引。例如，索引6将对应于颜色Orange= 25,230,255。
注意：此功能只对外部客户端/启动器(例如CNCNet)有效，用在原版/尤复的启动器中可能会出现不良效果。
因不兼容问题，启用此功能将会禁用ARES的自定义下拉颜色。
战役游戏速度
现在可以改变战役默认的游戏速度(GS4/Fast/30FPS)了。 这是通过周期性地改变游戏帧之间的延迟，从而提高或降低FPS来实现的。
目前只能达到约10~60FPS。
在rulesmd.ini中：
[General]►CustomGS= (boolean)
是否可以更改战役的游戏速度。
[General]►CustomGS.ChangeInterval= (integer) 
填大于1的整数值(或-1)，表示增加延迟的周期，每多少帧插入一次延迟。例如：填写2表示每隔一帧，即每两帧；3表示每隔两帧，即每三帧。-1表示不启用，默认-1。
[General]►CustomGS.ChangeDelay= (integer) 
填0~6的整数值，表示周期增加的延迟数。
[General]►CustomGS.DefaultDelay= (integer) 
填0~6的整数值，表示正常帧数(不增加延迟)的延迟数。
 
注意：如果在游戏速度6(最快)时设置上面两个延迟数，FPS可能会超过60，不同的运行环境结果将有所不同。
目前你只能通过计算并设定上面的三个值来得到你所需要的FPS，而无法直接设置FPS。官方的英文说明书中有相关的 计算工具。
 
在RA2MD.ini中
[Phobos]►CampaignDefaultGameSpeed= (integer) 
战役的游戏速度。默认4。
文件拆分
新的文件拆分规则
Phobos中现在有了新的文件拆分规则。 
[$Include]
类比ARES中的[#include]。可以在rulesmd.ini、artmd.ini和soundmd.ini中使用该拆分规则。
在下面列出要包含的其他文件。例如：
[$Include]
0=rules1.ini
1=rules2.ini
注意： 你必须通过命令行参数 -Include 来启用新的拆分规则
 
警告： 启用该规则将会禁用ARES中的[#include]。
同时由于技术问题，包含的子文件的第一行有可能会被跳过，因此包含的子文件应该以空行或注释开头。
INI继承
Phobos中现在有了INI的继承规则。 此规则可以在任何INI文件中使用，例如：rulesmd.ini, artmd.ini, soundmd.ini和map。
你可以用$Inherits=让需要继承的部分(子级)从继承的来源部分(父级)中继承词条语句。
注意： 你必须通过命令行参数 -Inheritance 来启用新的拆分规则
例如：
[PARENT1SECTION]
[PARENT2SECTION]
[CHILDSECTION] 
$Inherits=PARENT1SECTION,PARENT2SECTION... 
当子级中缺少某个词条的值时，游戏将尝试使用父级中对应词条的值(父级也没有则使用默认值)。
当一个子级指定由逗号隔开的多个父级时，将按照从左到右的顺序，优先使用左侧父级的词条值。
 
注意：继承是可以递归嵌套的(父级可以有自己的父级)。
同时递归是深度优先的(在继承下一个父级之前，先检查当前父级是否有父级)。
 
警告：启用该规则将会禁用 ARES中的A:B式继承(官方声称如此，但目前并没有)。
相对于ARES继承，Phobos继承不再仅继承自己“上方”的段落，这导致INI书写结构可能需要一些调整。
同时取决于要读取的规则文件大小和硬件环境，此项功能可能会显著增加游戏的加载时间。
保存所有变量
现在可以设置一个新的快捷键来保存游戏内所有的本地变量至locals.ini，所有的全局变量至globals.ini，只有在debug标签启动时启用
每一节的变量会以当前任务相同的名字并用大写字母保存，如MYCAMPAIGN.MAP
若locals.ini或globals.ini不存在，phobos会自行创建
 
在rulesmd.ini中
[General]►SaveVariblesOnScenarioEnd=（boolean）
定义是否在任务结束后自动保存变量
用户界面特性
自定义图标
自定义game.exe图标
可以通过命令行参数-icon <路径>指定gamemd.exe的图标，路径可以是绝对路径也可以是相对路径（例如gamemd.exe -icon Resources/clienticon.ico）。 
屏蔽版本信息
屏蔽Ingame右上角的Phobos版本信息 
可以通过命令行参数 -b= <Build版本号> 来屏蔽右上角的版本信息(例如b36 为：-b=36)。
声音
现在可以指定玩家胜利或失败时播放的音轨。

[Side]►IngameScore.WinTheme= (theme id)
胜利时播放的音轨。
[Side]►IngameScore.LoseTheme= (theme id)
失败时播放的音轨。
快捷键指令
快速存档
保存当前单人游戏。如果需要本地化，只需要在.csf文件中增加TXT_QUICKSAVE，TXT_QUICKSAVE_DESC，TXT_QUICKSAVE_SUFFIX和MSG:NotAvailableInMultiplayer即可。原版CSF中的TXT_SAVING_GAME，TXT_GAME_WAS_SAVED和TXT_ERROR_SAVING_GAME将会被使用。存档名将会是地图名 - CSF -QuickSaved 

下一空闲矿车
选择并居中下一个被[矿车指示器]计数且处于空闲状态的单位。如果需要本地化，只需要在.csf文件中增加TXT_NEXT_IDLE_HARVESTER和TXT_NEXT_IDLE_HARVESTER_DESC即可。

数值显示开关
开启/关闭 数值显示功能相关显示效果。如果需要本地化，只需要在.csf文件中增加TXT_DIGITAL_DISPLAY和TXT_DIGIT AL_DISPLAY_DESC即可。
指示者/抑制者范围显示开关
开启/关闭 超武指示者/抑制者范围显示圈。如果需要本地化，只需要在.csf文件中增加TXT_DESIGNATOR_RANGE 和TXT_DESIGNATOR_RANGE_DESC 即可。

切换逐帧模式
开启/关闭 逐帧模式。在逐帧模式中可以使用不同的前进帧指令来一次前进1/5/10/15/30/60帧。
如果需要本地化，只需要在.csf文件中增加TXT_FRAME_BY_FRAME 和 TXT_FRAME_BY_FRAME_DESC 即可。

输出目标信息
该快捷键指令需要启用[GlobalControls]>DebugKeysEnabled才能使用
将当前鼠标悬浮或选中的目标信息写入日志并输出信息。如果需要本地化，只需要在.csf文件中增加TXT_DUMP_OBJECT_INFO和TXT_DUMP_OBJECT_INFO_DESC即可。 


显示伤害数值
该快捷键指令需要启用[GlobalControls]>DebugKeysEnabled才能使用
开启/关闭在造成伤害时显示漂浮的伤害数字。红色-伤害/蓝色-对护盾伤害/绿色-治疗/青色-对护盾治疗
数子会出现在受影响的单位上并且出现后会向上移动。如果需要本地化，只需要在.csf文件中增加
TXT_DISPLAY_DAMAGE 和TXT_DISPLAY_DAMAGE_DESC 即可。 


保存变量
该快捷键指令需要启用[GlobalControls]>DebugKeysEnabled才能使用
将当前所有局部变量写入locals.ini并将当前所有全局变量写入globals.ini。
如果在rulesmd.ini中设置了[General]>SaveVariablesOncinarioEnd=true，则变量也将在当前关卡结束时自动保存到文件中。
变量部分将使用与任务文件名相同的大写字母名称，例如[MYCAMPAIGN.MAP]。变量将被写成键值对，例如MyVariable=1。
如果不存在同名INI文件（locals.INI/globals.INI），则将创建该文件。如果存在，所有部分都将被保留。
如果需要本地化，只需要在.csf文件中增加TXT_SAVE_VARIABLES 和TXT_SAVE_VARIABLES_DESC即可。








战斗界面UI
框选低优先级
现在可以为游戏内的物体设定为低选择权重。这样的单位将不会在框选，T框选，Shift框选有正常选择权重的单位时被选中。

[TechnoType]►LowSelectionPriority= (boolean) 
是否为低选择权重。默认no。

用户可以自由指定是否启用这个逻辑。目前只能人工设置或内置到客户端中。
在RA2MD.ini中
[Phobos]►PrioritySelectionFiltering= (boolean)
是否开启低选择权重功能。默认yes。
隐藏血条
如果需要，血条可以被关闭显示。

[TechnoType]►HealthBar.Hide= (boolean)
是否关闭血条显示。默认no。
资金收入数值显示
现在可以在矿厂或回收厂获取资金时，设置更直观的数字显示。
注意：一秒内的多项资金收入会合并成一个数字显示出来。 
 
全局设置：
[AudioVisual]►DisplayIncome= (boolean)
是否显示资金收入的数值。默认no。
[AudioVisual]►DisplayIncome.Houses= (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
那个阵容可以看到资金收入显示的数值。默认all。
[AudioVisual]►DisplayIncome.AllowAI= (boolean) 
是否显示AI的资金收入数值。默认yes。
 
微观设置：
[BuildingTypes]►DisplayIncome= (boolean) 
是否显示该建筑的资金收入数值。默认no。
[BuildingTypes]►DisplayIncome= (enum none|owner/self|allies/ally|team|enemies/enemy|all) 
那个阵容可以看到该建筑的资金收入数值。默认all。
[BuildingTypes]►DisplayIncome.Offset= (X,Y) 
调整该建筑显示的资金收入数的绘制偏移。负数左/上，正数右/下。默认0,0。
建筑放置预览
[AudioVisual]►BuildingPlacementGrid.TranslucentLevel= (integer) 
建筑放置格子的透明度，0为0%，1%为25%，2为50%，3为75%。默认0。
[AudioVisual]►BuildingPlacementPreview.DefaultTranslucentLevel= (integer)
建筑放置预览的透明度，0为0%，1%为25%，2为50%，3为75%。默认0。
b36中语句迁移为：
[AudioVisual]►PlacementPreview.Translucency= (integer) 
建筑放置预览的透明度，可填值：0、25、50、75。默认75。
[AudioVisual]►PlacementGrid.Translucency= (integer) 
建筑放置格子的透明度，可填值：0、25、50、75。默认0。
[AudioVisual]►PlacementGrid.TranslucencyWithPreview= (integer) 
当PlacementPreview=no时，设置建筑放置格子的透明度，可填值：0、25、50、75。默认[AudioVisual]►PlacementGrid.Translucency=。
 
微观设置：
[BuildingType]►PlacementPreview.Show= (boolean) 
微观设置是否显示建筑放置预览。
b36中语句迁移为：
[BuildingType]►PlacementPreview= (boolean) 
该建筑是否显示建筑放置预览。
 
[BuildingType]►PlacementPreview.Shape= (filename, *excluding*the .shp extension)
建筑放置预览显示的内容。默认该建筑建造动画的最后一帧。
[BuildingType]►PlacementPreview.ShapeFrame= (integer)
建筑放置预览显示第几帧。
[BuildingType]►PlacementPreview.Offset= (X,Y,Z)
建筑放置预览显示的位置。默认0,-15,1。
[BuildingType]►PlacementPreview.Remap= (boolean)
建筑放置预览是否显示所属色。默认yes。
[BuildingType]►PlacementPreview.Palette= (filename, *including*the .pal extension)
建筑放置预览使用的色盘，如果上一个标签启用则这个标签无效。
 
[BuildingType]►PlacementPreview.TranslucentLevel= (integer)
微观设置建筑放置预览的透明度。
b36中语句迁移为：
[BuildingType]►PlacementPreview.Translucency= (integer) 
微观设置建筑放置预览的透明度，可填值：0、25、50、75。
 
用户可以自由指定是否启用这个逻辑。目前只能人工设置或内置到客户端中。
在RA2MD.ini中
[Phobos]►ShowBuildingPlacementPreview= (boolean)
是否开启建筑放置预览功能。默认no。
b36中语句迁移为：
[Phobos]►ShowPlacementPreview= (boolean) 
是否开启建筑放置预览功能。默认no。
计时器优先级
[SuperWeaponTypes]►ShowTimer.Priority= (integer)
设置超级武器计时器的优先级，数值越大优先级越高，位置越偏下。默认0。 
超武即时计时器
现在超武的倒计时可以以当前游戏速度计算出现实时间里需要等待的时间
默认情况下，即时计时器会依据当前游戏速度的帧速档位计算时间。若RealTimeTimers.Adaptive设置为true时，计时器会根据当前帧速的情况下，考虑进游戏延迟得出时间（最快游戏档位或自定义游戏速度时永远为true）
在RA2MD.ini中
[Phobos]►RealTimeTimers= (boolean)
是否启用超武即时计时功能，默认false。
[Phobos]►RealTimeTimers.Adaptive= (boolean)
是否启用超武即时计时的自适应功能，默认false。
闪光效果开关
现在可以手动关闭一些闪光效果，作用范围包括如下：
1.战斗闪光 (Bright=true)以及其他所有使用相同功能的效果,
例如铁幕和力场护盾效果闪光。
2.附加到弹头Particle=所生成的粒子系统或粒子上的AlphaImage图像（如果以下两条定义为true）。
[AudioVisual]►WarheadParticleAlphaImageIsLightFlash=(boolean)
全局定义是否将弹头Paticle=所生产粒子系统/粒子上的AlphaImage图像视为闪光效果。默认否。
[Warhead]►Particle.AlphaImageIsLightFlash=(boolean)
微观定义是否将该弹头Paticle=所生产粒子系统/粒子上的AlphaImage图像视为闪光效果。默认为上一条的设置值。
[AudioVisual]►LightFlashAlphaImageDetailLevel=(integer)
定义显示被视为闪光效果的AlphaImage图像的细节等级要求。默认0。
注意：如果LightFlashAlphaImageDetailLevel高于当前的细节等级设置，
则无视HideLightFlashEffects设置并且不创建被视为闪光效果的AlphaImage图像。
在RA2MD.ini中
[Phobos]►HideLightFlashEffects=(boolean)
定义是否关闭闪光效果。默认false。
侧边栏
指定侧边栏风格
现在可以切换侧边栏是否使用GDI侧边栏坐标。 

[Side]►Sidebar.GDIPositions= (boolean)
侧边栏是否使用GDI侧边栏坐标。第一阵营默认yes，其他阵营默认no。
图标排序
现在可以为任意单位或超武指定图标优先级。图标优先级是最优先检查的，大的优先级排在前面。

[TechnoType/SuperWeapon]►CameoPriority= (integer)
图标的优先级。默认0。
暂停界面居中
现在可以指定暂停界面位于屏幕的中心，而不总是在左上角。

[Sidebar]►CenterPauseMenuBackground= (boolean)
是否指定暂停界面位于屏幕的中心。默认no。
自定义缺省图标
现在可以指定任意SHP/PCX文件为缺省图标（XXICON.SHP）。
[AudioVisual]►MissingCameo= (filename, *including* the .pcx or .shp extension)
缺省图标。默认XXICON.SHP。
矿车指示器
[Sidebar]►HarvesterCounter.Label= (CSF label)
矿车指示器的显示标志。默认U+26CF。
[Sidebar]►HarvesterCounter.ConditionYellow= (double - percentage)
当工作的矿车占比低于这个百分比时，矿车指示器变为黄色。默认99%。
[Sidebar]►HarvesterCounter.ConditionRed= (double - percentage)
当工作的矿车占比低于这个百分比时，矿车指示器变为红色。默认50%。
 
在rulesmd.ini中
[TechnoType]►Harvester.Counted= (boolean)
是否算作矿车计算。如果油井这类建筑设置了，则在生产资金时会被记为工作。默认no。
[Side]►Sidebar.HarvesterCounter.Offset= (X,Y)
调整矿车指示器的位置。负数左/上，正数右/下。默认0,0。
[Side]►Sidebar.HarvesterCounter.ColorYellow= (R,G,B)
矿车指示器变黄时的颜色。默认255,255,0。
[Side]►Sidebar.HarvesterCounter.ColorRed= (R,G,B)
矿车指示器变红时的颜色。默认255,0,0。
 
在RA2MD.ini中
[Phobos]►ShowHarvesterCounter= (boolean)
全局调整是否显示矿车指示器。默认yes。

注意：如果使用矿车指示器功能可能需要下载增强字库（v4或更高版本）或是自行编辑字库。
生产进度
现在可以通过侧边栏了解到工厂的状态了。需要自行在sidec0x.mix中添加tab0xpp.shp(x对应的是生产项目，0为生产建筑，1为防御建筑，2为步兵，3为载具) 作为生产进度的素材。 
在uimd.ini中
[Sidebar]►ProducingProgress.Show= (boolean)
是否显示生产进度。默认no。
在rulesmd.ini中
[SomeSide]►Sidebar.ProducingProgress.Offset= (X,Y)
调整生产进度的位置。负数左/上，正数右/下。默认0,0。
电力变动指示器
在uimd.ini中
[Sidebar]►PowerDelta.Show= (boolean)
是否显示电力变动指示器。默认no。
[Sidebar]►PowerDelta.ConditionYellow= (double - percentage)
当负载比电力的比值高于这个百分比时，电力指示器变为黄色。默认75%。
[Sidebar]►PowerDelta.ConditionRed= (double - percentage)
当负载比电力的比值高于这个百分比时，电力指示器变为红色。默认100%。
 
在rulesmd.ini中
[Side]►Sidebar.PowerDelta.Offset= (X,Y)
调整电力指示器的位置。负数左/上，正数右/下。默认0,0。
[Side]►Sidebar.PowerDelta.ColorGreen= (R,G,B)
电力指示器的颜色。默认0,255,0。
[Side]►Sidebar.PowerDelta.ColorYellow= (R,G,B)
电力指示器变黄时的颜色。默认255,255,0。
[Side]►Sidebar.PowerDelta.ColorRed= (R,G,B)
电力指示器变红时的颜色。默认255,0,0。
[Side]►Sidebar.PowerDelta.ColorGrey= (R,G,B) 
电力指示器变灰时的颜色。默认128,128,128。
[Side]►Sidebar.PowerDelta.Align= (enum left|right|center/centre)
电力指示器的对齐方式。默认left。
 
在RA2MD.ini中
[Phobos]►ShowPowerDelta= (boolean)
全局调整是否显示电力指示器。默认yes。

 
注意：如果使用电力指示器功能可能需要下载增强字库（v4或更高版本）或是自行编辑字库。
泰伯利亚藤曼指示器
在uimd.ini中  
[Sidebar]►WeedsCounter.Show= (boolean)
是否显示泰伯利亚藤曼指示器。默认no。 
在rulesmd.ini中
[Sidebar]►Sidebar.WeedsCounter.Offset= (F,L,H)
微观调整泰伯利亚藤曼指示器的偏移位置。负数左/上，正数右/下，如若不设置会和矿车指示器重叠。
[Sidebar]►Sidebar.WeedsCounter.Color= (interger)
微观调整泰伯利亚指示器的颜色。如若不设置就用指示器的默认颜色。
在RA2MD.ini中
[Phobos]►ShowWeedsCounter= (boolean)
全局调整是否显示泰伯利亚藤曼指示器。默认yes。
载入屏幕
载入图像现在可以使用PCX格式，自定义载入屏幕可以通过Ares标签File.LoadScreen实现。

载入图的大小现在可以大于默认的800x600，一定为居中绘制。此功能是与CnCNet5生成器Dll搭配使用的，它将把载入界面固定为当前游戏分辨率大小并把载入图置于中间。如果没有CnCNet5生成器，那么载入分辨率将被锁定为800x600。

现在可以关闭YR引擎硬编码的黑点。
在uimd.ini中
[LoadingScreen]►DisableEmptySpawnPositions= (boolean)
是否关闭载入图中的黑点。默认no。
工具提示
鼠标悬浮在图标上时显示的工具提示现在可以更加详细了。拓展后TechnoType的工具提示将显示名称，所需资金，所需电力，建造时间，描述。SWType的工具提示将显示名称，所需资金，充能时间。
在uimd.ini中
[ToolTips]►ExtendedToolTips= (boolean)
是否开启工具提示。默认否。
[ToolTips]►CostLabel= (CSF label)
工具提示中所需资金的标志。默认U+0024。
[ToolTips]►PowerLabel= (CSF label)
工具提示中所需电力的标志。默认U+26A1。
[ToolTips]►TimeLabel= (CSF label)
工具提示中充能时间和建造时间的标志。默认U+231A。
[ToolTips]►MaxWidth= (integer)
工具提示栏的最大宽度。默认0，即不限制宽度。
[ToolTips]►SWShotsFormat=(CSF label)
工具提示中显示Ares的SW.Shots计数的格式，该格式使用C语言风格的字符串自定义。
默认为Shots: %d，如果使用双参数格式(如剩余次数%d/%d),则第二位参数是SW.Shots的定义值。
（例如SW.Shots=4的超武，已经发射1发，会显示剩余次数3/4）
[ToolTips]►AnchoredToolTips= (boolean)
是否将工具提示永远对齐在侧边栏处。默认false。
 
在rulesmd.ini中
[TechnoType/SuperWeapon]►UIDescription= (CSF label)
描述信息的内容。

用户可以自由指定是否启用这个逻辑。目前只能人工设置或内置到客户端中。
 
在RA2MD.ini中
[Phobos]►ToolTipDescriptions= (boolean)
是否开启工具提示功能。默认yes。
 
工具提示的背景颜色和不透明度现在也可以依据阵营进行自定义了
注意：请谨慎设置工具提示的阴影模糊效果
在rulesmd.ini中
全局设定： 
[AudioVisual]►ToolTip.Background.Color= (R,G,B) 
工具提示的背景颜色。默认0,0,0。
[AudioVisual]►ToolTip.Background.Opacity= (integer) 
工具提示的不透明度，填写1~100的数值。默认100。
[AudioVisual]►ToolTip.Background.BlurSize= (float) 
工具提示的阴影模糊效果。默认0.0。
阵营设定：
[Side]►ToolTip.Background.Color= (R,G,B)
该阵营工具提示的背景颜色。默认0,0,0。
[Side]►ToolTip.Background.Opacity= (integer) 
该阵营工具提示的不透明度，填写1~100的数值。默认100。
[Side]►ToolTip.Background.BlurSize= (float) 
该阵营工具提示的阴影模糊效果。默认0.0。
描述信息的内容。

用户可以自由指定是否启用这个逻辑。目前只能人工设置或内置到客户端中。
在RA2MD.ini中
[Phobos]►ToolTipBlur= (boolean)
是否开启工具提示的阴影模糊效果。默认no。 
数值显示

现在可以设置通过数值显示单位的信息了。
注意：数值显示的类型需要新增一个注册表[DigitalDisplayTypes]并在里面注册。


 
以下是数值显示类型可用语句：
[DigitalDisplayType]►InfoType= (enum health|shield|ammo|mindcontrol|spawns|passengers|tiberium|experience|occupants|gattlingstage)
数值显示的内容，如果没有相应的内容即使设置也不会显示。 
[DigitalDisplayType]►Offset= (X,Y) 
调整数值显示的位置。正数左/上，负数右/下。默认0,0。
[DigitalDisplayType]►Offset.ShieldDelta= (X,Y)
调整数值显示在有护盾时显示的位置。
[DigitalDisplayType]►Align= (enum left|right|center/centre) 
生命值数值的对齐方式。默认right。
[DigitalDisplayType]►Anchor.Horizontal= (enum left|center/centre|right)
生命值数值绘制位置在血条上水平位置的锚点。默认right。
[DigitalDisplayType]►Anchor.Vertical= (enum top|center/centre|bottom)
生命值数值绘制位置在血条上竖直位置的锚点。默认top。
[DigitalDisplayType]►Anchor.Building= (enum top|lefttop|leftright|bottom|rightbottom|righttop)
建筑生命值数值绘制位置在血条上位置的锚点。默认top。
[DigitalDisplayType]►Percentage= (boolean)
是否显示生命值的百分比而不是具体数值。默认no。
[DigitalDisplayType]►HideMaxValue= (boolean)
是否隐藏最大值。步兵默认yes，其他默认no。
[DigitalDisplayType]►VisibleToHouses= (none|owner/self|allies/ally|team|enemies/enemy|all)
数显的可见所属方，默认owner
[DigitalDisplayType]►VisibleToHouses.Observer= (boolean)

 数显是否观察者可见，默认yes
[DigitalDisplayType]►Text.Color= (R,G,B)
数值显示在百分比高于ConditionYellow时显示的颜色。默认0,255,0。
[DigitalDisplayType]►Text.Color.ConditionYellow= (R,G,B)
数值显示在百分比低于ConditionYellow但高于ConditionRed时显示的颜色。默认255,255,0。
[DigitalDisplayType]►Text.Color.ConditionRed= (R,G,B)
数值显示在百分比低于ConditionRed时显示的颜色。默认255,0,0。
[DigitalDisplayType]►Text.Background= (boolean)
数值显示后是否有黑色背景。默认否。
[DigitalDisplayType]►Shape= (filename, *including*the .shp extension)
shp数值显示使用的文件。
[DigitalDisplayType]►Palette= (filename, *including*the .pal extension)
shp数值显示使用的色盘。默认palette.pal。
[DigitalDisplayType]►Shape.Spacing= (X,Y)
shp数值显示的数字水平和竖直间隔。
 
全局设置
[AudioVisual]►Buildings.DefaultDigitalDisplayTypes= (list of DigitalDisplayTypes)
建筑使用的默认数值显示类型。
[AudioVisual]►Infantry.DefaultDigitalDisplayTypes= (list of DigitalDisplayTypes)
步兵使用的默认数值显示类型。
[AudioVisual]►Vehicles.DefaultDigitalDisplayTypes= (list of DigitalDisplayTypes)
载具使用的默认数值显示类型。
[AudioVisual]►Aircraft.DefaultDigitalDisplayTypes= (list of DigitalDisplayTypes)
飞机使用的默认数值显示类型。


 
微观设置
[TechnoType]►DigitalDisplayTypes= (list of DigitalDisplayTypes)
微观设定单位使用的数值显示类型。
[TechnoType]►DigitalDisplay.Disable= (boolean)
单位是否禁用数值显示。默认no。

 
用户可以自由指定是否启用这个逻辑。目前只能人工设置或内置到客户端中。
在RA2MD.ini中
[Phobos]►DigitalDisplay.Enable= (boolean)
是否开启数值显示功能。默认no。
显示指示者范围
 
用户可以自由指定是否启用这个逻辑。目前只能人工设置或内置到客户端中。
在RA2MD.ini中
[Phobos]►ShowDesignatorRange=（boolean）
是否启用显示指引者范围功能。
自定义计时器闪烁颜色
[AudioVisual]►TimerBlinkColorScheme=（integer） 
定义计时器闪烁时候的颜色。默认为[colors]里的第三个颜色
选中单位时闪烁
现在可以在选中单位时令其闪烁指定的帧数。
[AudioVisual]►SelectionFlashDuration= (integer)
选中单位时闪烁的帧数。设定为0则关闭此功能，不闪烁。默认0。
跳过战役自动保存
原版在开始新战役关卡时，游戏会自动保存。现在可以跳过这个自动保存。 
在RA2MD.ini中
[Phobos]►SaveGameOnScenarioStart= (boolean)
是否跳过战役的游戏自动保存。默认true。
